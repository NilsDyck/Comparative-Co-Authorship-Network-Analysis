Name;Title;Co-Authors;Pagintation;Published in;LNCS-link;Abstract
Cristian Calude;Automata: From Uncertainty to Quantum.;Elena Calude;[<span itemprop="pagination">1-14</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_1;Automata are simple mathematical objects with unexpected computational, mathematical, modelling and explanatory capabilities. This paper examines some relations between automata and physics. Automata will be used to model quantum uncertainty and quantum computation. Finally, mathematical proofs will be discussed from the perspective of quantum automata.
Elena Calude;Automata: From Uncertainty to Quantum.;Cristian Calude;[<span itemprop="pagination">1-14</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_1;Automata are simple mathematical objects with unexpected computational, mathematical, modelling and explanatory capabilities. This paper examines some relations between automata and physics. Automata will be used to model quantum uncertainty and quantum computation. Finally, mathematical proofs will be discussed from the perspective of quantum automata.
Christian Choffrut;Elementary Theory of Ordinals with Addition and Left Translation by omega.;;[<span itemprop="pagination">15-20</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_2;After Büchi it has become very natural to interprete formulae of certain logical theories as finite automata, i.e., as recognizing devices. This recognition aspect though, was neglected by the inventor of the concept and the study of the families of linear structures that could be accepted in the language theory sense of the term, was carried out by other authors. The most popular field of application of Büchi type automata is nowadays connected with model checking by considering a process as a possibly infinite sequence of events. For over a decade, the original model has been enriched by adding a time parameter in order to model reactive systems and their properties. Originally Büchi was interested in the monadic second order theory with the successor over ω but he later considered the theory of countable ordinals for which he was led to propose new notions of finite automata. Again these constructs can be viewed as recognizing devices ofwords over a finite alphabet whose length are countable ordinals. They were studied by other authors, mainly Choueka and Wojciechowski to who we owe two Theorems “à la Kleene” asserting the equivalence between expressions using suitable rational operators and subsets (languages) of transfinite words, [6] and [13].
Zoltán Ésik;The Equational Theory of Fixed Points with Applications to Generalized Language Theory.;;[<span itemprop="pagination">21-36</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_3;We review the rudiments of the equational logic of (least) fixed points and provide some of its applications for axiomatization problems with respect to regular languages, tree languages, and synchronization trees.
Thomas Eiter;Second-Order Logic over Strings: Regular and Non-regular Fragments.;Georg Gottlob, Thomas Schwentick;[<span itemprop="pagination">37-56</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_4;By a well-known result due to Büchi and Trakhtenbrot, all monadic second-order sentences over words describe regular languages. In this paper, we investigate prefix classes of general second-order logic. Such a prefix class is called regular, if each of its sentences describes a regular language, and nonregular otherwise. Recently, the regular and nonregular prefix classes of existential second order logic (Σ11) were exhaustively determined. We briefly recall these results and continue this line of research by systematically investigating the syntactically more complex prefix classes Σ1k(Q) of second-order logic for each integer k &gt. 1 and for each first-order quantifier prefix Q. We give an exhaustive classification of the regular and nonregular prefix classes of this form, and derive of complexity results for the corresponding model checking problems. We also give a brief survey of recent results on the complexity of evaluating existential second-order logic over graphs, and a list of interesting open problems.
Georg Gottlob;Second-Order Logic over Strings: Regular and Non-regular Fragments.;Thomas Eiter, Thomas Schwentick;[<span itemprop="pagination">37-56</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_4;By a well-known result due to Büchi and Trakhtenbrot, all monadic second-order sentences over words describe regular languages. In this paper, we investigate prefix classes of general second-order logic. Such a prefix class is called regular, if each of its sentences describes a regular language, and nonregular otherwise. Recently, the regular and nonregular prefix classes of existential second order logic (Σ11) were exhaustively determined. We briefly recall these results and continue this line of research by systematically investigating the syntactically more complex prefix classes Σ1k(Q) of second-order logic for each integer k &gt. 1 and for each first-order quantifier prefix Q. We give an exhaustive classification of the regular and nonregular prefix classes of this form, and derive of complexity results for the corresponding model checking problems. We also give a brief survey of recent results on the complexity of evaluating existential second-order logic over graphs, and a list of interesting open problems.
Thomas Schwentick;Second-Order Logic over Strings: Regular and Non-regular Fragments.;Thomas Eiter, Georg Gottlob;[<span itemprop="pagination">37-56</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_4;By a well-known result due to Büchi and Trakhtenbrot, all monadic second-order sentences over words describe regular languages. In this paper, we investigate prefix classes of general second-order logic. Such a prefix class is called regular, if each of its sentences describes a regular language, and nonregular otherwise. Recently, the regular and nonregular prefix classes of existential second order logic (Σ11) were exhaustively determined. We briefly recall these results and continue this line of research by systematically investigating the syntactically more complex prefix classes Σ1k(Q) of second-order logic for each integer k &gt. 1 and for each first-order quantifier prefix Q. We give an exhaustive classification of the regular and nonregular prefix classes of this form, and derive of complexity results for the corresponding model checking problems. We also give a brief survey of recent results on the complexity of evaluating existential second-order logic over graphs, and a list of interesting open problems.
Tero Harju;Decision Questions on Integer Matrices.;;[<span itemprop="pagination">57-68</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_5;We give a survey of simple undecidability results and open problems concerning matrices of low order with integer entries. Connections to the theory of finite automata (with multiplicities) are also provided.
Masami Ito;Some Petri Net Languages and Codes.;Yoshiyuki Kunimoch;[<span itemprop="pagination">69-80</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_6;In this paper, we consider the language over an alphabet T generated by a given Petri net with a positive initial marking, called a CPN language. This language becomes a prefix code over T. We are interested in CPN languages which are maximal prefix codes, called mCPN languages over T. We will investigate various properties of mCPN languages. Moreover, we will prove that a CPN language is a context-sensitive language in two different ways.
Yoshiyuki Kunimoch;Some Petri Net Languages and Codes.;Masami Ito;[<span itemprop="pagination">69-80</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_6;In this paper, we consider the language over an alphabet T generated by a given Petri net with a positive initial marking, called a CPN language. This language becomes a prefix code over T. We are interested in CPN languages which are maximal prefix codes, called mCPN languages over T. We will investigate various properties of mCPN languages. Moreover, we will prove that a CPN language is a context-sensitive language in two different ways.
Helmut Prodinger;Words, Permutations, and Representations of Numbers.;;[<span itemprop="pagination">81-99</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_7;In this survey paper we consider words, where the letters are interpreted to be numbers or digits. In the first part, natural numbers are weighted with probabilities (from the geometric distribution). Several properties and parameters of sets of such words are analyzed probabilistically. the case of permutations is a limiting case. In the second part, the representation of Gaussian integers to the base -2 + i is considered, as well as redundant representations to the base q, where the digits can be arbitrary integers.
Alexander A. Razborov;Proof Complexity of Pigeonhole Principles.;;[<span itemprop="pagination">100-116</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_8;The pigeonhole principle asserts that there is no injective mapping from m pigeons to n holes as long as m &gt. n. It is amazingly simple, expresses one of the most basic primitives in mathematics and Theoretical Computer Science (counting) and, for these reasons, is probably the most extensively studied combinatorial principle. In this survey we try to summarize what is known about its proof complexity, and what we would still like to prove.We also mention some applications of the pigeonhole principle to the study of efficient provability of major open problems in computational complexity, as well as some of its generalizations in the form of general matching principles.
Antonio Restivo;Words and Patterns.;Sergio Salemi;[<span itemprop="pagination">117-129</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_9;In this paper some new ideas, problems and results on patterns are proposed. In particular, motivated by questions concerning avoidability, we first study the set of binary patterns that can occur in one infinite binary word, comparing it with the set of factors of the word. This suggests a classification of infinite words in terms of the “difference” between the set of its patterns and the set of its factors. The fact that each factor in an infinite word can give rise to several distinct patterns leads to study the set of patterns of a single finite word. This set, endowed with a natural order relation, defines a poset: we investigate the relationships between the structure of such a poset and the combinatorial properties of the word. Finally we show that the set of patterns of the words in a regular language is a regular language too.
Sergio Salemi;Words and Patterns.;Antonio Restivo;[<span itemprop="pagination">117-129</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_9;In this paper some new ideas, problems and results on patterns are proposed. In particular, motivated by questions concerning avoidability, we first study the set of binary patterns that can occur in one infinite binary word, comparing it with the set of factors of the word. This suggests a classification of infinite words in terms of the “difference” between the set of its patterns and the set of its factors. The fact that each factor in an infinite word can give rise to several distinct patterns leads to study the set of patterns of a single finite word. This set, endowed with a natural order relation, defines a poset: we investigate the relationships between the structure of such a poset and the combinatorial properties of the word. Finally we show that the set of patterns of the words in a regular language is a regular language too.
Wolfgang Thomas;A Short Introduction to Infinite Automata.;;[<span itemprop="pagination">130-144</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_10;Infinite automata are of interest not only in the verification of systems with infinite state spaces, but also as a natural (and so far underdeveloped) framework for the study of formal languages. In this survey, we discuss some basic types of infinite automata, which are based on the so-called prefix-recognizable, synchronized rational, and rational transition graphs, respectively. We present characterizations of these transition graphs (due to Muller/Schupp and to Caucal and students), mention results on their power to recognize languages, and discuss the status of central algorithmic problems (like reachability of given states, or decidability of the first-order theory).
Thierry Cachat;The Power of One-Letter Rational Languages.;;[<span itemprop="pagination">145-154</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_11;For any language L, let pow(L) = uj ∣ j ≥ 0, u ε L be the set of powers of elements of L. Given a rational language L (over a finite alphabet), we study the question, posed in [3], whether pow(L) is rational or not. While leaving open the problem in general, we provide an algorithmic solution for the case of one-letter alphabets. This case is still non trivial. our solution is based on Dirichlet’s result that for two relatively prime numbers, their associated arithmetic progression contains infinitely many primes.
Ludwig Staiger;The Entropy of Lukasiewicz-Languages.;;[<span itemprop="pagination">155-165</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_12;The paper presents an elementary approach for the calculation of the entropy of a class of context-free languages. This approach is based on the consideration of roots of a real polynomial and is also suitable for calculating the Bernoulli measure.
Dimitry S. Ananichev;Collapsing Words vs. Synchronizing Words.;Mikhail V. Volkov;[<span itemprop="pagination">166-174</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_13;We investigate the relationships between two types of words that have recently arisen in studying “black-box” versions of the famous Černý problem on synchronizing automata. Considering the languages formed by words of each of these types, we verify that one of them is regular while the other is not, thus showing that the two notions in question are different. We also discuss certain open problems concerning words of minimum length in these languages.
Mikhail V. Volkov;Collapsing Words vs. Synchronizing Words.;Dimitry S. Ananichev;[<span itemprop="pagination">166-174</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_13;We investigate the relationships between two types of words that have recently arisen in studying “black-box” versions of the famous Černý problem on synchronizing automata. Considering the languages formed by words of each of these types, we verify that one of them is regular while the other is not, thus showing that the two notions in question are different. We also discuss certain open problems concerning words of minimum length in these languages.
Karel Culík II;A Note on Synchronized Automata and Road Coloring Problem.;Juhani Karhumäki, Jarkko Kari;[<span itemprop="pagination">175-185</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_14;We consider a problem of labeling a directed multigraph so that it becomes a synchronized finite automaton, as an ultimate goal to solve the famous Road Coloring Conjecture, cf. [1],[2].We introduce a relabeling method which can be used for a large class of automata to improve their “degree of synchronization”. This allows, for example, to formulate the conjecture in several equivalent ways.
Juhani Karhumäki;A Note on Synchronized Automata and Road Coloring Problem.;Karel Culík II, Jarkko Kari;[<span itemprop="pagination">175-185</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_14;We consider a problem of labeling a directed multigraph so that it becomes a synchronized finite automaton, as an ultimate goal to solve the famous Road Coloring Conjecture, cf. [1],[2].We introduce a relabeling method which can be used for a large class of automata to improve their “degree of synchronization”. This allows, for example, to formulate the conjecture in several equivalent ways.
Jarkko Kari;A Note on Synchronized Automata and Road Coloring Problem.;Karel Culík II, Juhani Karhumäki;[<span itemprop="pagination">175-185</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_14;We consider a problem of labeling a directed multigraph so that it becomes a synchronized finite automaton, as an ultimate goal to solve the famous Road Coloring Conjecture, cf. [1],[2].We introduce a relabeling method which can be used for a large class of automata to improve their “degree of synchronization”. This allows, for example, to formulate the conjecture in several equivalent ways.
Cezar Câmpeanu;Shuffle Quotient and Decompositions.;Kai Salomaa, Sándor Vágvölgyi;[<span itemprop="pagination">186-196</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_15;We introduce a right congruence relation that is the analogy of the Nerode congruence when catenation is replaced by shuffle. Using this relation we show that for certain subclasses of regular languages the shuffle decomposition problem is decidable. We show that shuffle decomposition is undecidable for context-free languages.
Kai Salomaa;Shuffle Quotient and Decompositions.;Cezar Câmpeanu, Sándor Vágvölgyi;[<span itemprop="pagination">186-196</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_15;We introduce a right congruence relation that is the analogy of the Nerode congruence when catenation is replaced by shuffle. Using this relation we show that for certain subclasses of regular languages the shuffle decomposition problem is decidable. We show that shuffle decomposition is undecidable for context-free languages.
Sándor Vágvölgyi;Shuffle Quotient and Decompositions.;Cezar Câmpeanu, Kai Salomaa;[<span itemprop="pagination">186-196</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_15;We introduce a right congruence relation that is the analogy of the Nerode congruence when catenation is replaced by shuffle. Using this relation we show that for certain subclasses of regular languages the shuffle decomposition problem is decidable. We show that shuffle decomposition is undecidable for context-free languages.
Gundula Niemann;The Growing Context-Sensitive Languages Are the Acyclic Context-Sensitive Languages.;Jens R. Woinowski;[<span itemprop="pagination">197-205</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_16;The growing context-sensitive languages have been defined by Dahlhaus and Warmuth using strictly monotone grammars, and they have been characterized by Buntrock and Lory’s by weight-increasing grammars. The acyclic context-sensitive languages are defined by context-sensitive grammars the contextfree kernels of which contain no cycles of chain rules, which is equivalent to being context-sensitive and weight-increasing at the same time. p] In this paper we show that these two language classes coincide, that is, for each weight-increasing grammar there exists an equivalent one that is weight-increasing and context-sensitive at the same time.
Jens R. Woinowski;The Growing Context-Sensitive Languages Are the Acyclic Context-Sensitive Languages.;Gundula Niemann;[<span itemprop="pagination">197-205</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_16;The growing context-sensitive languages have been defined by Dahlhaus and Warmuth using strictly monotone grammars, and they have been characterized by Buntrock and Lory’s by weight-increasing grammars. The acyclic context-sensitive languages are defined by context-sensitive grammars the contextfree kernels of which contain no cycles of chain rules, which is equivalent to being context-sensitive and weight-increasing at the same time. p] In this paper we show that these two language classes coincide, that is, for each weight-increasing grammar there exists an equivalent one that is weight-increasing and context-sensitive at the same time.
Dietrich Kuske;Recognizable Sets of N-Free Pomsets Are Monadically Axiomatizable.;;[<span itemprop="pagination">206-216</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_17;It is shown that any recognizable set of finite N-free pomsets is axiomatizable in counting monadic second order logic. Differently from similar results by Courcelle, Kabanets, and Lapoire, we do not use MSO-transductions (i.e., one-dimensional interpretations), but two-dimensional interpretations of a generating tree in an N-free pomset. Then we have to deal with the new problem that set-quantifications over the generating tree are translated into quantifications over binary relations in the N-free pomset. This is solved by an adaptation of a result by Potthoff &amp. Thomas on monadic antichain logic.
Zoltán Ésik;Automata on Series-Parallel Biposets.;Zoltán L. Németh;[<span itemprop="pagination">217-227</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_18;We provide the basics of a 2-dimensional theory of automata on seriesparallel biposets. We define recognizable, regular and rational sets of seriesparallel biposets and study their relationship. Moreover, we relate these classes to languages of series-parallel biposets definable in monadic second-order logic.
Zoltán L. Németh;Automata on Series-Parallel Biposets.;Zoltán Ésik;[<span itemprop="pagination">217-227</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_18;We provide the basics of a 2-dimensional theory of automata on seriesparallel biposets. We define recognizable, regular and rational sets of seriesparallel biposets and study their relationship. Moreover, we relate these classes to languages of series-parallel biposets definable in monadic second-order logic.
Joost Engelfriet;Hierarchies of String Languages Generated by Deterministic Tree Transducers.;Sebastian Maneth;[<span itemprop="pagination">228-238</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_19;The composition of total deterministic macro tree transducers gives rise to a proper hierarchy with respect to the generated string languages (these are the languages obtained by taking the yields of the output trees). The same holds for attributed tree transducers, for controlled EDT0L systems, and for YIELD mappings (which shows properness of the IO-hierarchy).
Sebastian Maneth;Hierarchies of String Languages Generated by Deterministic Tree Transducers.;Joost Engelfriet;[<span itemprop="pagination">228-238</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_19;The composition of total deterministic macro tree transducers gives rise to a proper hierarchy with respect to the generated string languages (these are the languages obtained by taking the yields of the output trees). The same holds for attributed tree transducers, for controlled EDT0L systems, and for YIELD mappings (which shows properness of the IO-hierarchy).
Thomas Schwentick;Partially-Ordered Two-Way Automata: A New Characterization of DA.;Denis Thérien, Heribert Vollmer;[<span itemprop="pagination">239-250</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_20;In this paper,we consider finite automata with the restriction that whenever the automaton leaves a state it never returns to it. Equivalently we may assume that the states set is partially ordered and the automaton may never move “backwards” to a smaller state. p] We show that different types of partially-ordered automata characterize different language classes between level 1 and 3/2 of the Straubing-Thérien-Hierarchy. p] In particular, we prove that partially-ordered 2-way DFAs recognize exactly the class UL of unambiguous languages introduced by Schützenberger in 1976. As shown by Schützenberger, this class coincides with the class of those languages whose syntactic monoid is in the variety DA, a specific subclass of all “groupfree” (or “aperiodic”) semigroups.DA has turned out to possess a lot of appealing characterizations. Our result adds one more to these: partially-ordered two-way automata recognize exactly those languages whose syntactic monoid is in DA.
Denis Thérien;Partially-Ordered Two-Way Automata: A New Characterization of DA.;Thomas Schwentick, Heribert Vollmer;[<span itemprop="pagination">239-250</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_20;In this paper,we consider finite automata with the restriction that whenever the automaton leaves a state it never returns to it. Equivalently we may assume that the states set is partially ordered and the automaton may never move “backwards” to a smaller state. p] We show that different types of partially-ordered automata characterize different language classes between level 1 and 3/2 of the Straubing-Thérien-Hierarchy. p] In particular, we prove that partially-ordered 2-way DFAs recognize exactly the class UL of unambiguous languages introduced by Schützenberger in 1976. As shown by Schützenberger, this class coincides with the class of those languages whose syntactic monoid is in the variety DA, a specific subclass of all “groupfree” (or “aperiodic”) semigroups.DA has turned out to possess a lot of appealing characterizations. Our result adds one more to these: partially-ordered two-way automata recognize exactly those languages whose syntactic monoid is in DA.
Heribert Vollmer;Partially-Ordered Two-Way Automata: A New Characterization of DA.;Thomas Schwentick, Denis Thérien;[<span itemprop="pagination">239-250</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_20;In this paper,we consider finite automata with the restriction that whenever the automaton leaves a state it never returns to it. Equivalently we may assume that the states set is partially ordered and the automaton may never move “backwards” to a smaller state. p] We show that different types of partially-ordered automata characterize different language classes between level 1 and 3/2 of the Straubing-Thérien-Hierarchy. p] In particular, we prove that partially-ordered 2-way DFAs recognize exactly the class UL of unambiguous languages introduced by Schützenberger in 1976. As shown by Schützenberger, this class coincides with the class of those languages whose syntactic monoid is in the variety DA, a specific subclass of all “groupfree” (or “aperiodic”) semigroups.DA has turned out to possess a lot of appealing characterizations. Our result adds one more to these: partially-ordered two-way automata recognize exactly those languages whose syntactic monoid is in DA.
Christian Glaßer;Level 5/2 of the Straubing-Thérien Hierarchy for Two-Letter Alphabets.;Heinz Schmitz;[<span itemprop="pagination">251-261</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_21;We prove an effective characterization of level 5/2 of the Straubing-Thérien hierarchy for the restricted case of languages defined over a two-letter alphabet.
Heinz Schmitz;Level 5/2 of the Straubing-Thérien Hierarchy for Two-Letter Alphabets.;Christian Glaßer;[<span itemprop="pagination">251-261</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_21;We prove an effective characterization of level 5/2 of the Straubing-Thérien hierarchy for the restricted case of languages defined over a two-letter alphabet.
Juraj Hromkovic;On the Power of Randomized Pushdown Automata.;Georg Schnitger;[<span itemprop="pagination">262-271</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_22;Although randomization is now a standard tool for the design of efficient algorithms or for building simpler systems, we are far from fully understanding the power of randomized computing. Hence it is advisable to study randomization for restricted models of computation.We followthis approach by investigating the power of randomization for pushdown automata.
Georg Schnitger;On the Power of Randomized Pushdown Automata.;Juraj Hromkovic;[<span itemprop="pagination">262-271</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_22;Although randomization is now a standard tool for the design of efficient algorithms or for building simpler systems, we are far from fully understanding the power of randomized computing. Hence it is advisable to study randomization for restricted models of computation.We followthis approach by investigating the power of randomization for pushdown automata.
Gerhard Lischke;The Root of a Language and Its Complexity.;;[<span itemprop="pagination">272-280</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_23;The root of a language L is the set of all primitive words p such that pn belongs to L for some n ≥ 1. We show that the gap between the time complexity and space complexity, respectively, of a language and that of its root can be arbitrarily great. From this we conclude that there exist regular languages the roots of which are not even context-sensitive. Also we show that the quadratic time complexity for deciding the set of all primitive words by an 1-tape Turing machine is optimal.
Henning Fernau;Valuated and Valence Grammars: An Algebraic View.;Ralf Stiebe;[<span itemprop="pagination">281-292</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_24;Valence grammars were introduced by Gh. Păun in [8] as a grammatical model of chemical processes. Here, we focus on discussing a simpler variant which we call valuated grammars.We give some algebraic characterizations of the corresponding language classes. Similarly,we obtain an algebraic characterization of the linear languages. We also give some Nivat-like representations of valence transductions.
Ralf Stiebe;Valuated and Valence Grammars: An Algebraic View.;Henning Fernau;[<span itemprop="pagination">281-292</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_24;Valence grammars were introduced by Gh. Păun in [8] as a grammatical model of chemical processes. Here, we focus on discussing a simpler variant which we call valuated grammars.We give some algebraic characterizations of the corresponding language classes. Similarly,we obtain an algebraic characterization of the linear languages. We also give some Nivat-like representations of valence transductions.
Hendrik Jan Hoogeboom;Context-Free Valence Grammars - Revisited.;;[<span itemprop="pagination">293-303</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_25;Context-free valence languages (over ℤк) are shown to be codings of the intersection of a context-free language and a blind к-counter language. This afl-style characterization allows one to infer some of the properties of the family of valence languages, in particular the ⋋-free normal form proved by Fernau and Stiebe.
Vesa Halava;An Undecidability Result Concerning Periodic Morphisms.;Tero Harju;[<span itemprop="pagination">304-310</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_26;The following universe problem for the equality sets is shown to be undecidable: given a weak coding h, and two morphisms g1, g2, where g2 is periodic, determine whether or not h(EG(g1, g2)) = ∑+, where EG(g1, g2) consists of the solutions ω to the equation g1(ω) = #g2(ω) for a fixed letter #. The problem is trivially decidable, if instead of EG(g1, g2) the equality set E(g1, g2) (without a marker symbol #) is chosen.
Tero Harju;An Undecidability Result Concerning Periodic Morphisms.;Vesa Halava;[<span itemprop="pagination">304-310</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_26;The following universe problem for the equality sets is shown to be undecidable: given a weak coding h, and two morphisms g1, g2, where g2 is periodic, determine whether or not h(EG(g1, g2)) = ∑+, where EG(g1, g2) consists of the solutions ω to the equation g1(ω) = #g2(ω) for a fixed letter #. The problem is trivially decidable, if instead of EG(g1, g2) the equality set E(g1, g2) (without a marker symbol #) is chosen.
Manfred Kudlek;A Universal Turing Machine with 3 States and 9 Symbols.;Yurii Rogozhin;[<span itemprop="pagination">311-318</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_27;With an UTM(3,9) we present a new small universal Turing machine with 3 states and 9 symbols, improving a former result of an UTM(3,10).
Yurii Rogozhin;A Universal Turing Machine with 3 States and 9 Symbols.;Manfred Kudlek;[<span itemprop="pagination">311-318</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_27;With an UTM(3,9) we present a new small universal Turing machine with 3 states and 9 symbols, improving a former result of an UTM(3,10).
Michael Domaratzki;Minimal Covers of Formal Languages.;Jeffrey O. Shallit, Sheng Yu;[<span itemprop="pagination">319-329</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_28;Let L,L′ be languages. If L ⫅ L′, we say that L′ covers L. Let C,D be two classes of languages. If L′ ∈ C, we say that L′ is a minimal C-cover with respect to D if whenever L ⫅ L″ ⫅ L′ and L″∈ C, we have L′ - L″ ∈ D. In this paper we discuss minimal C-covers with respect to finite languages, when C is the class of regular languages.
Jeffrey O. Shallit;Minimal Covers of Formal Languages.;Michael Domaratzki, Sheng Yu;[<span itemprop="pagination">319-329</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_28;Let L,L′ be languages. If L ⫅ L′, we say that L′ covers L. Let C,D be two classes of languages. If L′ ∈ C, we say that L′ is a minimal C-cover with respect to D if whenever L ⫅ L″ ⫅ L′ and L″∈ C, we have L′ - L″ ∈ D. In this paper we discuss minimal C-covers with respect to finite languages, when C is the class of regular languages.
Sheng Yu;Minimal Covers of Formal Languages.;Michael Domaratzki, Jeffrey O. Shallit;[<span itemprop="pagination">319-329</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_28;Let L,L′ be languages. If L ⫅ L′, we say that L′ covers L. Let C,D be two classes of languages. If L′ ∈ C, we say that L′ is a minimal C-cover with respect to D if whenever L ⫅ L″ ⫅ L′ and L″∈ C, we have L′ - L″ ∈ D. In this paper we discuss minimal C-covers with respect to finite languages, when C is the class of regular languages.
Gundula Niemann;Some Regular Languages That Are Church-Rosser Congruential.;Johannes Waldmann;[<span itemprop="pagination">330-339</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_29;In 1988 McNaughton et al introduced the class CRCL of Church-Rosser congruential languages as a way to define formal languages by confluent length-reducing string-rewriting systems. As other congruential language classes CRCL is quite limited, although it contains some languages that are not contextfree. In 2000 Niemann has shown that at least each regular language with polynomial density is Church-Rosser congruential. It is still an open question whether the class of regular languages is contained in CRCL. Here we give some families of regular languages of exponential density that are Church-Rosser congruential. More precisely, we show that some shuffle languages, as well as Level 1 of the Straubing-Thérien hierarchy, are in CRCL, using a sufficient condition under which a regular language is Church-Rosser congruential. Last, we give a family of group languages that are Church-Rosser congruential, but do not fulfill this condition.
Johannes Waldmann;Some Regular Languages That Are Church-Rosser Congruential.;Gundula Niemann;[<span itemprop="pagination">330-339</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_29;In 1988 McNaughton et al introduced the class CRCL of Church-Rosser congruential languages as a way to define formal languages by confluent length-reducing string-rewriting systems. As other congruential language classes CRCL is quite limited, although it contains some languages that are not contextfree. In 2000 Niemann has shown that at least each regular language with polynomial density is Church-Rosser congruential. It is still an open question whether the class of regular languages is contained in CRCL. Here we give some families of regular languages of exponential density that are Church-Rosser congruential. More precisely, we show that some shuffle languages, as well as Level 1 of the Straubing-Thérien hierarchy, are in CRCL, using a sufficient condition under which a regular language is Church-Rosser congruential. Last, we give a family of group languages that are Church-Rosser congruential, but do not fulfill this condition.
Martin Beaudry;On the Relationship between the McNaughton Families of Languages and the Chomsky Hierarchy.;Markus Holzer, Gundula Niemann, Friedrich Otto;[<span itemprop="pagination">340-348</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_30;By generalizing the Church-Rosser languages the McNaughton families of languages are obtained. Here we concentrate on those families that are defined by monadic or special string-rewriting systems. We investigate the relationship of these families to each other and to the lower classes of the Chomsky hierarchy and present some closure and some non-closure properties for them. Moreover, we address some complexity issues for their membership problems.
Markus Holzer;On the Relationship between the McNaughton Families of Languages and the Chomsky Hierarchy.;Martin Beaudry, Gundula Niemann, Friedrich Otto;[<span itemprop="pagination">340-348</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_30;By generalizing the Church-Rosser languages the McNaughton families of languages are obtained. Here we concentrate on those families that are defined by monadic or special string-rewriting systems. We investigate the relationship of these families to each other and to the lower classes of the Chomsky hierarchy and present some closure and some non-closure properties for them. Moreover, we address some complexity issues for their membership problems.
Gundula Niemann;On the Relationship between the McNaughton Families of Languages and the Chomsky Hierarchy.;Martin Beaudry, Markus Holzer, Friedrich Otto;[<span itemprop="pagination">340-348</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_30;By generalizing the Church-Rosser languages the McNaughton families of languages are obtained. Here we concentrate on those families that are defined by monadic or special string-rewriting systems. We investigate the relationship of these families to each other and to the lower classes of the Chomsky hierarchy and present some closure and some non-closure properties for them. Moreover, we address some complexity issues for their membership problems.
Friedrich Otto;On the Relationship between the McNaughton Families of Languages and the Chomsky Hierarchy.;Martin Beaudry, Markus Holzer, Gundula Niemann;[<span itemprop="pagination">340-348</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_30;By generalizing the Church-Rosser languages the McNaughton families of languages are obtained. Here we concentrate on those families that are defined by monadic or special string-rewriting systems. We investigate the relationship of these families to each other and to the lower classes of the Chomsky hierarchy and present some closure and some non-closure properties for them. Moreover, we address some complexity issues for their membership problems.
Filippo Mignosi;Forbidden Factors and Fragment Assembly.;Antonio Restivo, Marinella Sciortino;[<span itemprop="pagination">349-358</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_31;In this paper we approach the fragment assembly problem by using the notion of minimal forbidden factors introduced in previous paper. Denoting by M(w) the set of minimal forbidden factors of a word w, we first focus on the evaluation of the size of elements in M(w) and on designing of an algorithm to recover the word w from M(w). Actually we prove that for a word w randomly generated by a memoryless source with identical symbol probabilities, the maximal length m(w) of words in M(w) is logarithmic and that the reconstruction algorithm runs in linear time. These results have an interesting application to the fragment assembly problem, i.e. reconstruct a word w from a given set I of substrings (fragments). Indeed under a suitable hypothesis on the set of fragments I, one can detect the elements of M(w) by looking at the minimal forbidden factors of elements in I and then apply the reconstruction algorithm.
Antonio Restivo;Forbidden Factors and Fragment Assembly.;Filippo Mignosi, Marinella Sciortino;[<span itemprop="pagination">349-358</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_31;In this paper we approach the fragment assembly problem by using the notion of minimal forbidden factors introduced in previous paper. Denoting by M(w) the set of minimal forbidden factors of a word w, we first focus on the evaluation of the size of elements in M(w) and on designing of an algorithm to recover the word w from M(w). Actually we prove that for a word w randomly generated by a memoryless source with identical symbol probabilities, the maximal length m(w) of words in M(w) is logarithmic and that the reconstruction algorithm runs in linear time. These results have an interesting application to the fragment assembly problem, i.e. reconstruct a word w from a given set I of substrings (fragments). Indeed under a suitable hypothesis on the set of fragments I, one can detect the elements of M(w) by looking at the minimal forbidden factors of elements in I and then apply the reconstruction algorithm.
Marinella Sciortino;Forbidden Factors and Fragment Assembly.;Filippo Mignosi, Antonio Restivo;[<span itemprop="pagination">349-358</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_31;In this paper we approach the fragment assembly problem by using the notion of minimal forbidden factors introduced in previous paper. Denoting by M(w) the set of minimal forbidden factors of a word w, we first focus on the evaluation of the size of elements in M(w) and on designing of an algorithm to recover the word w from M(w). Actually we prove that for a word w randomly generated by a memoryless source with identical symbol probabilities, the maximal length m(w) of words in M(w) is logarithmic and that the reconstruction algorithm runs in linear time. These results have an interesting application to the fragment assembly problem, i.e. reconstruct a word w from a given set I of substrings (fragments). Indeed under a suitable hypothesis on the set of fragments I, one can detect the elements of M(w) by looking at the minimal forbidden factors of elements in I and then apply the reconstruction algorithm.
Erzsébet Csuhaj-Varjú;Parallel Communicating Grammar Systems with Incomplete Information Communication.;György Vaszil;[<span itemprop="pagination">359-368</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_32;We examine the generative power of parallel communicating (PC) grammar systems with context-free or E0L components communicating incomplete information, that is, only subwords of their sentential forms. We prove that these systems in most cases, even with E0L components, generate all recursively enumerable languages.
György Vaszil;Parallel Communicating Grammar Systems with Incomplete Information Communication.;Erzsébet Csuhaj-Varjú;[<span itemprop="pagination">359-368</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_32;We examine the generative power of parallel communicating (PC) grammar systems with context-free or E0L components communicating incomplete information, that is, only subwords of their sentential forms. We prove that these systems in most cases, even with E0L components, generate all recursively enumerable languages.
Branislav Rovan;Eliminating Communication by Parallel Rewriting.;Marián Slast'an;[<span itemprop="pagination">369-278</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_33;We shall show that simple communication can be substituted by parallel rewriting and nondeterminism without a time penalty. This is no longer true for more complex communication. In particular, we shall show that time preserving simulation of regular PCGS by g-systems is possible whereas time preserving simulation of context-free PCGS is impossible.
Marián Slast'an;Eliminating Communication by Parallel Rewriting.;Branislav Rovan;[<span itemprop="pagination">369-278</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_33;We shall show that simple communication can be substituted by parallel rewriting and nondeterminism without a time penalty. This is no longer true for more complex communication. In particular, we shall show that time preserving simulation of regular PCGS by g-systems is possible whereas time preserving simulation of context-free PCGS is impossible.
Petr Sosík;String Rewriting Sequential P-Systems and Regulated Rewriting.;Rudolf Freund;[<span itemprop="pagination">379-388</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_34;We investigate the computational power of generalized P-systems of specific types in comparison with the computational power of certain control mechanisms for string rewriting grammars.An important restriction dwells in using sets of operators instead of multisets within sequential P-systems. this restriction is shown to be substantial, i.e., sequential P-systems of specific type using multisets are more powerful than the corresponding sequential P-systems using only sets.
Rudolf Freund;String Rewriting Sequential P-Systems and Regulated Rewriting.;Petr Sosík;[<span itemprop="pagination">379-388</span>];[<meta content="2001" itemprop="datePublished"/>];https://doi.org/10.1007/3-540-46011-X_34;We investigate the computational power of generalized P-systems of specific types in comparison with the computational power of certain control mechanisms for string rewriting grammars.An important restriction dwells in using sets of operators instead of multisets within sequential P-systems. this restriction is shown to be substantial, i.e., sequential P-systems of specific type using multisets are more powerful than the corresponding sequential P-systems using only sets.
Véronique Bruyère;Computer Aided Synthesis: A Game-Theoretic Approach.;;[<span itemprop="pagination">3-35</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_1;In this invited contribution, we propose a comprehensive introduction to game theory applied in computer aided synthesis. In this context, we give some classical results on two-player zero-sum games and then on multi-player non zero-sum games. The simple case of one-player games is strongly related to automata theory on infinite words. All along the article, we focus on general approaches to solve the studied problems, and we provide several illustrative examples as well as intuitions on the proofs.
Sergey Kitaev;A Comprehensive Introduction to the Theory of Word-Representable Graphs.;;[<span itemprop="pagination">36-67</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_2;Letters x and y alternate in a word w if after deleting in w all letters but the copies of x and y we either obtain a word \(xyxy\cdots \) (of even or odd length) or a word \(yxyx\cdots \) (of even or odd length). A graph \(G=(V,E)\) is word-representable if and only if there exists a word w over the alphabet V such that letters x and y alternate in w if and only if \(xy\in E\).
Eric Rowland;Binomial Coefficients, Valuations, and Words.;;[<span itemprop="pagination">68-74</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_3;The study of arithmetic properties of binomial coefficients has a rich history. A recurring theme is that p-adic statistics reflect the base-p representations of integers. We discuss many results expressing the number of binomial coefficients \(\left( {\begin{array}{c}n\\ m\end{array}}\right) \) with a given p-adic valuation in terms of the number of occurrences of a given word in the base-p representation of n, beginning with a result of Glaisher from 1899, up through recent results by Spiegelhofer–Wallner and Rowland.
Michal Skrzypczak;Connecting Decidability and Complexity for MSO Logic.;;[<span itemprop="pagination">75-79</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_4;This work is about studying reasons for (un)decidability of variants of Monadic Second-order (mso) logic over infinite structures. Thus, it focuses on connecting the fact that a given theory is (un)decidable with certain measures of complexity of that theory.
Simon Beier;On Regular Expression Proof Complexity.;Markus Holzer;[<span itemprop="pagination">83-95</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_5;We investigate the proof complexity of Salomaa’s axiom system \(F_1\) for regular expression equivalence. We show that for two regular expression E and F over the alphabet \(\varSigma \) with \(L(E)=L(F)\) an equivalence proof of length \(O\left( |\varSigma |^4\cdot \textsc {Tower}(\max \{h(E),h(F)\}+4)\right) \) can be derived within \(F_1\), where h(E) (h(F), respectively) refers to the height of E (F, respectively) and the tower function is defined as \(\textsc {Tower}(1)=2\) and \(\textsc {Tower}(k+1)=2^{\textsc {Tower}(k)}\), for \(k\ge 1\). In other words 
Markus Holzer;On Regular Expression Proof Complexity.;Simon Beier;[<span itemprop="pagination">83-95</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_5;We investigate the proof complexity of Salomaa’s axiom system \(F_1\) for regular expression equivalence. We show that for two regular expression E and F over the alphabet \(\varSigma \) with \(L(E)=L(F)\) an equivalence proof of length \(O\left( |\varSigma |^4\cdot \textsc {Tower}(\max \{h(E),h(F)\}+4)\right) \) can be derived within \(F_1\), where h(E) (h(F), respectively) refers to the height of E (F, respectively) and the tower function is defined as \(\textsc {Tower}(1)=2\) and \(\textsc {Tower}(k+1)=2^{\textsc {Tower}(k)}\), for \(k\ge 1\). In other words 
Simon Beier;Operational State Complexity and Decidability of Jumping Finite Automata.;Markus Holzer, Martin Kutrib;[<span itemprop="pagination">96-108</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_6;We consider jumping finite automata and their operational state complexity and decidability status. Roughly speaking, a jumping automaton is a finite automaton with a non-continuous input. This device has nice relations to semilinear sets and thus to Parikh images of regular sets, which will be exhaustively used in our proofs. In particular, we prove upper bounds on the intersection and complementation. The latter result on the complementation upper bound answers an open problem from G.J. Lavado, G. Pighizzini, S. Seki: Operational State Complexity of Parikh Equivalence [2014]. Moreover, we correct an erroneous result on the inverse homomorphism closure. Finally, we also consider the decidability status of standard problems as regularity, disjointness, universality, inclusion, etc. for jumping finite automata.
Markus Holzer;Operational State Complexity and Decidability of Jumping Finite Automata.;Simon Beier, Martin Kutrib;[<span itemprop="pagination">96-108</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_6;We consider jumping finite automata and their operational state complexity and decidability status. Roughly speaking, a jumping automaton is a finite automaton with a non-continuous input. This device has nice relations to semilinear sets and thus to Parikh images of regular sets, which will be exhaustively used in our proofs. In particular, we prove upper bounds on the intersection and complementation. The latter result on the complementation upper bound answers an open problem from G.J. Lavado, G. Pighizzini, S. Seki: Operational State Complexity of Parikh Equivalence [2014]. Moreover, we correct an erroneous result on the inverse homomorphism closure. Finally, we also consider the decidability status of standard problems as regularity, disjointness, universality, inclusion, etc. for jumping finite automata.
Martin Kutrib;Operational State Complexity and Decidability of Jumping Finite Automata.;Simon Beier, Markus Holzer;[<span itemprop="pagination">96-108</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_6;We consider jumping finite automata and their operational state complexity and decidability status. Roughly speaking, a jumping automaton is a finite automaton with a non-continuous input. This device has nice relations to semilinear sets and thus to Parikh images of regular sets, which will be exhaustively used in our proofs. In particular, we prove upper bounds on the intersection and complementation. The latter result on the complementation upper bound answers an open problem from G.J. Lavado, G. Pighizzini, S. Seki: Operational State Complexity of Parikh Equivalence [2014]. Moreover, we correct an erroneous result on the inverse homomorphism closure. Finally, we also consider the decidability status of standard problems as regularity, disjointness, universality, inclusion, etc. for jumping finite automata.
Vincent Hugot;Equivalence of Symbolic Tree Transducers.;Adrien Boiret, Joachim Niehren;[<span itemprop="pagination">109-121</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_7;Symbolic tree transducers are programs that transform data trees with an infinite signature. In this paper, we show that the equivalence problem of deterministic symbolic top-down tree transducers (DTop) can be reduced to that of classical DTop. As a consequence the equivalence of two symbolic DTop can be decided in NExpTime, when assuming that all operations related to the processing of data values are in PTime. This result can be extended to symbolic DTop with lookahead and thus to deterministic symbolic bottom-up tree transducers.
Adrien Boiret;Equivalence of Symbolic Tree Transducers.;Vincent Hugot, Joachim Niehren;[<span itemprop="pagination">109-121</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_7;Symbolic tree transducers are programs that transform data trees with an infinite signature. In this paper, we show that the equivalence problem of deterministic symbolic top-down tree transducers (DTop) can be reduced to that of classical DTop. As a consequence the equivalence of two symbolic DTop can be decided in NExpTime, when assuming that all operations related to the processing of data values are in PTime. This result can be extended to symbolic DTop with lookahead and thus to deterministic symbolic bottom-up tree transducers.
Joachim Niehren;Equivalence of Symbolic Tree Transducers.;Vincent Hugot, Adrien Boiret;[<span itemprop="pagination">109-121</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_7;Symbolic tree transducers are programs that transform data trees with an infinite signature. In this paper, we show that the equivalence problem of deterministic symbolic top-down tree transducers (DTop) can be reduced to that of classical DTop. As a consequence the equivalence of two symbolic DTop can be decided in NExpTime, when assuming that all operations related to the processing of data values are in PTime. This result can be extended to symbolic DTop with lookahead and thus to deterministic symbolic bottom-up tree transducers.
Michiel de Bondt;DFAs and PFAs with Long Shortest Synchronizing Word Length.;Henk Don, Hans Zantema;[<span itemprop="pagination">122-133</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_8;It was conjectured by Černý in 1964, that a synchronizing DFA on n states always has a synchronizing word of length at most \((n-1)^2\), and he gave a sequence of DFAs for which this bound is reached. Until now a full analysis of all DFAs reaching this bound was only given for \(n \le 4\), and with bounds on the number of symbols for \(n \le 10\). Here we give the full analysis for \(n \le 6\), without bounds on the number of symbols.
Henk Don;DFAs and PFAs with Long Shortest Synchronizing Word Length.;Michiel de Bondt, Hans Zantema;[<span itemprop="pagination">122-133</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_8;It was conjectured by Černý in 1964, that a synchronizing DFA on n states always has a synchronizing word of length at most \((n-1)^2\), and he gave a sequence of DFAs for which this bound is reached. Until now a full analysis of all DFAs reaching this bound was only given for \(n \le 4\), and with bounds on the number of symbols for \(n \le 10\). Here we give the full analysis for \(n \le 6\), without bounds on the number of symbols.
Hans Zantema;DFAs and PFAs with Long Shortest Synchronizing Word Length.;Michiel de Bondt, Henk Don;[<span itemprop="pagination">122-133</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_8;It was conjectured by Černý in 1964, that a synchronizing DFA on n states always has a synchronizing word of length at most \((n-1)^2\), and he gave a sequence of DFAs for which this bound is reached. Until now a full analysis of all DFAs reaching this bound was only given for \(n \le 4\), and with bounds on the number of symbols for \(n \le 10\). Here we give the full analysis for \(n \le 6\), without bounds on the number of symbols.
Sabine Broda;On the Mother of All Automata: The Position Automaton.;Markus Holzer, Eva Maia, Nelma Moreira, Rogério Reis;[<span itemprop="pagination">134-146</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_9;We contribute new relations to the taxonomy of different conversions from regular expressions to equivalent finite automata. In particular, we are interested in ordinary transformations that construct automata such as, the follow automaton, the partial derivative automaton, the prefix automaton, the automata based on pointed expressions recently introduced and studied, and last but not least the position, or Glushkov automaton (\(\mathcal {A}_{{{\mathrm{POS}}}}\)), and their double reversed construction counterparts. We deepen the understanding of these constructions and show that with the artefacts used to construct the Glushkov automaton one is able to capture most of them. As a byproduct we define a dual version \(\mathcal {A}_{{{\mathrm{\overleftarrow{{{\mathrm{POS}}}}}}}}\) of the position automaton which plays a similar role as \(\mathcal {A}_{{{\mathrm{POS}}}}\) but now for the reverse expression. It turns out that although the conversion of regular expressions and reversal of regular expressions to finite automata seems quite similar, there are significant differences.
Markus Holzer;On the Mother of All Automata: The Position Automaton.;Sabine Broda, Eva Maia, Nelma Moreira, Rogério Reis;[<span itemprop="pagination">134-146</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_9;We contribute new relations to the taxonomy of different conversions from regular expressions to equivalent finite automata. In particular, we are interested in ordinary transformations that construct automata such as, the follow automaton, the partial derivative automaton, the prefix automaton, the automata based on pointed expressions recently introduced and studied, and last but not least the position, or Glushkov automaton (\(\mathcal {A}_{{{\mathrm{POS}}}}\)), and their double reversed construction counterparts. We deepen the understanding of these constructions and show that with the artefacts used to construct the Glushkov automaton one is able to capture most of them. As a byproduct we define a dual version \(\mathcal {A}_{{{\mathrm{\overleftarrow{{{\mathrm{POS}}}}}}}}\) of the position automaton which plays a similar role as \(\mathcal {A}_{{{\mathrm{POS}}}}\) but now for the reverse expression. It turns out that although the conversion of regular expressions and reversal of regular expressions to finite automata seems quite similar, there are significant differences.
Eva Maia;On the Mother of All Automata: The Position Automaton.;Sabine Broda, Markus Holzer, Nelma Moreira, Rogério Reis;[<span itemprop="pagination">134-146</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_9;We contribute new relations to the taxonomy of different conversions from regular expressions to equivalent finite automata. In particular, we are interested in ordinary transformations that construct automata such as, the follow automaton, the partial derivative automaton, the prefix automaton, the automata based on pointed expressions recently introduced and studied, and last but not least the position, or Glushkov automaton (\(\mathcal {A}_{{{\mathrm{POS}}}}\)), and their double reversed construction counterparts. We deepen the understanding of these constructions and show that with the artefacts used to construct the Glushkov automaton one is able to capture most of them. As a byproduct we define a dual version \(\mathcal {A}_{{{\mathrm{\overleftarrow{{{\mathrm{POS}}}}}}}}\) of the position automaton which plays a similar role as \(\mathcal {A}_{{{\mathrm{POS}}}}\) but now for the reverse expression. It turns out that although the conversion of regular expressions and reversal of regular expressions to finite automata seems quite similar, there are significant differences.
Nelma Moreira;On the Mother of All Automata: The Position Automaton.;Sabine Broda, Markus Holzer, Eva Maia, Rogério Reis;[<span itemprop="pagination">134-146</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_9;We contribute new relations to the taxonomy of different conversions from regular expressions to equivalent finite automata. In particular, we are interested in ordinary transformations that construct automata such as, the follow automaton, the partial derivative automaton, the prefix automaton, the automata based on pointed expressions recently introduced and studied, and last but not least the position, or Glushkov automaton (\(\mathcal {A}_{{{\mathrm{POS}}}}\)), and their double reversed construction counterparts. We deepen the understanding of these constructions and show that with the artefacts used to construct the Glushkov automaton one is able to capture most of them. As a byproduct we define a dual version \(\mathcal {A}_{{{\mathrm{\overleftarrow{{{\mathrm{POS}}}}}}}}\) of the position automaton which plays a similar role as \(\mathcal {A}_{{{\mathrm{POS}}}}\) but now for the reverse expression. It turns out that although the conversion of regular expressions and reversal of regular expressions to finite automata seems quite similar, there are significant differences.
Rogério Reis;On the Mother of All Automata: The Position Automaton.;Sabine Broda, Markus Holzer, Eva Maia, Nelma Moreira;[<span itemprop="pagination">134-146</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_9;We contribute new relations to the taxonomy of different conversions from regular expressions to equivalent finite automata. In particular, we are interested in ordinary transformations that construct automata such as, the follow automaton, the partial derivative automaton, the prefix automaton, the automata based on pointed expressions recently introduced and studied, and last but not least the position, or Glushkov automaton (\(\mathcal {A}_{{{\mathrm{POS}}}}\)), and their double reversed construction counterparts. We deepen the understanding of these constructions and show that with the artefacts used to construct the Glushkov automaton one is able to capture most of them. As a byproduct we define a dual version \(\mathcal {A}_{{{\mathrm{\overleftarrow{{{\mathrm{POS}}}}}}}}\) of the position automaton which plays a similar role as \(\mathcal {A}_{{{\mathrm{POS}}}}\) but now for the reverse expression. It turns out that although the conversion of regular expressions and reversal of regular expressions to finite automata seems quite similar, there are significant differences.
Olivier Carton;Two-Way Two-Tape Automata.;Léo Exibard, Olivier Serre;[<span itemprop="pagination">147-159</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_10;In this article we consider two-way two-tape (alternating) automata accepting pairs of words and we study some closure properties of this model. Our main result is that such alternating automata are not closed under complementation for non-unary alphabets. This improves a similar result of Kari and Moore for picture languages. We also show that these deterministic, non-deterministic and alternating automata are not closed under composition.
Léo Exibard;Two-Way Two-Tape Automata.;Olivier Carton, Olivier Serre;[<span itemprop="pagination">147-159</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_10;In this article we consider two-way two-tape (alternating) automata accepting pairs of words and we study some closure properties of this model. Our main result is that such alternating automata are not closed under complementation for non-unary alphabets. This improves a similar result of Kari and Moore for picture languages. We also show that these deterministic, non-deterministic and alternating automata are not closed under composition.
Olivier Serre;Two-Way Two-Tape Automata.;Olivier Carton, Léo Exibard;[<span itemprop="pagination">147-159</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_10;In this article we consider two-way two-tape (alternating) automata accepting pairs of words and we study some closure properties of this model. Our main result is that such alternating automata are not closed under complementation for non-unary alphabets. This improves a similar result of Kari and Moore for picture languages. We also show that these deterministic, non-deterministic and alternating automata are not closed under composition.
Jörg Endrullis;Undecidability and Finite Automata.;Jeffrey O. Shallit, Tim Smith;[<span itemprop="pagination">160-172</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_11;Using a novel rewriting problem, we show that several natural decision problems about finite automata are undecidable (i.e., recursively unsolvable). In contrast, we also prove three related problems are decidable. We apply one result to prove the undecidability of a related problem about k-automatic sets of rational numbers.
Jeffrey O. Shallit;Undecidability and Finite Automata.;Jörg Endrullis, Tim Smith;[<span itemprop="pagination">160-172</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_11;Using a novel rewriting problem, we show that several natural decision problems about finite automata are undecidable (i.e., recursively unsolvable). In contrast, we also prove three related problems are decidable. We apply one result to prove the undecidability of a related problem about k-automatic sets of rational numbers.
Tim Smith;Undecidability and Finite Automata.;Jörg Endrullis, Jeffrey O. Shallit;[<span itemprop="pagination">160-172</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_11;Using a novel rewriting problem, we show that several natural decision problems about finite automata are undecidable (i.e., recursively unsolvable). In contrast, we also prove three related problems are decidable. We apply one result to prove the undecidability of a related problem about k-automatic sets of rational numbers.
Zsolt Gazdag;On the Power of Permitting Semi-conditional Grammars.;Krisztián Tichler;[<span itemprop="pagination">173-184</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_12;Permitting semi-conditional grammars are such extensions of context-free grammars where each rule is associated with a word v, and such a rule can be applied to a sentential form u only if v is a subword of u. In this paper we show that the class of languages generated by permitting semi-conditional grammars with no erasing rules is strictly included in the class of context-sensitive languages.
Krisztián Tichler;On the Power of Permitting Semi-conditional Grammars.;Zsolt Gazdag;[<span itemprop="pagination">173-184</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_12;Permitting semi-conditional grammars are such extensions of context-free grammars where each rule is associated with a word v, and such a rule can be applied to a sentential form u only if v is a subword of u. In this paper we show that the class of languages generated by permitting semi-conditional grammars with no erasing rules is strictly included in the class of context-sensitive languages.
François Gonze;On the Interplay Between Babai and Černý's Conjectures.;Vladimir V. Gusev, Balázs Gerencsér, Raphaël M. Jungers, Mikhail V. Volkov;[<span itemprop="pagination">185-197</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_13;Motivated by the Babai conjecture and the Černý conjecture, we study the reset thresholds of automata with the transition monoid equal to the full monoid of transformations of the state set. For automata with n states in this class, we prove that the reset thresholds are upper-bounded by \(2n^2-6n+5\) and can attain the value \(\tfrac{n(n-1)}{2}\). In addition, we study diameters of the pair digraphs of permutation automata and construct n-state permutation automata with diameter \(\tfrac{n^2}{4} + o(n^2)\).
Vladimir V. Gusev;On the Interplay Between Babai and Černý's Conjectures.;François Gonze, Balázs Gerencsér, Raphaël M. Jungers, Mikhail V. Volkov;[<span itemprop="pagination">185-197</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_13;Motivated by the Babai conjecture and the Černý conjecture, we study the reset thresholds of automata with the transition monoid equal to the full monoid of transformations of the state set. For automata with n states in this class, we prove that the reset thresholds are upper-bounded by \(2n^2-6n+5\) and can attain the value \(\tfrac{n(n-1)}{2}\). In addition, we study diameters of the pair digraphs of permutation automata and construct n-state permutation automata with diameter \(\tfrac{n^2}{4} + o(n^2)\).
Balázs Gerencsér;On the Interplay Between Babai and Černý's Conjectures.;François Gonze, Vladimir V. Gusev, Raphaël M. Jungers, Mikhail V. Volkov;[<span itemprop="pagination">185-197</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_13;Motivated by the Babai conjecture and the Černý conjecture, we study the reset thresholds of automata with the transition monoid equal to the full monoid of transformations of the state set. For automata with n states in this class, we prove that the reset thresholds are upper-bounded by \(2n^2-6n+5\) and can attain the value \(\tfrac{n(n-1)}{2}\). In addition, we study diameters of the pair digraphs of permutation automata and construct n-state permutation automata with diameter \(\tfrac{n^2}{4} + o(n^2)\).
Raphaël M. Jungers;On the Interplay Between Babai and Černý's Conjectures.;François Gonze, Vladimir V. Gusev, Balázs Gerencsér, Mikhail V. Volkov;[<span itemprop="pagination">185-197</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_13;Motivated by the Babai conjecture and the Černý conjecture, we study the reset thresholds of automata with the transition monoid equal to the full monoid of transformations of the state set. For automata with n states in this class, we prove that the reset thresholds are upper-bounded by \(2n^2-6n+5\) and can attain the value \(\tfrac{n(n-1)}{2}\). In addition, we study diameters of the pair digraphs of permutation automata and construct n-state permutation automata with diameter \(\tfrac{n^2}{4} + o(n^2)\).
Mikhail V. Volkov;On the Interplay Between Babai and Černý's Conjectures.;François Gonze, Vladimir V. Gusev, Balázs Gerencsér, Raphaël M. Jungers;[<span itemprop="pagination">185-197</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_13;Motivated by the Babai conjecture and the Černý conjecture, we study the reset thresholds of automata with the transition monoid equal to the full monoid of transformations of the state set. For automata with n states in this class, we prove that the reset thresholds are upper-bounded by \(2n^2-6n+5\) and can attain the value \(\tfrac{n(n-1)}{2}\). In addition, we study diameters of the pair digraphs of permutation automata and construct n-state permutation automata with diameter \(\tfrac{n^2}{4} + o(n^2)\).
Anaël Grandjean;Differences Between 2D Neighborhoods According to Real Time Computation.;;[<span itemprop="pagination">198-209</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_14;Cellular automata are a parallel model of computation. This paper presents studies about the impact of the choice of the neighborhood on small complexity classes, mainly the real time class. The main result states that given two neighborhoods \(\mathcal {N}\) and \(\mathcal {N}'\), if \(\mathcal {N}\) has a limiting vertex in some direction and \(\mathcal {N}'\) have no vertex in that direction then there is a language recognizable in real time with \(\mathcal {N}'\) and not with \(\mathcal {N}\). One easy corollary is that real time classes for two neighborhoods may be incomparable (and such neighborhoods are easy to construct).
Luisa Herrmann;A Medvedev Characterization of Recognizable Tree Series.;;[<span itemprop="pagination">210-221</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_15;We introduce representable tree series over commutative semirings, which extend representable sets [10] to the weighted setting. We prove that restricted representable tree series are exactly those tree series that can be recognized by weighted tree automata. Moreover, we investigate the relation between unrestricted representable tree series and weighted monadic second-order logic.
Michal Hospodár;On the Descriptive Complexity of $$\overline{\varSigma ^*\overline{L}}$$.;Galina Jirásková, Peter Mlynárcik;[<span itemprop="pagination">222-234</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_16;We examine the descriptive complexity of the combined unary operation \(\overline{\varSigma ^*\overline{L}}\) and investigate the trade-offs between various models of finite automata. We consider complete and partial deterministic finite automata, nondeterministic finite automata with single or multiple initial states, alternating, and boolean finite automata. We assume that the argument and the result of this operation are accepted by automata belonging to one of these six models. We investigate all possible trade-offs and provide a tight upper bound for 32 of 36 of them. The most interesting result is the trade-off from nondeterministic to deterministic automata given by the Dedekind number \({{\mathrm{M}}}(n-1)\). We also prove that the nondeterministic state complexity of \(\overline{\varSigma ^*\overline{L}}\) is \(2^{n-1}\) which solves an open problem stated by Birget [1996, The state complexity of \(\overline{\varSigma ^*\overline{L}}\) and its connection with temporal logic, Inform. Process. Lett. 58, 185–188].
Galina Jirásková;On the Descriptive Complexity of $$\overline{\varSigma ^*\overline{L}}$$.;Michal Hospodár, Peter Mlynárcik;[<span itemprop="pagination">222-234</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_16;We examine the descriptive complexity of the combined unary operation \(\overline{\varSigma ^*\overline{L}}\) and investigate the trade-offs between various models of finite automata. We consider complete and partial deterministic finite automata, nondeterministic finite automata with single or multiple initial states, alternating, and boolean finite automata. We assume that the argument and the result of this operation are accepted by automata belonging to one of these six models. We investigate all possible trade-offs and provide a tight upper bound for 32 of 36 of them. The most interesting result is the trade-off from nondeterministic to deterministic automata given by the Dedekind number \({{\mathrm{M}}}(n-1)\). We also prove that the nondeterministic state complexity of \(\overline{\varSigma ^*\overline{L}}\) is \(2^{n-1}\) which solves an open problem stated by Birget [1996, The state complexity of \(\overline{\varSigma ^*\overline{L}}\) and its connection with temporal logic, Inform. Process. Lett. 58, 185–188].
Peter Mlynárcik;On the Descriptive Complexity of $$\overline{\varSigma ^*\overline{L}}$$.;Michal Hospodár, Galina Jirásková;[<span itemprop="pagination">222-234</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_16;We examine the descriptive complexity of the combined unary operation \(\overline{\varSigma ^*\overline{L}}\) and investigate the trade-offs between various models of finite automata. We consider complete and partial deterministic finite automata, nondeterministic finite automata with single or multiple initial states, alternating, and boolean finite automata. We assume that the argument and the result of this operation are accepted by automata belonging to one of these six models. We investigate all possible trade-offs and provide a tight upper bound for 32 of 36 of them. The most interesting result is the trade-off from nondeterministic to deterministic automata given by the Dedekind number \({{\mathrm{M}}}(n-1)\). We also prove that the nondeterministic state complexity of \(\overline{\varSigma ^*\overline{L}}\) is \(2^{n-1}\) which solves an open problem stated by Birget [1996, The state complexity of \(\overline{\varSigma ^*\overline{L}}\) and its connection with temporal logic, Inform. Process. Lett. 58, 185–188].
Oscar H. Ibarra;Variations of Checking Stack Automata: Obtaining Unexpected Decidability Properties.;Ian McQuillan;[<span itemprop="pagination">235-246</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_17;We introduce a model of one-way language acceptors (a variant of a checking stack automaton) and show the following decidability properties:
Ian McQuillan;Variations of Checking Stack Automata: Obtaining Unexpected Decidability Properties.;Oscar H. Ibarra;[<span itemprop="pagination">235-246</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_17;We introduce a model of one-way language acceptors (a variant of a checking stack automaton) and show the following decidability properties:
Michal Kunc;The Generalized Rank of Trace Languages.;Jan Meitner;[<span itemprop="pagination">247-259</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_18;The notion of rank of a language with respect to an independence alphabet is generalized from concatenations of two words to an arbitrary fixed number of words. It is proved that in the case of free commutative monoids, as well as in the more general case of direct products of free monoids, sequences of ranks of regular languages are exactly non-decreasing sequences that are eventually constant. On the other hand, by uncovering a relationship between rank sequences of regular languages and rational series over the min-plus semiring, it is shown that already for free products of free commutative monoids, rank sequences need not be eventually periodic.
Jan Meitner;The Generalized Rank of Trace Languages.;Michal Kunc;[<span itemprop="pagination">247-259</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_18;The notion of rank of a language with respect to an independence alphabet is generalized from concatenations of two words to an arbitrary fixed number of words. It is proved that in the case of free commutative monoids, as well as in the more general case of direct products of free monoids, sequences of ranks of regular languages are exactly non-decreasing sequences that are eventually constant. On the other hand, by uncovering a relationship between rank sequences of regular languages and rational series over the min-plus semiring, it is shown that already for free products of free commutative monoids, rank sequences need not be eventually periodic.
Kamal Lodaya;Two-Variable First Order Logic with Counting Quantifiers: Complexity Results.;A. V. Sreejith;[<span itemprop="pagination">260-271</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_19;Etessami et al. [5] showed that satisfiability of two-variable first order logic \(\mathrm {FO}^2\)[&lt.] on word models is Nexptime-complete. We extend this upper bound to the slightly stronger logic \(\mathrm {FO}^2\)[\(&lt.,succ ,\equiv \)], which allows checking whether a word position is congruent to r modulo q, for some divisor q and remainder r. If we allow the more powerful modulo counting quantifiers of Straubing, Thérien et al. [22] (we call this two-variable fragment FOmod\(^2\)[\(&lt.,succ \)]), satisfiability becomes Expspace-complete. A more general counting quantifier, FOunC\(^2\)[\(&lt.,succ \)], makes the logic undecidable.
A. V. Sreejith;Two-Variable First Order Logic with Counting Quantifiers: Complexity Results.;Kamal Lodaya;[<span itemprop="pagination">260-271</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_19;Etessami et al. [5] showed that satisfiability of two-variable first order logic \(\mathrm {FO}^2\)[&lt.] on word models is Nexptime-complete. We extend this upper bound to the slightly stronger logic \(\mathrm {FO}^2\)[\(&lt.,succ ,\equiv \)], which allows checking whether a word position is congruent to r modulo q, for some divisor q and remainder r. If we allow the more powerful modulo counting quantifiers of Straubing, Thérien et al. [22] (we call this two-variable fragment FOmod\(^2\)[\(&lt.,succ \)]), satisfiability becomes Expspace-complete. A more general counting quantifier, FOunC\(^2\)[\(&lt.,succ \)], makes the logic undecidable.
Frantisek Mráz;Deleting Deterministic Restarting Automata with Two Windows.;Friedrich Otto;[<span itemprop="pagination">272-283</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_20;We study deterministic restarting automata with two windows. In each cycle of a computation, these det-2-RR-automata can perform up to two delete operations, one with each of their two windows. We study the class of languages accepted by these automata, comparing it to other well-known language classes and exploring closure properties.
Friedrich Otto;Deleting Deterministic Restarting Automata with Two Windows.;Frantisek Mráz;[<span itemprop="pagination">272-283</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_20;We study deterministic restarting automata with two windows. In each cycle of a computation, these det-2-RR-automata can perform up to two delete operations, one with each of their two windows. We study the class of languages accepted by these automata, comparing it to other well-known language classes and exploring closure properties.
Timothy Ng;Relative Prefix Distance Between Languages.;David Rappaport, Kai Salomaa;[<span itemprop="pagination">284-295</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_21;The prefix distance between two words x and y is defined as the number of symbols in x and y that do not belong to their longest common prefix. The relative prefix distance from a language \(L_1\) to a language \(L_2\), if finite, is the smallest integer k such that for every word in \(L_1\), there is a word in \(L_2\) with prefix distance at most k. We study the prefix distance between regular, visibly pushdown, deterministic context-free, and context-free languages. We show how to compute the distance between regular languages and determine whether the distance is bounded. For deterministic context-free languages and visibly pushdown languages, we show that the relative prefix distance to and from regular languages is decidable.
David Rappaport;Relative Prefix Distance Between Languages.;Timothy Ng, Kai Salomaa;[<span itemprop="pagination">284-295</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_21;The prefix distance between two words x and y is defined as the number of symbols in x and y that do not belong to their longest common prefix. The relative prefix distance from a language \(L_1\) to a language \(L_2\), if finite, is the smallest integer k such that for every word in \(L_1\), there is a word in \(L_2\) with prefix distance at most k. We study the prefix distance between regular, visibly pushdown, deterministic context-free, and context-free languages. We show how to compute the distance between regular languages and determine whether the distance is bounded. For deterministic context-free languages and visibly pushdown languages, we show that the relative prefix distance to and from regular languages is decidable.
Kai Salomaa;Relative Prefix Distance Between Languages.;Timothy Ng, David Rappaport;[<span itemprop="pagination">284-295</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_21;The prefix distance between two words x and y is defined as the number of symbols in x and y that do not belong to their longest common prefix. The relative prefix distance from a language \(L_1\) to a language \(L_2\), if finite, is the smallest integer k such that for every word in \(L_1\), there is a word in \(L_2\) with prefix distance at most k. We study the prefix distance between regular, visibly pushdown, deterministic context-free, and context-free languages. We show how to compute the distance between regular languages and determine whether the distance is bounded. For deterministic context-free languages and visibly pushdown languages, we show that the relative prefix distance to and from regular languages is decidable.
Elena A. Petrova;On the Tree of Binary Cube-Free Words.;Arseny M. Shur;[<span itemprop="pagination">296-307</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_22;We present two related results on the prefix tree of all binary cube-free words. First, we show that non-branching paths in this tree are short: such a path from a node of nth level has length \(O(\log n)\). Second, we prove that the lower density of the set of branching points along any infinite path is at least 23/78. Our results are based on a technical theorem describing the mutual location of “almost cubes” in a cube-free word.
Arseny M. Shur;On the Tree of Binary Cube-Free Words.;Elena A. Petrova;[<span itemprop="pagination">296-307</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_22;We present two related results on the prefix tree of all binary cube-free words. First, we show that non-branching paths in this tree are short: such a path from a node of nth level has length \(O(\log n)\). Second, we prove that the lower density of the set of branching points along any infinite path is at least 23/78. Our results are based on a technical theorem describing the mutual location of “almost cubes” in a cube-free word.
Giovanni Pighizzini;Limited Automata and Unary Languages.;Luca Prigioniero;[<span itemprop="pagination">308-319</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_23;Limited automata are one-tape Turing machines that are allowed to rewrite the content of any tape cell only in the first d visits, for a fixed constant d. When \(d=1\) these models characterize regular languages. An exponential gap between the size of limited automata accepting unary languages and the size of equivalent finite automata is proved. Since a similar gap was already known from unary context-free grammars to finite automata, also the conversion of such grammars into limited automata is investigated. It is proved that from each unary context-free grammar it is possible to obtain an equivalent 1-limited automaton whose description has a size which is polynomial in the size of the grammar. Furthermore, despite the exponential gap between the sizes of limited automata and of equivalent unary finite automata, there are unary regular languages for which d-limited automata cannot be significantly smaller than equivalent finite automata, for any arbitrarily large d.
Luca Prigioniero;Limited Automata and Unary Languages.;Giovanni Pighizzini;[<span itemprop="pagination">308-319</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_23;Limited automata are one-tape Turing machines that are allowed to rewrite the content of any tape cell only in the first d visits, for a fixed constant d. When \(d=1\) these models characterize regular languages. An exponential gap between the size of limited automata accepting unary languages and the size of equivalent finite automata is proved. Since a similar gap was already known from unary context-free grammars to finite automata, also the conversion of such grammars into limited automata is investigated. It is proved that from each unary context-free grammar it is possible to obtain an equivalent 1-limited automaton whose description has a size which is polynomial in the size of the grammar. Furthermore, despite the exponential gap between the sizes of limited automata and of equivalent unary finite automata, there are unary regular languages for which d-limited automata cannot be significantly smaller than equivalent finite automata, for any arbitrarily large d.
Gwénaël Richomme;A Characterization of Infinite LSP Words.;;[<span itemprop="pagination">320-331</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_24;G. Fici proved that a finite word has a minimal suffix automaton if and only if all its left special factors occur as prefixes. He called LSP all finite and infinite words having this latter property. We characterize here infinite LSP words in terms of S-adicity. More precisely we provide a finite set of morphisms S and an automaton \(\mathcal{A}\) such that an infinite word is LSP if and only if it is S-adic and all its directive words are recognizable by \(\mathcal{A}\).
Alexander A. Rubtsov;On Computational Complexity of Set Automata.;Mikhail N. Vyalyi;[<span itemprop="pagination">332-344</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_25;We consider a computational model which is known as set automata. The set automata are one-way finite automata with an additional storage—the set. There are two kinds of set automata—the deterministic and the nondeterministic ones. We denote them as DSA and NSA respectively. The model was introduced by M. Kutrib, A. Malcher, M. Wendlandt in 2014 in [<a aria-label="Reference 3" data-test="citation-ref" data-track="click" data-track-action="reference anchor" data-track-label="link" href="#ref-CR3" id="ref-link-section-d12720363e849" title="Kutrib, M., Malcher, A., Wendlandt, M.: Deterministic set automata. In: Shur, A.M., Volkov, M.V. (eds.) DLT 2014. LNCS, vol. 8633, pp. 303–314. Springer, Cham (2014). doi:                      10.1007/978-3-319-09698-8_27                                                  ">3, <a aria-label="Reference 4" data-test="citation-ref" data-track="click" data-track-action="reference anchor" data-track-label="link" href="#ref-CR4" id="ref-link-section-d12720363e852" title="Kutrib, M., Malcher, A., Wendlandt, M.: Regularity and size of set automata. In: Jürgensen, H., Karhumäki, J., Okhotin, A. (eds.) DCFS 2014. LNCS, vol. 8614, pp. 282–293. Springer, Cham (2014). doi:                      10.1007/978-3-319-09704-6_25                                                  ">4]. It was shown that DSA-languages look similar to DCFL due to their closure properties and NSA-languages look similar to CFL due to their undecidability properties.
Mikhail N. Vyalyi;On Computational Complexity of Set Automata.;Alexander A. Rubtsov;[<span itemprop="pagination">332-344</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_25;We consider a computational model which is known as set automata. The set automata are one-way finite automata with an additional storage—the set. There are two kinds of set automata—the deterministic and the nondeterministic ones. We denote them as DSA and NSA respectively. The model was introduced by M. Kutrib, A. Malcher, M. Wendlandt in 2014 in [<a aria-label="Reference 3" data-test="citation-ref" data-track="click" data-track-action="reference anchor" data-track-label="link" href="#ref-CR3" id="ref-link-section-d12720363e849" title="Kutrib, M., Malcher, A., Wendlandt, M.: Deterministic set automata. In: Shur, A.M., Volkov, M.V. (eds.) DLT 2014. LNCS, vol. 8633, pp. 303–314. Springer, Cham (2014). doi:                      10.1007/978-3-319-09698-8_27                                                  ">3, <a aria-label="Reference 4" data-test="citation-ref" data-track="click" data-track-action="reference anchor" data-track-label="link" href="#ref-CR4" id="ref-link-section-d12720363e852" title="Kutrib, M., Malcher, A., Wendlandt, M.: Regularity and size of set automata. In: Jürgensen, H., Karhumäki, J., Okhotin, A. (eds.) DCFS 2014. LNCS, vol. 8614, pp. 282–293. Springer, Cham (2014). doi:                      10.1007/978-3-319-09704-6_25                                                  ">4]. It was shown that DSA-languages look similar to DCFL due to their closure properties and NSA-languages look similar to CFL due to their undecidability properties.
Josef Rukavicka;On the Number of Rich Words.;;[<span itemprop="pagination">345-352</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_26;Any finite word w of length n contains at most \(n+1\) distinct palindromic factors. If the bound \(n+1\) is reached, the word w is called rich. The number of rich words of length n over an alphabet of cardinality q is denoted \(R_q(n)\). For binary alphabet, Rubinchik and Shur deduced that \({R_2(n)}\le c 1.605^n \) for some constant c. In addition, Guo, Shallit and Shur conjectured that the number of rich words grows slightly slower than \(n^{\sqrt{n}}\). We prove that \(\lim \limits _{n\rightarrow \infty }\root n \of {R_q(n)}=1\) for any q, i.e. \(R_q(n)\) has a subexponential growth on any alphabet.
Tomoyuki Yamakami;One-Way Bounded-Error Probabilistic Pushdown Automata and Kolmogorov Complexity - (Preliminary Report).;;[<span itemprop="pagination">353-364</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_27;One-way probabilistic pushdown automata (or ppda’s) are a simple model of randomized computation with last-in first-out memory device known as stacks and, when error probabilities are bounded away from 1 / 2, ppda’s can characterize a family of bounded-error probabilistic context-free languages (BPCFL). We resolve a fundamental question raised by Hromkovič and Schnitger [Inf. Comput. 208 (2010) 982–995] concerning the limitation of the language recognition power of bounded-error ppda’s. More specifically, we prove that a well-known language—the set of palindromes—cannot be recognized by any bounded-error ppda. in other words, this language stays outside of BPCFL. Furthermore, we show that, with bounded-error probability, no ppda can determine whether the center bit of input string is 1 (one). For those impossibility results, we utilize a complexity measure of algorithmic information known as Kolmogorov complexity. In our proofs, we first transform ppda’s into an ideal shape and then lead to a key lemma by employing a Kolmogorov complexity argument.
Hans Zantema;Classifying Non-periodic Sequences by Permutation Transducers.;Wieb Bosma;[<span itemprop="pagination">365-377</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_28;Transducers order infinite sequences into natural classes, but permutation transducers provide a finer classification, respecting certain changes to finite segments. We investigate this hierarchy for non-periodic sequences over \(\{0,1\}\) in which the groups of 0s and 1s grow according to simple functions like polynomials. In this hierarchy we find infinite strictly ascending chains of sequences, all being equivalent with respect to ordinary transducers.
Wieb Bosma;Classifying Non-periodic Sequences by Permutation Transducers.;Hans Zantema;[<span itemprop="pagination">365-377</span>];[<meta content="2017" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-319-62809-7_28;Transducers order infinite sequences into natural classes, but permutation transducers provide a finer classification, respecting certain changes to finite segments. We investigate this hierarchy for non-periodic sequences over \(\{0,1\}\) in which the groups of 0s and 1s grow according to simple functions like polynomials. In this hierarchy we find infinite strictly ascending chains of sequences, all being equivalent with respect to ordinary transducers.
Jean-Paul Allouche;Morphic Sequences Versus Automatic Sequences.;;[<span itemprop="pagination">3-11</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_1;Two classical families of infinite sequences with some regularity properties are the families of morphic and of automatic sequences. After recalling their definitions, we survey some recent work trying to “separate” between them.
Henning Fernau;Parsimonious Computational Completeness.;;[<span itemprop="pagination">12-26</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_2;Throughout the history of Formal Languages, one of the research directions has always been to describe computational completeness using only a small amount of possibly scarce resources. We review some of these results in the form of an essay.
Benjamin Steinberg;Pointlike Sets and Separation: A Personal Perspective.;;[<span itemprop="pagination">27-40</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_3;This is a personal survey about pointlike sets since their inception to roughly the present. Personal means that I make no attempt to be exhaustive, but rather to highlight things that have affected my research in the area or that I consider fundamental to the area. Pointlike sets, in the language of separation and covering problems, have become very popular now in Computer Science because of the truly amazing work of Place and Zeitoun on dot-depth and related hierarchies. I believe revisiting some of the older results will revive interest and provide perspective.
Elena Barcucci;A Strong Non-overlapping Dyck Code.;Antonio Bernini, Renzo Pinzani;[<span itemprop="pagination">43-53</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_4;We propose a strong non-overlapping set of Dyck paths having variable length. First, we construct a set starting from an elevated Dyck path by cutting it in a specific point and inserting suitable Dyck paths (not too long...) in this cutting point. Then, we increase the cardinality of the set by replacing the first and the second factor of the original elevated Dyck path with suitable sets of prefixes and suffixes.
Antonio Bernini;A Strong Non-overlapping Dyck Code.;Elena Barcucci, Renzo Pinzani;[<span itemprop="pagination">43-53</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_4;We propose a strong non-overlapping set of Dyck paths having variable length. First, we construct a set starting from an elevated Dyck path by cutting it in a specific point and inserting suitable Dyck paths (not too long...) in this cutting point. Then, we increase the cardinality of the set by replacing the first and the second factor of the original elevated Dyck path with suitable sets of prefixes and suffixes.
Renzo Pinzani;A Strong Non-overlapping Dyck Code.;Elena Barcucci, Antonio Bernini;[<span itemprop="pagination">43-53</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_4;We propose a strong non-overlapping set of Dyck paths having variable length. First, we construct a set starting from an elevated Dyck path by cutting it in a specific point and inserting suitable Dyck paths (not too long...) in this cutting point. Then, we increase the cardinality of the set by replacing the first and the second factor of the original elevated Dyck path with suitable sets of prefixes and suffixes.
Raphaël Berthon;Active Learning of Sequential Transducers with Side Information About the Domain.;Adrien Boiret, Guillermo A. Pérez, Jean-François Raskin;[<span itemprop="pagination">54-65</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_5;Active learning is a setting in which a student queries a teacher, through membership and equivalence queries, in order to learn a language. Performance on these algorithms is often measured in the number of queries required to learn a target, with an emphasis on costly equivalence queries. In graybox learning, the learning process is accelerated by foreknowledge of some information on the target. Here, we consider graybox active learning of subsequential string transducers, where a regular overapproximation of the domain is known by the student. We show that there exists an algorithm to learn subsequential string transducers with a better guarantee on the required number of equivalence queries than classical active learning.
Adrien Boiret;Active Learning of Sequential Transducers with Side Information About the Domain.;Raphaël Berthon, Guillermo A. Pérez, Jean-François Raskin;[<span itemprop="pagination">54-65</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_5;Active learning is a setting in which a student queries a teacher, through membership and equivalence queries, in order to learn a language. Performance on these algorithms is often measured in the number of queries required to learn a target, with an emphasis on costly equivalence queries. In graybox learning, the learning process is accelerated by foreknowledge of some information on the target. Here, we consider graybox active learning of subsequential string transducers, where a regular overapproximation of the domain is known by the student. We show that there exists an algorithm to learn subsequential string transducers with a better guarantee on the required number of equivalence queries than classical active learning.
Guillermo A. Pérez;Active Learning of Sequential Transducers with Side Information About the Domain.;Raphaël Berthon, Adrien Boiret, Jean-François Raskin;[<span itemprop="pagination">54-65</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_5;Active learning is a setting in which a student queries a teacher, through membership and equivalence queries, in order to learn a language. Performance on these algorithms is often measured in the number of queries required to learn a target, with an emphasis on costly equivalence queries. In graybox learning, the learning process is accelerated by foreknowledge of some information on the target. Here, we consider graybox active learning of subsequential string transducers, where a regular overapproximation of the domain is known by the student. We show that there exists an algorithm to learn subsequential string transducers with a better guarantee on the required number of equivalence queries than classical active learning.
Jean-François Raskin;Active Learning of Sequential Transducers with Side Information About the Domain.;Raphaël Berthon, Adrien Boiret, Guillermo A. Pérez;[<span itemprop="pagination">54-65</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_5;Active learning is a setting in which a student queries a teacher, through membership and equivalence queries, in order to learn a language. Performance on these algorithms is often measured in the number of queries required to learn a target, with an emphasis on costly equivalence queries. In graybox learning, the learning process is accelerated by foreknowledge of some information on the target. Here, we consider graybox active learning of subsequential string transducers, where a regular overapproximation of the domain is known by the student. We show that there exists an algorithm to learn subsequential string transducers with a better guarantee on the required number of equivalence queries than classical active learning.
Malte Blattmann;Compositions of Constant Weighted Extended Tree Transducers.;Andreas Maletti;[<span itemprop="pagination">66-77</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_6;Conjecture 11 of [Lagoutte, Maletti: Survey—Weighted extended top-down tree transducers—Part III: Composition. Proc. AFCS, LNCS 7020, p. 272–308, Springer 2011] is confirmed. It is demonstrated that the composition of a constant weighted extended tree transducer with a linear weighted top-down tree transducer can be computed by a single weighted extended tree transducer. Whereas linearity and the top-down property are syntactic, the constant property is semantic. The decidability of the constant property is investigated in several restricted settings.
Andreas Maletti;Compositions of Constant Weighted Extended Tree Transducers.;Malte Blattmann;[<span itemprop="pagination">66-77</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_6;Conjecture 11 of [Lagoutte, Maletti: Survey—Weighted extended top-down tree transducers—Part III: Composition. Proc. AFCS, LNCS 7020, p. 272–308, Springer 2011] is confirmed. It is demonstrated that the composition of a constant weighted extended tree transducer with a linear weighted top-down tree transducer can be computed by a single weighted extended tree transducer. Whereas linearity and the top-down property are syntactic, the constant property is semantic. The decidability of the constant property is investigated in several restricted settings.
Stijn Cambie;Extremal Binary PFAs in a Černý Family.;Michiel de Bondt, Henk Don;[<span itemprop="pagination">78-89</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_7;The largest known reset thresholds for DFAs are equal to \((n-1)^2\), where n is the number of states. This is conjectured to be the maximum possible. PFAs (with partial transition function) can have exponentially large reset thresholds. This is still true if we restrict to binary PFAs. However, asymptotics do not give conclusions for fixed n. We prove that the maximal reset threshold for binary PFAs is strictly greater than \((n-1)^2\) if and only if \(n\ge 6\).
Michiel de Bondt;Extremal Binary PFAs in a Černý Family.;Stijn Cambie, Henk Don;[<span itemprop="pagination">78-89</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_7;The largest known reset thresholds for DFAs are equal to \((n-1)^2\), where n is the number of states. This is conjectured to be the maximum possible. PFAs (with partial transition function) can have exponentially large reset thresholds. This is still true if we restrict to binary PFAs. However, asymptotics do not give conclusions for fixed n. We prove that the maximal reset threshold for binary PFAs is strictly greater than \((n-1)^2\) if and only if \(n\ge 6\).
Henk Don;Extremal Binary PFAs in a Černý Family.;Stijn Cambie, Michiel de Bondt;[<span itemprop="pagination">78-89</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_7;The largest known reset thresholds for DFAs are equal to \((n-1)^2\), where n is the number of states. This is conjectured to be the maximum possible. PFAs (with partial transition function) can have exponentially large reset thresholds. This is still true if we restrict to binary PFAs. However, asymptotics do not give conclusions for fixed n. We prove that the maximal reset threshold for binary PFAs is strictly greater than \((n-1)^2\) if and only if \(n\ge 6\).
Laura Ciobanu;Variations on the Post Correspondence Problem for Free Groups.;Alan D. Logan;[<span itemprop="pagination">90-102</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_8;The Post Correspondence Problem is a classical decision problem about equalisers of free monoid homomorphisms. We prove connections between several variations of this classical problem, but in the setting of free groups and free group homomorphisms. Among other results, and working under certain injectivity assumptions, we prove that computing the rank of the equaliser of a pair of free group homomorphisms can be applied to computing a basis of this equaliser, and also to solve the “generalised” Post Correspondence Problem for free groups.
Alan D. Logan;Variations on the Post Correspondence Problem for Free Groups.;Laura Ciobanu;[<span itemprop="pagination">90-102</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_8;The Post Correspondence Problem is a classical decision problem about equalisers of free monoid homomorphisms. We prove connections between several variations of this classical problem, but in the setting of free groups and free group homomorphisms. Among other results, and working under certain injectivity assumptions, we prove that computing the rank of the equaliser of a pair of free group homomorphisms can be applied to computing a basis of this equaliser, and also to solve the “generalised” Post Correspondence Problem for free groups.
Stefano Crespi-Reghizzi;Reducing Local Alphabet Size in Recognizable Picture Languages.;Antonio Restivo, Pierluigi San Pietro;[<span itemprop="pagination">103-116</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_9;A recognizable picture language is defined as the projection of a local picture language defined by a set of two-by-two tiles, i.e. by a strictly-locally-testable (SLT) language of order 2. The family of recognizable picture languages is also defined, using larger k by k tiles, \(k&gt.2\), by the projection of the corresponding SLT language. A basic measure of the descriptive complexity of a picture language is given by the size of the SLT alphabet using two-by-two tiles, more precisely by the so-called alphabetic ratio of sizes: SLT-alphabet/picture-alphabet. We study how the alphabetic ratio changes moving from two to larger tile sizes, and we obtain the following result: any recognizable picture language over an alphabet of size n is the projection of an SLT language over an alphabet of size 2n. Moreover, two is the minimal alphabetic ratio possible in general. This result reproduces into two dimensions a similar property (known as Extended Medvedev’s theorem) of the regular word languages, concerning the minimal alphabetic ratio needed to define a language by means of a projection of an SLT word language.
Antonio Restivo;Reducing Local Alphabet Size in Recognizable Picture Languages.;Stefano Crespi-Reghizzi, Pierluigi San Pietro;[<span itemprop="pagination">103-116</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_9;A recognizable picture language is defined as the projection of a local picture language defined by a set of two-by-two tiles, i.e. by a strictly-locally-testable (SLT) language of order 2. The family of recognizable picture languages is also defined, using larger k by k tiles, \(k&gt.2\), by the projection of the corresponding SLT language. A basic measure of the descriptive complexity of a picture language is given by the size of the SLT alphabet using two-by-two tiles, more precisely by the so-called alphabetic ratio of sizes: SLT-alphabet/picture-alphabet. We study how the alphabetic ratio changes moving from two to larger tile sizes, and we obtain the following result: any recognizable picture language over an alphabet of size n is the projection of an SLT language over an alphabet of size 2n. Moreover, two is the minimal alphabetic ratio possible in general. This result reproduces into two dimensions a similar property (known as Extended Medvedev’s theorem) of the regular word languages, concerning the minimal alphabetic ratio needed to define a language by means of a projection of an SLT word language.
Pierluigi San Pietro;Reducing Local Alphabet Size in Recognizable Picture Languages.;Stefano Crespi-Reghizzi, Antonio Restivo;[<span itemprop="pagination">103-116</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_9;A recognizable picture language is defined as the projection of a local picture language defined by a set of two-by-two tiles, i.e. by a strictly-locally-testable (SLT) language of order 2. The family of recognizable picture languages is also defined, using larger k by k tiles, \(k&gt.2\), by the projection of the corresponding SLT language. A basic measure of the descriptive complexity of a picture language is given by the size of the SLT alphabet using two-by-two tiles, more precisely by the so-called alphabetic ratio of sizes: SLT-alphabet/picture-alphabet. We study how the alphabetic ratio changes moving from two to larger tile sizes, and we obtain the following result: any recognizable picture language over an alphabet of size n is the projection of an SLT language over an alphabet of size 2n. Moreover, two is the minimal alphabetic ratio possible in general. This result reproduces into two dimensions a similar property (known as Extended Medvedev’s theorem) of the regular word languages, concerning the minimal alphabetic ratio needed to define a language by means of a projection of an SLT word language.
Volker Diekert;Properties of Graphs Specified by a Regular Language.;Henning Fernau, Petra Wolf;[<span itemprop="pagination">117-129</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_10;Traditionally, graph algorithms get a single graph as input, and then they should decide if this graph satisfies a certain property \(\varPhi \). What happens if this question is modified in a way that we get a possibly infinite family of graphs as an input, and the question is if there exists one graph satisfying \(\varPhi \)? We approach this question by using formal languages for specifying families of graphs. In particular, we show that certain graph properties can be decided by studying the syntactic monoid of the specification language.
Henning Fernau;Properties of Graphs Specified by a Regular Language.;Volker Diekert, Petra Wolf;[<span itemprop="pagination">117-129</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_10;Traditionally, graph algorithms get a single graph as input, and then they should decide if this graph satisfies a certain property \(\varPhi \). What happens if this question is modified in a way that we get a possibly infinite family of graphs as an input, and the question is if there exists one graph satisfying \(\varPhi \)? We approach this question by using formal languages for specifying families of graphs. In particular, we show that certain graph properties can be decided by studying the syntactic monoid of the specification language.
Petra Wolf;Properties of Graphs Specified by a Regular Language.;Volker Diekert, Henning Fernau;[<span itemprop="pagination">117-129</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_10;Traditionally, graph algorithms get a single graph as input, and then they should decide if this graph satisfies a certain property \(\varPhi \). What happens if this question is modified in a way that we get a possibly infinite family of graphs as an input, and the question is if there exists one graph satisfying \(\varPhi \)? We approach this question by using formal languages for specifying families of graphs. In particular, we show that certain graph properties can be decided by studying the syntactic monoid of the specification language.
Luc Edixhoven;Balanced-By-Construction Regular and ømega-Regular Languages.;Sung-Shik Jongmans;[<span itemprop="pagination">130-142</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_11;\(\mathrm {Paren_n}\) is the typical generalisation of the Dyck language to multiple types of parentheses. We generalise its notion of balancedness to allow parentheses of different types to freely commute. We show that balanced regular and \(\omega \)-regular languages can be characterised by syntactic constraints on regular and \(\omega \)-regular expressions and, using the shuffle on trajectories operator, we define grammars for balanced-by-construction expressions with which one can express every balanced regular and \(\omega \)-regular language.
Sung-Shik Jongmans;Balanced-By-Construction Regular and ømega-Regular Languages.;Luc Edixhoven;[<span itemprop="pagination">130-142</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_11;\(\mathrm {Paren_n}\) is the typical generalisation of the Dyck language to multiple types of parentheses. We generalise its notion of balancedness to allow parentheses of different types to freely commute. We show that balanced regular and \(\omega \)-regular languages can be characterised by syntactic constraints on regular and \(\omega \)-regular expressions and, using the shuffle on trajectories operator, we define grammars for balanced-by-construction expressions with which one can express every balanced regular and \(\omega \)-regular language.
Yannik Eikmeier;Weighted Prefix Normal Words: Mind the Gap.;Pamela Fleischmann, Mitja Kulczynski, Dirk Nowotka;[<span itemprop="pagination">143-154</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_12;A prefix normal word is a binary word whose prefixes contain at least as many 1s as any of its factors of the same length. Introduced by Fici and Lipták in 2011, the notion of prefix normality has been, thus far, only defined for words over the binary alphabet. In this work we investigate a generalisation for finite words over arbitrary finite alphabets, namely weighted prefix normality. We prove that weighted prefix normality is more expressive than binary prefix normality. Furthermore, we investigate the existence of a weighted prefix normal form, since weighted prefix normality comes with several new peculiarities that did not already occur in the binary case. We characterise these issues and finally present a standard technique to obtain a generalised prefix normal form for all words over arbitrary, finite alphabets.
Pamela Fleischmann;Weighted Prefix Normal Words: Mind the Gap.;Yannik Eikmeier, Mitja Kulczynski, Dirk Nowotka;[<span itemprop="pagination">143-154</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_12;A prefix normal word is a binary word whose prefixes contain at least as many 1s as any of its factors of the same length. Introduced by Fici and Lipták in 2011, the notion of prefix normality has been, thus far, only defined for words over the binary alphabet. In this work we investigate a generalisation for finite words over arbitrary finite alphabets, namely weighted prefix normality. We prove that weighted prefix normality is more expressive than binary prefix normality. Furthermore, we investigate the existence of a weighted prefix normal form, since weighted prefix normality comes with several new peculiarities that did not already occur in the binary case. We characterise these issues and finally present a standard technique to obtain a generalised prefix normal form for all words over arbitrary, finite alphabets.
Mitja Kulczynski;Weighted Prefix Normal Words: Mind the Gap.;Yannik Eikmeier, Pamela Fleischmann, Dirk Nowotka;[<span itemprop="pagination">143-154</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_12;A prefix normal word is a binary word whose prefixes contain at least as many 1s as any of its factors of the same length. Introduced by Fici and Lipták in 2011, the notion of prefix normality has been, thus far, only defined for words over the binary alphabet. In this work we investigate a generalisation for finite words over arbitrary finite alphabets, namely weighted prefix normality. We prove that weighted prefix normality is more expressive than binary prefix normality. Furthermore, we investigate the existence of a weighted prefix normal form, since weighted prefix normality comes with several new peculiarities that did not already occur in the binary case. We characterise these issues and finally present a standard technique to obtain a generalised prefix normal form for all words over arbitrary, finite alphabets.
Dirk Nowotka;Weighted Prefix Normal Words: Mind the Gap.;Yannik Eikmeier, Pamela Fleischmann, Mitja Kulczynski;[<span itemprop="pagination">143-154</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_12;A prefix normal word is a binary word whose prefixes contain at least as many 1s as any of its factors of the same length. Introduced by Fici and Lipták in 2011, the notion of prefix normality has been, thus far, only defined for words over the binary alphabet. In this work we investigate a generalisation for finite words over arbitrary finite alphabets, namely weighted prefix normality. We prove that weighted prefix normality is more expressive than binary prefix normality. Furthermore, we investigate the existence of a weighted prefix normal form, since weighted prefix normality comes with several new peculiarities that did not already occur in the binary case. We characterise these issues and finally present a standard technique to obtain a generalised prefix normal form for all words over arbitrary, finite alphabets.
Fabian Frei;Two-Way Non-uniform Finite Automata.;Juraj Hromkovic, Richard Královic, Rastislav Královic;[<span itemprop="pagination">155-166</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_13;We consider two-tape automata where one tape contains the input word w, and the other contains an advice string \(\alpha (|w|)\) for some function \(\alpha :\mathbb {N}\rightarrow \varSigma ^*\). Such an automaton recognizes a language L if there is an advice function for which every word on the input tape is correctly classified. This model has been introduced by Küçük with the aim to model non-uniform computation on finite automata. So far, most of the results concerned automata whose tapes are both 1-way. First, we show that making even one of the tapes 2-way increases the model’s power. Then we turn our attention to the case of both tapes being 2-way, which can also be viewed as a restricted version of the non-uniform families of automata used by Ibarra and Ravikumar to define the class \(\mathsf{NUDSPACE}\). We show this restriction to be not very significant since, e. g., , i. e., languages recognized by automata with 2-way input and advice tape with polynomial advice equals \(\mathsf{NUDSPACE} (O(\log (n)))\). Hence, we can show that many interesting problems concerning the state complexity of families of automata carry over to the problems concerning advice size of non-uniform automata. In particular, the question whether there can be a more than polynomial gap in advice between determinism and non-determinism is of great interest: e. g., the existence of a language that can be recognized by some 2-way NFA with some k heads on the advice tape and with polynomial (resp. logarithmic) advice, while a corresponding 2-head DFA would need exponential (resp. polynomial) advice, would imply \(\mathsf {L\not =NL}\) (resp. \(\mathsf {LL\not =NLL}\)). We show that for advice of size \((\log n)^{o(1)}\) there is no gap between determinism and non-determinism. In general, we can show that the gap is not more than exponential.
Juraj Hromkovic;Two-Way Non-uniform Finite Automata.;Fabian Frei, Richard Královic, Rastislav Královic;[<span itemprop="pagination">155-166</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_13;We consider two-tape automata where one tape contains the input word w, and the other contains an advice string \(\alpha (|w|)\) for some function \(\alpha :\mathbb {N}\rightarrow \varSigma ^*\). Such an automaton recognizes a language L if there is an advice function for which every word on the input tape is correctly classified. This model has been introduced by Küçük with the aim to model non-uniform computation on finite automata. So far, most of the results concerned automata whose tapes are both 1-way. First, we show that making even one of the tapes 2-way increases the model’s power. Then we turn our attention to the case of both tapes being 2-way, which can also be viewed as a restricted version of the non-uniform families of automata used by Ibarra and Ravikumar to define the class \(\mathsf{NUDSPACE}\). We show this restriction to be not very significant since, e. g., , i. e., languages recognized by automata with 2-way input and advice tape with polynomial advice equals \(\mathsf{NUDSPACE} (O(\log (n)))\). Hence, we can show that many interesting problems concerning the state complexity of families of automata carry over to the problems concerning advice size of non-uniform automata. In particular, the question whether there can be a more than polynomial gap in advice between determinism and non-determinism is of great interest: e. g., the existence of a language that can be recognized by some 2-way NFA with some k heads on the advice tape and with polynomial (resp. logarithmic) advice, while a corresponding 2-head DFA would need exponential (resp. polynomial) advice, would imply \(\mathsf {L\not =NL}\) (resp. \(\mathsf {LL\not =NLL}\)). We show that for advice of size \((\log n)^{o(1)}\) there is no gap between determinism and non-determinism. In general, we can show that the gap is not more than exponential.
Richard Královic;Two-Way Non-uniform Finite Automata.;Fabian Frei, Juraj Hromkovic, Rastislav Královic;[<span itemprop="pagination">155-166</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_13;We consider two-tape automata where one tape contains the input word w, and the other contains an advice string \(\alpha (|w|)\) for some function \(\alpha :\mathbb {N}\rightarrow \varSigma ^*\). Such an automaton recognizes a language L if there is an advice function for which every word on the input tape is correctly classified. This model has been introduced by Küçük with the aim to model non-uniform computation on finite automata. So far, most of the results concerned automata whose tapes are both 1-way. First, we show that making even one of the tapes 2-way increases the model’s power. Then we turn our attention to the case of both tapes being 2-way, which can also be viewed as a restricted version of the non-uniform families of automata used by Ibarra and Ravikumar to define the class \(\mathsf{NUDSPACE}\). We show this restriction to be not very significant since, e. g., , i. e., languages recognized by automata with 2-way input and advice tape with polynomial advice equals \(\mathsf{NUDSPACE} (O(\log (n)))\). Hence, we can show that many interesting problems concerning the state complexity of families of automata carry over to the problems concerning advice size of non-uniform automata. In particular, the question whether there can be a more than polynomial gap in advice between determinism and non-determinism is of great interest: e. g., the existence of a language that can be recognized by some 2-way NFA with some k heads on the advice tape and with polynomial (resp. logarithmic) advice, while a corresponding 2-head DFA would need exponential (resp. polynomial) advice, would imply \(\mathsf {L\not =NL}\) (resp. \(\mathsf {LL\not =NLL}\)). We show that for advice of size \((\log n)^{o(1)}\) there is no gap between determinism and non-determinism. In general, we can show that the gap is not more than exponential.
Rastislav Královic;Two-Way Non-uniform Finite Automata.;Fabian Frei, Juraj Hromkovic, Richard Královic;[<span itemprop="pagination">155-166</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_13;We consider two-tape automata where one tape contains the input word w, and the other contains an advice string \(\alpha (|w|)\) for some function \(\alpha :\mathbb {N}\rightarrow \varSigma ^*\). Such an automaton recognizes a language L if there is an advice function for which every word on the input tape is correctly classified. This model has been introduced by Küçük with the aim to model non-uniform computation on finite automata. So far, most of the results concerned automata whose tapes are both 1-way. First, we show that making even one of the tapes 2-way increases the model’s power. Then we turn our attention to the case of both tapes being 2-way, which can also be viewed as a restricted version of the non-uniform families of automata used by Ibarra and Ravikumar to define the class \(\mathsf{NUDSPACE}\). We show this restriction to be not very significant since, e. g., , i. e., languages recognized by automata with 2-way input and advice tape with polynomial advice equals \(\mathsf{NUDSPACE} (O(\log (n)))\). Hence, we can show that many interesting problems concerning the state complexity of families of automata carry over to the problems concerning advice size of non-uniform automata. In particular, the question whether there can be a more than polynomial gap in advice between determinism and non-determinism is of great interest: e. g., the existence of a language that can be recognized by some 2-way NFA with some k heads on the advice tape and with polynomial (resp. logarithmic) advice, while a corresponding 2-head DFA would need exponential (resp. polynomial) advice, would imply \(\mathsf {L\not =NL}\) (resp. \(\mathsf {LL\not =NLL}\)). We show that for advice of size \((\log n)^{o(1)}\) there is no gap between determinism and non-determinism. In general, we can show that the gap is not more than exponential.
Vesa Halava;Integer Weighted Automata on Infinite Words.;Tero Harju, Reino Niskanen, Igor Potapov;[<span itemprop="pagination">167-179</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_14;In this paper we combine two classical generalisations of finite automata (weighted automata and automata on infinite words) into a model of integer weighted automata on infinite words and study the universality and the emptiness problems under zero weight acceptance. We show that the universality problem is undecidable for three-state automata by a direct reduction from the infinite Post correspondence problem. We also consider other more general acceptance conditions as well as their complements with respect to the universality and the emptiness problems. Additionally, we build a universal integer weighted automaton where the automaton is fixed and the word problem is undecidable.
Tero Harju;Integer Weighted Automata on Infinite Words.;Vesa Halava, Reino Niskanen, Igor Potapov;[<span itemprop="pagination">167-179</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_14;In this paper we combine two classical generalisations of finite automata (weighted automata and automata on infinite words) into a model of integer weighted automata on infinite words and study the universality and the emptiness problems under zero weight acceptance. We show that the universality problem is undecidable for three-state automata by a direct reduction from the infinite Post correspondence problem. We also consider other more general acceptance conditions as well as their complements with respect to the universality and the emptiness problems. Additionally, we build a universal integer weighted automaton where the automaton is fixed and the word problem is undecidable.
Reino Niskanen;Integer Weighted Automata on Infinite Words.;Vesa Halava, Tero Harju, Igor Potapov;[<span itemprop="pagination">167-179</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_14;In this paper we combine two classical generalisations of finite automata (weighted automata and automata on infinite words) into a model of integer weighted automata on infinite words and study the universality and the emptiness problems under zero weight acceptance. We show that the universality problem is undecidable for three-state automata by a direct reduction from the infinite Post correspondence problem. We also consider other more general acceptance conditions as well as their complements with respect to the universality and the emptiness problems. Additionally, we build a universal integer weighted automaton where the automaton is fixed and the word problem is undecidable.
Igor Potapov;Integer Weighted Automata on Infinite Words.;Vesa Halava, Tero Harju, Reino Niskanen;[<span itemprop="pagination">167-179</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_14;In this paper we combine two classical generalisations of finite automata (weighted automata and automata on infinite words) into a model of integer weighted automata on infinite words and study the universality and the emptiness problems under zero weight acceptance. We show that the universality problem is undecidable for three-state automata by a direct reduction from the infinite Post correspondence problem. We also consider other more general acceptance conditions as well as their complements with respect to the universality and the emptiness problems. Additionally, we build a universal integer weighted automaton where the automaton is fixed and the word problem is undecidable.
Viktor Henriksson;None;Manfred Kufleitner;[<span itemprop="pagination">180-191</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_15;We consider two-variable first-order logic \(\text {FO}^2\) and its quantifier alternation hierarchies over both finite and infinite words. Our main results are forbidden patterns for deterministic automata (finite words) and for Carton-Michel automata (infinite words). In order to give concise patterns, we allow the use of subwords on paths in finite graphs. This concept is formalized as subword patterns. Deciding the presence or absence of such a pattern in a given automaton is in \(\mathbf {NL} \). In particular, this leads to \(\mathbf {NL} \) algorithms for deciding the levels of the \(\text {FO}^2\) quantifier alternation hierarchies. This applies to both full and half levels, each over finite and infinite words. Moreover, we show that these problems are \(\mathbf {NL} \)-hard and, hence, \(\mathbf {NL} \)-complete.
Manfred Kufleitner;None;Viktor Henriksson;[<span itemprop="pagination">180-191</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_15;We consider two-variable first-order logic \(\text {FO}^2\) and its quantifier alternation hierarchies over both finite and infinite words. Our main results are forbidden patterns for deterministic automata (finite words) and for Carton-Michel automata (infinite words). In order to give concise patterns, we allow the use of subwords on paths in finite graphs. This concept is formalized as subword patterns. Deciding the presence or absence of such a pattern in a given automaton is in \(\mathbf {NL} \). In particular, this leads to \(\mathbf {NL} \) algorithms for deciding the levels of the \(\text {FO}^2\) quantifier alternation hierarchies. This applies to both full and half levels, each over finite and infinite words. Moreover, we show that these problems are \(\mathbf {NL} \)-hard and, hence, \(\mathbf {NL} \)-complete.
Stefan Hoffmann;State Complexity of Projection on Languages Recognized by Permutation Automata and Commuting Letters.;;[<span itemprop="pagination">192-203</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_16;The projected language of a general deterministic automaton with n states is recognizable by a deterministic automaton with \(2^{n-1} + 2^{n-m} - 1\) states, where m denotes the number of states incident to unobservable non-loop transitions, and this bound is best possible. Here, we derive the tight bound \(2^{n - \lceil \frac{m}{2} \rceil } - 1\) for permutation automata. For a state-partition automaton with n states (also called automata with the observer property) the projected language is recognizable with n states. Up to now, these, and finite languages projected onto unary languages, were the only classes of automata known to possess this property. We show that this is also true for commutative automata and we find commutative automata that are not state-partition automata.
Stefan Hoffmann;Constrained Synchronization and Subset Synchronization Problems for Weakly Acyclic Automata.;;[<span itemprop="pagination">204-216</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_17;We investigate the constrained synchronization problem for weakly acyclic, or partially ordered, input automata. We show that, for input automata of this type, the problem is always in \(\textsf {NP}\). Furthermore, we give a full classification of the realizable complexities for constraint automata with at most two states and over a ternary alphabet. We find that most constrained problems that are PSPACE-complete in general become NP-complete. However, there also exist constrained problems that are PSPACE-complete in the general setting but become polynomial time solvable when considered for weakly acyclic input automata. We also investigate two problems related to subset synchronization, namely if there exists a word mapping all states into a given target subset of states, and if there exists a word mapping one subset into another. Both problems are \(\textsf {PSPACE}\)-complete in general, but in our setting the former is polynomial time solvable and the latter is \(\textsf {NP}\)-complete.
Stepan Holub;Lyndon Words Formalized in Isabelle/HOL.;Stepán Starosta;[<span itemprop="pagination">217-228</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_18;We present a formalization of Lyndon words and basic relevant results in Isabelle/HOL. We give a short review of Isabelle/HOL and focus on challenges that arise in this formalization. The presented formalization is based on an ongoing larger project of formalization of combinatorics on words.
Stepán Starosta;Lyndon Words Formalized in Isabelle/HOL.;Stepan Holub;[<span itemprop="pagination">217-228</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_18;We present a formalization of Lyndon words and basic relevant results in Isabelle/HOL. We give a short review of Isabelle/HOL and focus on challenges that arise in this formalization. The presented formalization is based on an ongoing larger project of formalization of combinatorics on words.
Markus Holzer;The Range of State Complexities of Languages Resulting from the Cascade Product - The General Case (Extended Abstract).;Christian Rauch;[<span itemprop="pagination">229-241</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_19;We continue our investigation on the descriptional complexity of the cascade product of finite state devices started in [M. Holzer, C. Rauch: The Range of State Complexities of Languages Resulting from the Cascade Product—The Unary Case (Extended Abstract). Proc. CIAA, 2021]. Here we study the general case, that is, cascade products of reset, permutation-reset, permutation, and finite automata in general, where the left operand automaton has an alphabet of size at least two. In all cases, except for the cascade product of two permutation automata, it is shown that the whole range of state complexities, namely the interval [1, nm], where n is the state complexity of the left operand and m that of the right one, is reachable. The cascade product of two permutation automata produces a lot of non-reachable numbers—numbers of this kind are called magic in the relevant literature—even for arbitrary alphabet sizes. These results are in sharp contrast to the unary case.
Christian Rauch;The Range of State Complexities of Languages Resulting from the Cascade Product - The General Case (Extended Abstract).;Markus Holzer;[<span itemprop="pagination">229-241</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_19;We continue our investigation on the descriptional complexity of the cascade product of finite state devices started in [M. Holzer, C. Rauch: The Range of State Complexities of Languages Resulting from the Cascade Product—The Unary Case (Extended Abstract). Proc. CIAA, 2021]. Here we study the general case, that is, cascade products of reset, permutation-reset, permutation, and finite automata in general, where the left operand automaton has an alphabet of size at least two. In all cases, except for the cascade product of two permutation automata, it is shown that the whole range of state complexities, namely the interval [1, nm], where n is the state complexity of the left operand and m that of the right one, is reachable. The cascade product of two permutation automata produces a lot of non-reachable numbers—numbers of this kind are called magic in the relevant literature—even for arbitrary alphabet sizes. These results are in sharp contrast to the unary case.
Dietrich Kuske;Second-Order Finite Automata: Expressive Power and Simple Proofs Using Automatic Structures.;;[<span itemprop="pagination">242-254</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_20;Second-order finite automata, introduced recently by Andrade de Melo and de Oliveira Oliveira, represent classes of languages. Since their semantics is defined by a synchronized rational relation, they can be studied using the theory of automatic structures. We exploit this connection to uniformly reprove and strengthen known and new results regarding closure and decidability properties concerning these automata. We then proceed to characterize their expressive power in terms of automatic classes of languages studied by Jain, Luo, and Stephan.
Martin Kutrib;Reversible Top-Down Syntax Analysis.;Uwe Meyer;[<span itemprop="pagination">255-266</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_21;Top-down syntax analysis can be based on \(\mathrm {LL}(k)\) grammars. The canonical acceptors for \(\mathrm {LL}(k)\) languages are deterministic stateless pushdown automata with input lookahead of size k. We investigate the computational capacity of reversible computations of such automata. A pushdown automaton with lookahead k is said to be reversible if its predecessor configurations can uniquely be computed by a pushdown automaton with backward input lookahead (lookback) of size k. It is shown that we cannot trade a lookahead for states or vice versa. The impact of having states or a lookahead depends on the language. While reversible pushdown automata with states accept all regular languages, we are going to prove that there are regular languages that cannot be accepted reversibly without states, even in case of an arbitrarily large lookahead. This completes the comparison of reversible with ordinary pushdown automata in our setting. Finally, it turns out that there are problems which can be solved by reversible deterministic stateless pushdown automata with lookahead of size \(k+1\), but not by any reversible deterministic stateless pushdown automaton with lookahead of size k. So, an infinite and tight hierarchy of language families dependent on the size of the lookahead is shown.
Uwe Meyer;Reversible Top-Down Syntax Analysis.;Martin Kutrib;[<span itemprop="pagination">255-266</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_21;Top-down syntax analysis can be based on \(\mathrm {LL}(k)\) grammars. The canonical acceptors for \(\mathrm {LL}(k)\) languages are deterministic stateless pushdown automata with input lookahead of size k. We investigate the computational capacity of reversible computations of such automata. A pushdown automaton with lookahead k is said to be reversible if its predecessor configurations can uniquely be computed by a pushdown automaton with backward input lookahead (lookback) of size k. It is shown that we cannot trade a lookahead for states or vice versa. The impact of having states or a lookahead depends on the language. While reversible pushdown automata with states accept all regular languages, we are going to prove that there are regular languages that cannot be accepted reversibly without states, even in case of an arbitrarily large lookahead. This completes the comparison of reversible with ordinary pushdown automata in our setting. Finally, it turns out that there are problems which can be solved by reversible deterministic stateless pushdown automata with lookahead of size \(k+1\), but not by any reversible deterministic stateless pushdown automaton with lookahead of size k. So, an infinite and tight hierarchy of language families dependent on the size of the lookahead is shown.
Sergey Luchinin;Symmetry Groups of Infinite Words.;Svetlana Puzynina;[<span itemprop="pagination">267-278</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_22;In this paper we introduce a new notion of a symmetry group of an infinite word. Given a subgroup \(G_n\) of the symmetric group \(S_n\), it acts on the set of finite words of length n by permutation. For each n, a symmetry group of an infinite word w is a subgroup \(G_n\) of the symmetric group \(S_n\) such that g(v) is a factor of w for each permutation \(g \in G_n\) and each factor v of w. We study general properties of symmetry groups of infinite words and characterize symmetry groups of several families of infinite words. We show that symmetry groups of Sturmian words and more generally Arnoux-Rauzy words are of order two for large enough n. on the other hand, symmetry groups of certain Toeplitz words have exponential growth.
Svetlana Puzynina;Symmetry Groups of Infinite Words.;Sergey Luchinin;[<span itemprop="pagination">267-278</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_22;In this paper we introduce a new notion of a symmetry group of an infinite word. Given a subgroup \(G_n\) of the symmetric group \(S_n\), it acts on the set of finite words of length n by permutation. For each n, a symmetry group of an infinite word w is a subgroup \(G_n\) of the symmetric group \(S_n\) such that g(v) is a factor of w for each permutation \(g \in G_n\) and each factor v of w. We study general properties of symmetry groups of infinite words and characterize symmetry groups of several families of infinite words. We show that symmetry groups of Sturmian words and more generally Arnoux-Rauzy words are of order two for large enough n. on the other hand, symmetry groups of certain Toeplitz words have exponential growth.
Vladislav Makarov;Bounded Languages Described by GF(2)-grammars.;;[<span itemprop="pagination">279-290</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_23;GF(2)-grammars are a recently introduced grammar family that has some unusual algebraic properties and is closely connected to the family of unambiguous grammars. By using the method of formal power series, we establish strong conditions that are necessary for subsets of \(a_1^* a_2^* \cdots a_k^*\) to be described by some GF(2)-grammar. By further applying the established results, we settle the long-standing open question of proving the inherent ambiguity of the language \(\{ \, a^n b^m c^\ell \mid n \ne m \text { or } m \ne \ell \, \}\), as well as give a new, purely algebraic, proof of the inherent ambiguity of the language \(\{ \, a^n b^m c^\ell \mid n = m \text { or } m = \ell \, \}\).
Sebastian Maneth;Definability Results for Top-Down Tree Transducers.;Helmut Seidl, Martin Vu;[<span itemprop="pagination">291-303</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_24;We prove that for a given deterministic top-down transducer with look-ahead it is decidable whether or not its translation is definable (1) by a linear top-down tree transducer or (2) by a tree homomorphism. We present algorithms that construct equivalent such transducers if they exist.
Helmut Seidl;Definability Results for Top-Down Tree Transducers.;Sebastian Maneth, Martin Vu;[<span itemprop="pagination">291-303</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_24;We prove that for a given deterministic top-down transducer with look-ahead it is decidable whether or not its translation is definable (1) by a linear top-down tree transducer or (2) by a tree homomorphism. We present algorithms that construct equivalent such transducers if they exist.
Martin Vu;Definability Results for Top-Down Tree Transducers.;Sebastian Maneth, Helmut Seidl;[<span itemprop="pagination">291-303</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_24;We prove that for a given deterministic top-down transducer with look-ahead it is decidable whether or not its translation is definable (1) by a linear top-down tree transducer or (2) by a tree homomorphism. We present algorithms that construct equivalent such transducers if they exist.
Mikhail Mrykhin;The Hardest LL(k) Language.;Alexander Okhotin;[<span itemprop="pagination">304-315</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_25;This paper establishes an analogue of Greibach’s hardest language theorem (“The hardest context-free language”, SIAM J. Comp., 1973) for the subfamily of LL languages. The first result is that there is a language \(L_0\) defined by an LL(1) grammar in the Greibach normal form, to which every language L defined by an LL(1) grammar in the Greibach normal form can be reduced by a homomorphism, that is, \(w \in L\) if and only if \(h(w) \in L_0\). Then it is shown that this statement does not hold for LL(k) languages. The second hardest language theorem is then established in the following form: there is a language \(L_0\) defined by an LL(1) grammar in the Greibach normal form, such that, for every language L defined by an LL(k) grammar, there exists a homomorphism h, for which \(w \in L\) if and only if \(h(w \$) \in L_0\), where \(\$\) is a new symbol.
Alexander Okhotin;The Hardest LL(k) Language.;Mikhail Mrykhin;[<span itemprop="pagination">304-315</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_25;This paper establishes an analogue of Greibach’s hardest language theorem (“The hardest context-free language”, SIAM J. Comp., 1973) for the subfamily of LL languages. The first result is that there is a language \(L_0\) defined by an LL(1) grammar in the Greibach normal form, to which every language L defined by an LL(1) grammar in the Greibach normal form can be reduced by a homomorphism, that is, \(w \in L\) if and only if \(h(w) \in L_0\). Then it is shown that this statement does not hold for LL(k) languages. The second hardest language theorem is then established in the following form: there is a language \(L_0\) defined by an LL(1) grammar in the Greibach normal form, such that, for every language L defined by an LL(k) grammar, there exists a homomorphism h, for which \(w \in L\) if and only if \(h(w \$) \in L_0\), where \(\$\) is a new symbol.
Julian Pape-Lange;Upper Bounds on Distinct Maximal (Sub-)Repetitions in Compressed Strings.;;[<span itemprop="pagination">316-327</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_26;For \(\delta \in \mathbb {R}^+\), maximal \(\delta \)-repetitions (\(\delta \)-subrepetitions) are fractional powers with exponent of at least \(2+\delta \) (and \(1+\delta \), respectively) which are non-extendable with respect to their minimum period.
Elena A. Petrova;Branching Frequency and Markov Entropy of Repetition-Free Languages.;Arseny M. Shur;[<span itemprop="pagination">328-341</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_27;We define a new quantitative measure for an arbitrary factorial language: the entropy of a random walk in the prefix tree associated with the language. we call it Markov entropy. We relate Markov entropy to the growth rate of the language and the parameters of branching of its prefix tree. We show how to compute Markov entropy for a regular language. Finally, we develop a framework for experimental study of Markov entropy by modelling random walks and present the results of experiments with power-free and Abelian-power-free languages.
Arseny M. Shur;Branching Frequency and Markov Entropy of Repetition-Free Languages.;Elena A. Petrova;[<span itemprop="pagination">328-341</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_27;We define a new quantitative measure for an arbitrary factorial language: the entropy of a random walk in the prefix tree associated with the language. we call it Markov entropy. We relate Markov entropy to the growth rate of the language and the parameters of branching of its prefix tree. We show how to compute Markov entropy for a regular language. Finally, we develop a framework for experimental study of Markov entropy by modelling random walks and present the results of experiments with power-free and Abelian-power-free languages.
Alexander A. Rubtsov;A Linear-Time Simulation of Deterministic d-Limited Automata.;;[<span itemprop="pagination">342-354</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_28;A d-limited automaton is a nondeterministic Turing machine that uses only the cells with the input word (and end-markers) and rewrites symbols only in the first d visits. This model was introduced by T. Hibbard in 1967 and he showed that d-limited automata recognize context-free languages for each \(d \geqslant 2\). He also proved that languages recognizable by deterministic d-limited automata form a hierarchy and it was shown later by Pighizzini and Pisoni that it begins with deterministic context-free languages (DCFLs) (for \(d=2\)).
Ryoma Sin'ya;Carathéodory Extensions of Subclasses of Regular Languages.;;[<span itemprop="pagination">355-367</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_29;A language \(L\) is said to be regular measurable if there exists an infinite sequence of regular languages that “converges” to \(L\). In [<a aria-label="Reference 13" data-test="citation-ref" data-track="click" data-track-action="reference anchor" data-track-label="link" href="#ref-CR13" id="ref-link-section-d3414142e643" title="Sin’ya, R.: Asymptotic approximation by regular languages. In: Bureš, T., et al. (eds.) SOFSEM 2021. LNCS, vol. 12607, pp. 74–88. Springer, Cham (2021).                     https://doi.org/10.1007/978-3-030-67731-2_6                                      ">13], the author showed that, while many complex context-free languages are regular measurable, the set of all primitive words and certain deterministic context-free languages are regular immeasurable. This paper investigates general properties of measurability, including closure properties, decidability and different characterisation. Further, for a suitable subclass \({\mathcal C}\) of regular languages, we show that the class of all \({\mathcal C}\)-measurable regular languages has a good algebraic structure.
Nobin Thomas;Parikh Word Representable Graphs and Morphisms.;Lisa Mathew, Somnath Bera, Atulya K. Nagar, K. G. Subramanian;[<span itemprop="pagination">368-379</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_30;Study on numerical properties of words based on scattered subwords of words was initiated around the year 2000, introducing certain upper triangular matrices, called Parikh matrices. On the other hand, linking the areas of combinatorics on words and graph theory, a class of graphs, called Parikh word representable graphs (PWRG) of words, was introduced based on certain scattered subwords of words. Several properties of PWRG have been investigated, especially corresponding to binary words. Here, we derive several structural properties of PWRG of images of ternary words under certain morphisms.
Lisa Mathew;Parikh Word Representable Graphs and Morphisms.;Nobin Thomas, Somnath Bera, Atulya K. Nagar, K. G. Subramanian;[<span itemprop="pagination">368-379</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_30;Study on numerical properties of words based on scattered subwords of words was initiated around the year 2000, introducing certain upper triangular matrices, called Parikh matrices. On the other hand, linking the areas of combinatorics on words and graph theory, a class of graphs, called Parikh word representable graphs (PWRG) of words, was introduced based on certain scattered subwords of words. Several properties of PWRG have been investigated, especially corresponding to binary words. Here, we derive several structural properties of PWRG of images of ternary words under certain morphisms.
Somnath Bera;Parikh Word Representable Graphs and Morphisms.;Nobin Thomas, Lisa Mathew, Atulya K. Nagar, K. G. Subramanian;[<span itemprop="pagination">368-379</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_30;Study on numerical properties of words based on scattered subwords of words was initiated around the year 2000, introducing certain upper triangular matrices, called Parikh matrices. On the other hand, linking the areas of combinatorics on words and graph theory, a class of graphs, called Parikh word representable graphs (PWRG) of words, was introduced based on certain scattered subwords of words. Several properties of PWRG have been investigated, especially corresponding to binary words. Here, we derive several structural properties of PWRG of images of ternary words under certain morphisms.
Atulya K. Nagar;Parikh Word Representable Graphs and Morphisms.;Nobin Thomas, Lisa Mathew, Somnath Bera, K. G. Subramanian;[<span itemprop="pagination">368-379</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_30;Study on numerical properties of words based on scattered subwords of words was initiated around the year 2000, introducing certain upper triangular matrices, called Parikh matrices. On the other hand, linking the areas of combinatorics on words and graph theory, a class of graphs, called Parikh word representable graphs (PWRG) of words, was introduced based on certain scattered subwords of words. Several properties of PWRG have been investigated, especially corresponding to binary words. Here, we derive several structural properties of PWRG of images of ternary words under certain morphisms.
K. G. Subramanian;Parikh Word Representable Graphs and Morphisms.;Nobin Thomas, Lisa Mathew, Somnath Bera, Atulya K. Nagar;[<span itemprop="pagination">368-379</span>];[<meta content="2021" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-81508-0_30;Study on numerical properties of words based on scattered subwords of words was initiated around the year 2000, introducing certain upper triangular matrices, called Parikh matrices. On the other hand, linking the areas of combinatorics on words and graph theory, a class of graphs, called Parikh word representable graphs (PWRG) of words, was introduced based on certain scattered subwords of words. Several properties of PWRG have been investigated, especially corresponding to binary words. Here, we derive several structural properties of PWRG of images of ternary words under certain morphisms.
Amazigh Amrane;Equational Theories of Scattered and Countable Series-Parallel Posets.;Nicolas Bedon;[<span itemprop="pagination">1-13</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_1;In this paper we consider two classes of posets labeled over an alphabet A. The class \(SP^\diamond (A)\) is built from the letters and closed under the operations of series finite, \(\omega \) and \({\overline{\omega }}\) products, and finite parallel product. In the class \(^{\omega }{}SP(A)\), \(\omega \) and \({\overline{\omega }}\) products are replaced by \(\omega \) and \({\overline{\omega }}\) powers. We prove that \(SP^\diamond (A)\) and \(^{\omega }{}SP(A)\) are freely generated in their respective natural varieties of algebras \({\mathcal {V}}\) and \({\mathcal {V}}'\), and that the equational theory of \({\mathcal {V}}'\) is decidable.
Nicolas Bedon;Equational Theories of Scattered and Countable Series-Parallel Posets.;Amazigh Amrane;[<span itemprop="pagination">1-13</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_1;In this paper we consider two classes of posets labeled over an alphabet A. The class \(SP^\diamond (A)\) is built from the letters and closed under the operations of series finite, \(\omega \) and \({\overline{\omega }}\) products, and finite parallel product. In the class \(^{\omega }{}SP(A)\), \(\omega \) and \({\overline{\omega }}\) products are replaced by \(\omega \) and \({\overline{\omega }}\) powers. We prove that \(SP^\diamond (A)\) and \(^{\omega }{}SP(A)\) are freely generated in their respective natural varieties of algebras \({\mathcal {V}}\) and \({\mathcal {V}}'\), and that the equational theory of \({\mathcal {V}}'\) is decidable.
Laura Barker;Scattered Factor-Universality of Words.;Pamela Fleischmann, Katharina Harwardt, Florin Manea, Dirk Nowotka;[<span itemprop="pagination">14-28</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_2;A word \(u=u_1\dots u_n\) is a scattered factor of a word w if u can be obtained from w by deleting some of its letters: there exist the (potentially empty) words \(v_0,v_1,..\,,v_n\) such that \(w = v_0u_1v_1...u_nv_n\). The set of all scattered factors up to length k of a word is called its full k-spectrum. Firstly, we show an algorithm deciding whether the k-spectra for given k of two words are equal or not, running in optimal time. Secondly, we consider a notion of scattered-factors universality: the word w, with \(\text {alph}(w)=\varSigma \), is called k-universal if its k-spectrum includes all words of length k over the alphabet \(\varSigma \). we extend this notion to k-circular universality. After a series of preliminary combinatorial results, we present an algorithm computing, for a given \(k'\)-universal word w the minimal i such that \(w^i\) is k-universal for some \(k&gt.k'\). Several other connected problems are also considered.
Pamela Fleischmann;Scattered Factor-Universality of Words.;Laura Barker, Katharina Harwardt, Florin Manea, Dirk Nowotka;[<span itemprop="pagination">14-28</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_2;A word \(u=u_1\dots u_n\) is a scattered factor of a word w if u can be obtained from w by deleting some of its letters: there exist the (potentially empty) words \(v_0,v_1,..\,,v_n\) such that \(w = v_0u_1v_1...u_nv_n\). The set of all scattered factors up to length k of a word is called its full k-spectrum. Firstly, we show an algorithm deciding whether the k-spectra for given k of two words are equal or not, running in optimal time. Secondly, we consider a notion of scattered-factors universality: the word w, with \(\text {alph}(w)=\varSigma \), is called k-universal if its k-spectrum includes all words of length k over the alphabet \(\varSigma \). we extend this notion to k-circular universality. After a series of preliminary combinatorial results, we present an algorithm computing, for a given \(k'\)-universal word w the minimal i such that \(w^i\) is k-universal for some \(k&gt.k'\). Several other connected problems are also considered.
Katharina Harwardt;Scattered Factor-Universality of Words.;Laura Barker, Pamela Fleischmann, Florin Manea, Dirk Nowotka;[<span itemprop="pagination">14-28</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_2;A word \(u=u_1\dots u_n\) is a scattered factor of a word w if u can be obtained from w by deleting some of its letters: there exist the (potentially empty) words \(v_0,v_1,..\,,v_n\) such that \(w = v_0u_1v_1...u_nv_n\). The set of all scattered factors up to length k of a word is called its full k-spectrum. Firstly, we show an algorithm deciding whether the k-spectra for given k of two words are equal or not, running in optimal time. Secondly, we consider a notion of scattered-factors universality: the word w, with \(\text {alph}(w)=\varSigma \), is called k-universal if its k-spectrum includes all words of length k over the alphabet \(\varSigma \). we extend this notion to k-circular universality. After a series of preliminary combinatorial results, we present an algorithm computing, for a given \(k'\)-universal word w the minimal i such that \(w^i\) is k-universal for some \(k&gt.k'\). Several other connected problems are also considered.
Florin Manea;Scattered Factor-Universality of Words.;Laura Barker, Pamela Fleischmann, Katharina Harwardt, Dirk Nowotka;[<span itemprop="pagination">14-28</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_2;A word \(u=u_1\dots u_n\) is a scattered factor of a word w if u can be obtained from w by deleting some of its letters: there exist the (potentially empty) words \(v_0,v_1,..\,,v_n\) such that \(w = v_0u_1v_1...u_nv_n\). The set of all scattered factors up to length k of a word is called its full k-spectrum. Firstly, we show an algorithm deciding whether the k-spectra for given k of two words are equal or not, running in optimal time. Secondly, we consider a notion of scattered-factors universality: the word w, with \(\text {alph}(w)=\varSigma \), is called k-universal if its k-spectrum includes all words of length k over the alphabet \(\varSigma \). we extend this notion to k-circular universality. After a series of preliminary combinatorial results, we present an algorithm computing, for a given \(k'\)-universal word w the minimal i such that \(w^i\) is k-universal for some \(k&gt.k'\). Several other connected problems are also considered.
Dirk Nowotka;Scattered Factor-Universality of Words.;Laura Barker, Pamela Fleischmann, Katharina Harwardt, Florin Manea;[<span itemprop="pagination">14-28</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_2;A word \(u=u_1\dots u_n\) is a scattered factor of a word w if u can be obtained from w by deleting some of its letters: there exist the (potentially empty) words \(v_0,v_1,..\,,v_n\) such that \(w = v_0u_1v_1...u_nv_n\). The set of all scattered factors up to length k of a word is called its full k-spectrum. Firstly, we show an algorithm deciding whether the k-spectra for given k of two words are equal or not, running in optimal time. Secondly, we consider a notion of scattered-factors universality: the word w, with \(\text {alph}(w)=\varSigma \), is called k-universal if its k-spectrum includes all words of length k over the alphabet \(\varSigma \). we extend this notion to k-circular universality. After a series of preliminary combinatorial results, we present an algorithm computing, for a given \(k'\)-universal word w the minimal i such that \(w^i\) is k-universal for some \(k&gt.k'\). Several other connected problems are also considered.
Collin Bleak;On Normalish Subgroups of the R. Thompson Groups.;;[<span itemprop="pagination">29-42</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_3;Results in \(C^*\) algebras, of Matte Bon and Le Boudec, and of Haagerup and Olesen, apply to the R. Thompson groups \(F\le T\le V\). These results together show that F is non-amenable if and only if T has a simple reduced \(C^*\)-algebra.
Hyunjoon Cheon;Computing the Shortest String and the Edit-Distance for Parsing Expression Languages.;Yo-Sub Han;[<span itemprop="pagination">43-54</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_4;A distance between two languages is a useful tool to measure the language similarity, and is closely related to the intersection problem as well as the shortest string problem. A parsing expression grammar (PEG) is an unambiguous grammar such that the choice operator selects the first matching in PEG while it can be ambiguous in a context-free grammar. PEGs are also closely related to top-down parsing languages. We consider two problems on parsing expression languages (PELs). One is the r-shortest string problem that decides whether or not a given PEL contains a string of length shorter than r. The other problem is the edit-distance problem of PELs with respect to other language families such as finite languages or regular languages. We show that the r-shortest string problem and the edit-distance problem with respect to finite languages are NEXPTIME-complete, and the edit-distance problem with respect to regular languages is undecidable. In addition, we prove that it is impossible to compute a length bound \(\mathcal {B}(G)\) of a PEG G such that L(G) has a string w of length at most \(\mathcal {B}(G)\).
Yo-Sub Han;Computing the Shortest String and the Edit-Distance for Parsing Expression Languages.;Hyunjoon Cheon;[<span itemprop="pagination">43-54</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_4;A distance between two languages is a useful tool to measure the language similarity, and is closely related to the intersection problem as well as the shortest string problem. A parsing expression grammar (PEG) is an unambiguous grammar such that the choice operator selects the first matching in PEG while it can be ambiguous in a context-free grammar. PEGs are also closely related to top-down parsing languages. We consider two problems on parsing expression languages (PELs). One is the r-shortest string problem that decides whether or not a given PEL contains a string of length shorter than r. The other problem is the edit-distance problem of PELs with respect to other language families such as finite languages or regular languages. We show that the r-shortest string problem and the edit-distance problem with respect to finite languages are NEXPTIME-complete, and the edit-distance problem with respect to regular languages is undecidable. In addition, we prove that it is impossible to compute a length bound \(\mathcal {B}(G)\) of a PEG G such that L(G) has a string w of length at most \(\mathcal {B}(G)\).
Fabienne Chouraqui;An Approach to the Herzog-Schönheim Conjecture Using Automata.;;[<span itemprop="pagination">55-68</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_5;Let G be a group and \(H_1\),..., \(H_s\) be subgroups of G of indices \(d_1,\ldots ,d_s\) respectively. In 1974, M. Herzog and J. Schönheim conjectured that if \(\{H_i\alpha _i\}_{i=1}^{i=s}\), \(\alpha _i\in G\), is a coset partition of G, then \(d_1,\ldots ,d_s\) cannot be distinct. In this paper, we present a new approach to the Herzog-Schönheim conjecture based on automata and present a translation of the conjecture as a problem on automata.
Mateus de Oliveira Oliveira;On the Fine Grained Complexity of Finite Automata Non-emptiness of Intersection.;Michael Wehar;[<span itemprop="pagination">69-82</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_6;We study the fine grained complexity of the DFA non-emptiness of intersection problem parameterized by the number k of input automata (k -DFA-NEI). More specifically, we are given a list \(\langle \mathcal {A}_1,...,\mathcal {A}_k\rangle \) of DFA’s over a common alphabet \(\varSigma \), and the goal is to determine whether \(\bigcap _{i=1}^{k}{\mathcal {L}}(\mathcal {A}_i)\ne \emptyset \). This problem can be solved in time \(O(n^k)\) by applying the classic Rabin-Scott product construction. In this work, we show that the existence of algorithms solving k -DFA-NEI in time slightly faster than \(O(n^k)\) would imply the existence of deterministic sub-exponential time algorithms for the simulation of nondeterministic linear space bounded computations. This consequence strengthens the existing conditional lower bounds for k-DFA-NEI and implies new non-uniform circuit lower bounds.
Michael Wehar;On the Fine Grained Complexity of Finite Automata Non-emptiness of Intersection.;Mateus de Oliveira Oliveira;[<span itemprop="pagination">69-82</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_6;We study the fine grained complexity of the DFA non-emptiness of intersection problem parameterized by the number k of input automata (k -DFA-NEI). More specifically, we are given a list \(\langle \mathcal {A}_1,...,\mathcal {A}_k\rangle \) of DFA’s over a common alphabet \(\varSigma \), and the goal is to determine whether \(\bigcap _{i=1}^{k}{\mathcal {L}}(\mathcal {A}_i)\ne \emptyset \). This problem can be solved in time \(O(n^k)\) by applying the classic Rabin-Scott product construction. In this work, we show that the existence of algorithms solving k -DFA-NEI in time slightly faster than \(O(n^k)\) would imply the existence of deterministic sub-exponential time algorithms for the simulation of nondeterministic linear space bounded computations. This consequence strengthens the existing conditional lower bounds for k-DFA-NEI and implies new non-uniform circuit lower bounds.
Lukas Fleischer;The State Complexity of Lexicographically Smallest Words and Computing Successors.;Jeffrey O. Shallit;[<span itemprop="pagination">83-95</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_7;Given a regular language L over an ordered alphabet \(\varSigma \), the set of lexicographically smallest (resp., largest) words of each length is itself regular. Moreover, there exists an unambiguous finite-state transducer that, on a given word \(w \in \varSigma ^*\), outputs the length-lexicographically smallest word larger than w (henceforth called the L-successor of w). In both cases, naïve constructions result in an exponential blowup in the number of states. We prove that if L is recognized by a DFA with n states, then \(2^{\varTheta (\sqrt{n \log n})}\) states are sufficient for a DFA to recognize the subset S(L) of L composed of its lexicographically smallest words. We give a matching lower bound that holds even if S(L) is represented as an NFA. We then show that the same upper and lower bounds hold for an unambiguous finite-state transducer that computes L-successors.
Jeffrey O. Shallit;The State Complexity of Lexicographically Smallest Words and Computing Successors.;Lukas Fleischer;[<span itemprop="pagination">83-95</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_7;Given a regular language L over an ordered alphabet \(\varSigma \), the set of lexicographically smallest (resp., largest) words of each length is itself regular. Moreover, there exists an unambiguous finite-state transducer that, on a given word \(w \in \varSigma ^*\), outputs the length-lexicographically smallest word larger than w (henceforth called the L-successor of w). In both cases, naïve constructions result in an exponential blowup in the number of states. We prove that if L is recognized by a DFA with n states, then \(2^{\varTheta (\sqrt{n \log n})}\) states are sufficient for a DFA to recognize the subset S(L) of L composed of its lexicographically smallest words. We give a matching lower bound that holds even if S(L) is represented as an NFA. We then show that the same upper and lower bounds hold for an unambiguous finite-state transducer that computes L-successors.
Pamela Fleischmann;Reconstructing Words from Right-Bounded-Block Words.;Marie Lejeune, Florin Manea, Dirk Nowotka, Michel Rigo;[<span itemprop="pagination">96-109</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_8;A reconstruction problem of words from scattered factors asks for the minimal information, like multisets of scattered factors of a given length or the number of occurrences of scattered factors from a given set, necessary to uniquely determine a word. We show that a word \(w\in \{\mathtt {a},\mathtt {b}\}^*\) can be reconstructed from the number of occurrences of at most \(\min (|w|_\mathtt {a},|w|_\mathtt {b})+1\) scattered factors of the form \(\mathtt {a}^i \mathtt {b}\), where \(|w|_{\mathtt {a}}\) is the number of occurrences of the letter \(\mathtt {a}\) in w. Moreover, we generalize the result to alphabets of the form \(\{1, \ldots , q\}\) by showing that at most \(\sum _{i=1}^{q-1} |w|_i \, (q-i+1)\) scattered factors suffices to reconstruct w. Both results improve on the upper bounds known so far. Complexity time bounds on reconstruction algorithms are also considered here.
Marie Lejeune;Reconstructing Words from Right-Bounded-Block Words.;Pamela Fleischmann, Florin Manea, Dirk Nowotka, Michel Rigo;[<span itemprop="pagination">96-109</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_8;A reconstruction problem of words from scattered factors asks for the minimal information, like multisets of scattered factors of a given length or the number of occurrences of scattered factors from a given set, necessary to uniquely determine a word. We show that a word \(w\in \{\mathtt {a},\mathtt {b}\}^*\) can be reconstructed from the number of occurrences of at most \(\min (|w|_\mathtt {a},|w|_\mathtt {b})+1\) scattered factors of the form \(\mathtt {a}^i \mathtt {b}\), where \(|w|_{\mathtt {a}}\) is the number of occurrences of the letter \(\mathtt {a}\) in w. Moreover, we generalize the result to alphabets of the form \(\{1, \ldots , q\}\) by showing that at most \(\sum _{i=1}^{q-1} |w|_i \, (q-i+1)\) scattered factors suffices to reconstruct w. Both results improve on the upper bounds known so far. Complexity time bounds on reconstruction algorithms are also considered here.
Florin Manea;Reconstructing Words from Right-Bounded-Block Words.;Pamela Fleischmann, Marie Lejeune, Dirk Nowotka, Michel Rigo;[<span itemprop="pagination">96-109</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_8;A reconstruction problem of words from scattered factors asks for the minimal information, like multisets of scattered factors of a given length or the number of occurrences of scattered factors from a given set, necessary to uniquely determine a word. We show that a word \(w\in \{\mathtt {a},\mathtt {b}\}^*\) can be reconstructed from the number of occurrences of at most \(\min (|w|_\mathtt {a},|w|_\mathtt {b})+1\) scattered factors of the form \(\mathtt {a}^i \mathtt {b}\), where \(|w|_{\mathtt {a}}\) is the number of occurrences of the letter \(\mathtt {a}\) in w. Moreover, we generalize the result to alphabets of the form \(\{1, \ldots , q\}\) by showing that at most \(\sum _{i=1}^{q-1} |w|_i \, (q-i+1)\) scattered factors suffices to reconstruct w. Both results improve on the upper bounds known so far. Complexity time bounds on reconstruction algorithms are also considered here.
Dirk Nowotka;Reconstructing Words from Right-Bounded-Block Words.;Pamela Fleischmann, Marie Lejeune, Florin Manea, Michel Rigo;[<span itemprop="pagination">96-109</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_8;A reconstruction problem of words from scattered factors asks for the minimal information, like multisets of scattered factors of a given length or the number of occurrences of scattered factors from a given set, necessary to uniquely determine a word. We show that a word \(w\in \{\mathtt {a},\mathtt {b}\}^*\) can be reconstructed from the number of occurrences of at most \(\min (|w|_\mathtt {a},|w|_\mathtt {b})+1\) scattered factors of the form \(\mathtt {a}^i \mathtt {b}\), where \(|w|_{\mathtt {a}}\) is the number of occurrences of the letter \(\mathtt {a}\) in w. Moreover, we generalize the result to alphabets of the form \(\{1, \ldots , q\}\) by showing that at most \(\sum _{i=1}^{q-1} |w|_i \, (q-i+1)\) scattered factors suffices to reconstruct w. Both results improve on the upper bounds known so far. Complexity time bounds on reconstruction algorithms are also considered here.
Michel Rigo;Reconstructing Words from Right-Bounded-Block Words.;Pamela Fleischmann, Marie Lejeune, Florin Manea, Dirk Nowotka;[<span itemprop="pagination">96-109</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_8;A reconstruction problem of words from scattered factors asks for the minimal information, like multisets of scattered factors of a given length or the number of occurrences of scattered factors from a given set, necessary to uniquely determine a word. We show that a word \(w\in \{\mathtt {a},\mathtt {b}\}^*\) can be reconstructed from the number of occurrences of at most \(\min (|w|_\mathtt {a},|w|_\mathtt {b})+1\) scattered factors of the form \(\mathtt {a}^i \mathtt {b}\), where \(|w|_{\mathtt {a}}\) is the number of occurrences of the letter \(\mathtt {a}\) in w. Moreover, we generalize the result to alphabets of the form \(\{1, \ldots , q\}\) by showing that at most \(\sum _{i=1}^{q-1} |w|_i \, (q-i+1)\) scattered factors suffices to reconstruct w. Both results improve on the upper bounds known so far. Complexity time bounds on reconstruction algorithms are also considered here.
Pascal Caron;A Study of a Simple Class of Modifiers: Product Modifiers.;Edwin Hamel-De le Court, Jean-Gabriel Luque;[<span itemprop="pagination">110-121</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_9;A modifier is a k-ary operator acting on DFAs and producing a DFA. Modifiers are involved in the theory of state complexity. We define and study a class of simple modifiers, called product modifiers, and we link closely the regular operations they encode to boolean operations.
Edwin Hamel-De le Court;A Study of a Simple Class of Modifiers: Product Modifiers.;Pascal Caron, Jean-Gabriel Luque;[<span itemprop="pagination">110-121</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_9;A modifier is a k-ary operator acting on DFAs and producing a DFA. Modifiers are involved in the theory of state complexity. We define and study a class of simple modifiers, called product modifiers, and we link closely the regular operations they encode to boolean operations.
Jean-Gabriel Luque;A Study of a Simple Class of Modifiers: Product Modifiers.;Pascal Caron, Edwin Hamel-De le Court;[<span itemprop="pagination">110-121</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_9;A modifier is a k-ary operator acting on DFAs and producing a DFA. Modifiers are involved in the theory of state complexity. We define and study a class of simple modifiers, called product modifiers, and we link closely the regular operations they encode to boolean operations.
Michal Hospodár;Operations on Permutation Automata.;Peter Mlynárcik;[<span itemprop="pagination">122-136</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_10;We investigate the class of languages recognized by permutation deterministic finite automata. Using automata constructions and some properties of permutation automata, we show that this class is closed under Boolean operations, reversal, and quotients, and it is not closed under concatenation, power, Kleene closure, positive closure, cut, shuffle, cyclic shift, and permutation. We prove that the state complexity of Boolean operations, Kleene closure, positive closure, and right quotient on permutation languages is the same as in the general case of regular languages. Next, we get the tight upper bounds on the state complexity of concatenation (\(m2^n-2^{n-1}-m+1\)), square (\(n2^{n-1}-2^{n-2}\)), reversal (\(n\atopwithdelims ()\lceil n/2\rceil \)), and left quotient (\(m\atopwithdelims ()\lceil m/2\rceil \). tight if \(m\le n\)). All our witnesses are unary or binary, and the binary alphabet is always optimal, except for Boolean operations in the case of \(\gcd (m,n)=1\). In the unary case, the state complexity of all considered operations is the same as for regular languages, except for quotients and cut. In case of quotients, it is \(\min \{m,n\}\), and in case of cut, it is either \(2m-1\) or \(2m-2\), depending on whether there exists an integer \(\ell \) with \(2\le \ell \le n\) such that \(m\bmod \ell \ne 0\).
Peter Mlynárcik;Operations on Permutation Automata.;Michal Hospodár;[<span itemprop="pagination">122-136</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_10;We investigate the class of languages recognized by permutation deterministic finite automata. Using automata constructions and some properties of permutation automata, we show that this class is closed under Boolean operations, reversal, and quotients, and it is not closed under concatenation, power, Kleene closure, positive closure, cut, shuffle, cyclic shift, and permutation. We prove that the state complexity of Boolean operations, Kleene closure, positive closure, and right quotient on permutation languages is the same as in the general case of regular languages. Next, we get the tight upper bounds on the state complexity of concatenation (\(m2^n-2^{n-1}-m+1\)), square (\(n2^{n-1}-2^{n-2}\)), reversal (\(n\atopwithdelims ()\lceil n/2\rceil \)), and left quotient (\(m\atopwithdelims ()\lceil m/2\rceil \). tight if \(m\le n\)). All our witnesses are unary or binary, and the binary alphabet is always optimal, except for Boolean operations in the case of \(\gcd (m,n)=1\). In the unary case, the state complexity of all considered operations is the same as for regular languages, except for quotients and cut. In case of quotients, it is \(\min \{m,n\}\), and in case of cut, it is either \(2m-1\) or \(2m-2\), depending on whether there exists an integer \(\ell \) with \(2\le \ell \le n\) such that \(m\bmod \ell \ne 0\).
Oscar H. Ibarra;Space Complexity of Stack Automata Models.;Jozef Jirásek Jr., Ian McQuillan, Luca Prigioniero;[<span itemprop="pagination">137-149</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_11;This paper examines several measures of space complexity on variants of stack automata: non-erasing stack automata and checking stack automata. These measures capture the minimum stack size required to accept any word in a language (weak measure), the maximum stack size used in any accepting computation on any accepted word (accept measure), and the maximum stack size used in any computation (strong measure). We give a detailed characterization of the accept and strong space complexity measures for checking stack automata. Exactly one of three cases can occur: the complexity is either bounded by a constant, behaves (up to small technicalities explained in the paper) like a linear function, or it grows arbitrarily larger than the length of the input word. However, this result does not hold for non-erasing stack automata. we provide an example when the space complexity grows with the square root of the input length. Furthermore, an investigation is done regarding the best complexity of any machine accepting a given language, and on decidability of space complexity properties.
Jozef Jirásek Jr.;Space Complexity of Stack Automata Models.;Oscar H. Ibarra, Ian McQuillan, Luca Prigioniero;[<span itemprop="pagination">137-149</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_11;This paper examines several measures of space complexity on variants of stack automata: non-erasing stack automata and checking stack automata. These measures capture the minimum stack size required to accept any word in a language (weak measure), the maximum stack size used in any accepting computation on any accepted word (accept measure), and the maximum stack size used in any computation (strong measure). We give a detailed characterization of the accept and strong space complexity measures for checking stack automata. Exactly one of three cases can occur: the complexity is either bounded by a constant, behaves (up to small technicalities explained in the paper) like a linear function, or it grows arbitrarily larger than the length of the input word. However, this result does not hold for non-erasing stack automata. we provide an example when the space complexity grows with the square root of the input length. Furthermore, an investigation is done regarding the best complexity of any machine accepting a given language, and on decidability of space complexity properties.
Ian McQuillan;Space Complexity of Stack Automata Models.;Oscar H. Ibarra, Jozef Jirásek Jr., Luca Prigioniero;[<span itemprop="pagination">137-149</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_11;This paper examines several measures of space complexity on variants of stack automata: non-erasing stack automata and checking stack automata. These measures capture the minimum stack size required to accept any word in a language (weak measure), the maximum stack size used in any accepting computation on any accepted word (accept measure), and the maximum stack size used in any computation (strong measure). We give a detailed characterization of the accept and strong space complexity measures for checking stack automata. Exactly one of three cases can occur: the complexity is either bounded by a constant, behaves (up to small technicalities explained in the paper) like a linear function, or it grows arbitrarily larger than the length of the input word. However, this result does not hold for non-erasing stack automata. we provide an example when the space complexity grows with the square root of the input length. Furthermore, an investigation is done regarding the best complexity of any machine accepting a given language, and on decidability of space complexity properties.
Luca Prigioniero;Space Complexity of Stack Automata Models.;Oscar H. Ibarra, Jozef Jirásek Jr., Ian McQuillan;[<span itemprop="pagination">137-149</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_11;This paper examines several measures of space complexity on variants of stack automata: non-erasing stack automata and checking stack automata. These measures capture the minimum stack size required to accept any word in a language (weak measure), the maximum stack size used in any accepting computation on any accepted word (accept measure), and the maximum stack size used in any computation (strong measure). We give a detailed characterization of the accept and strong space complexity measures for checking stack automata. Exactly one of three cases can occur: the complexity is either bounded by a constant, behaves (up to small technicalities explained in the paper) like a linear function, or it grows arbitrarily larger than the length of the input word. However, this result does not hold for non-erasing stack automata. we provide an example when the space complexity grows with the square root of the input length. Furthermore, an investigation is done regarding the best complexity of any machine accepting a given language, and on decidability of space complexity properties.
Lila Kari;Descriptional Complexity of Semi-simple Splicing Systems.;Timothy Ng;[<span itemprop="pagination">150-163</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_12;Splicing systems are generative mechanisms introduced by Tom Head in 1987 to model the biological process of DNA recombination. The computational engine of a splicing system is the “splicing operation”, a cut-and-paste binary string operation defined by a set of “splicing rules”, quadruples \(r = (u_1, u_2 . u_3, u_4)\) where \(u_1, u_2, u_3, u_4\) are words over an alphabet \(\varSigma \). For two strings \( x_1 u_1 u_2 y_1\) and \( x_2 u_3 u_4 y_2\), applying the splicing rule r produces the string \( x_1 u_1 u_4 y_2\). In this paper we focus on a particular type of splicing systems, called (i, j) semi-simple splicing systems, \(i = 1,2\) and \(j = 3, 4\), wherein all splicing rules r have the property that the two strings in positions i and j in r are singleton letters, while the other two strings are empty. The language generated by such a system consists of the set of words that are obtained starting from an initial set called “axiom set”, by iteratively applying the splicing rules to strings in the axiom set as well as to intermediately produced strings. We consider semi-simple splicing systems where the axiom set is a regular language, and investigate the descriptional complexity of such systems in terms of the size of the minimal deterministic finite automata that recognize the languages they generate.
Timothy Ng;Descriptional Complexity of Semi-simple Splicing Systems.;Lila Kari;[<span itemprop="pagination">150-163</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_12;Splicing systems are generative mechanisms introduced by Tom Head in 1987 to model the biological process of DNA recombination. The computational engine of a splicing system is the “splicing operation”, a cut-and-paste binary string operation defined by a set of “splicing rules”, quadruples \(r = (u_1, u_2 . u_3, u_4)\) where \(u_1, u_2, u_3, u_4\) are words over an alphabet \(\varSigma \). For two strings \( x_1 u_1 u_2 y_1\) and \( x_2 u_3 u_4 y_2\), applying the splicing rule r produces the string \( x_1 u_1 u_4 y_2\). In this paper we focus on a particular type of splicing systems, called (i, j) semi-simple splicing systems, \(i = 1,2\) and \(j = 3, 4\), wherein all splicing rules r have the property that the two strings in positions i and j in r are singleton letters, while the other two strings are empty. The language generated by such a system consists of the set of words that are obtained starting from an initial set called “axiom set”, by iteratively applying the splicing rules to strings in the axiom set as well as to intermediately produced strings. We consider semi-simple splicing systems where the axiom set is a regular language, and investigate the descriptional complexity of such systems in terms of the size of the minimal deterministic finite automata that recognize the languages they generate.
Florent Koechlin;On the Degeneracy of Random Expressions Specified by Systems of Combinatorial Equations.;Cyril Nicaud, Pablo Rotondo;[<span itemprop="pagination">164-177</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_13;We consider general expressions, which are trees whose nodes are labeled with operators, that represent syntactic descriptions of formulas. We assume that there is an operator that has an absorbing pattern and prove that if we use this property to simplify a uniform random expression with n nodes, then the expected size of the result is bounded by a constant. In our framework, expressions are defined using a combinatorial system, which describes how they are built: one can ensure, for instance, that there are no two consecutive stars in regular expressions. This generalizes a former result where only one equation was allowed, confirming the lack of expressivity of uniform random expressions.
Cyril Nicaud;On the Degeneracy of Random Expressions Specified by Systems of Combinatorial Equations.;Florent Koechlin, Pablo Rotondo;[<span itemprop="pagination">164-177</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_13;We consider general expressions, which are trees whose nodes are labeled with operators, that represent syntactic descriptions of formulas. We assume that there is an operator that has an absorbing pattern and prove that if we use this property to simplify a uniform random expression with n nodes, then the expected size of the result is bounded by a constant. In our framework, expressions are defined using a combinatorial system, which describes how they are built: one can ensure, for instance, that there are no two consecutive stars in regular expressions. This generalizes a former result where only one equation was allowed, confirming the lack of expressivity of uniform random expressions.
Pablo Rotondo;On the Degeneracy of Random Expressions Specified by Systems of Combinatorial Equations.;Florent Koechlin, Cyril Nicaud;[<span itemprop="pagination">164-177</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_13;We consider general expressions, which are trees whose nodes are labeled with operators, that represent syntactic descriptions of formulas. We assume that there is an operator that has an absorbing pattern and prove that if we use this property to simplify a uniform random expression with n nodes, then the expected size of the result is bounded by a constant. In our framework, expressions are defined using a combinatorial system, which describes how they are built: one can ensure, for instance, that there are no two consecutive stars in regular expressions. This generalizes a former result where only one equation was allowed, confirming the lack of expressivity of uniform random expressions.
Johan Kopra;Dynamics of Cellular Automata on Beta-Shifts and Direct Topological Factorizations.;;[<span itemprop="pagination">178-191</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_14;We consider the range of possible dynamics of cellular automata (CA) on two-sided beta-shifts \(S_\beta \). We show that any reversible CA \(F:S_\beta \rightarrow S_\beta \) has an almost equicontinuous direction whenever \(S_\beta \) is not sofic. This has the corollary that non-sofic beta-shifts are topologically direct prime, i.e. they are not conjugate to direct topological factorizations \(X\times Y\) of two nontrivial subshifts X and Y. We also make some preliminary observations on direct topological factorizations of beta-shifts that are subshifts of finite type.
Florian Lietard;Avoidability of Additive Cubes over Alphabets of Four Numbers.;Matthieu Rosenfeld;[<span itemprop="pagination">192-206</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_15;Let \(\mathcal {A}\subset \mathbb {N}\) be a set of size 4 such that \(\mathcal {A}\) cannot be obtained by applying the same affine function to all of the elements of \(\{0,1,2,3\}\). We show that there is an infinite sequence of elements of \(\mathcal {A}\) that contains no three consecutive blocks of same size and same sum (additive cubes). Moreover, it is possible to replace \(\mathbb {N}\) by \(\mathbb {C}\) in the statement.
Matthieu Rosenfeld;Avoidability of Additive Cubes over Alphabets of Four Numbers.;Florian Lietard;[<span itemprop="pagination">192-206</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_15;Let \(\mathcal {A}\subset \mathbb {N}\) be a set of size 4 such that \(\mathcal {A}\) cannot be obtained by applying the same affine function to all of the elements of \(\{0,1,2,3\}\). We show that there is an infinite sequence of elements of \(\mathcal {A}\) that contains no three consecutive blocks of same size and same sum (additive cubes). Moreover, it is possible to replace \(\mathbb {N}\) by \(\mathbb {C}\) in the statement.
Raphaela Löbel;Equivalence of Linear Tree Transducers with Output in the Free Group.;Michael Luttenberger, Helmut Seidl;[<span itemprop="pagination">207-221</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_16;We show that equivalence of deterministic linear tree transducers can be decided in polynomial time when their outputs are interpreted over the free group. Due to the cancellation properties offered by the free group, the required constructions are not only more general, but also simpler than the corresponding constructions for proving equivalence of deterministic linear tree-to-word transducers.
Michael Luttenberger;Equivalence of Linear Tree Transducers with Output in the Free Group.;Raphaela Löbel, Helmut Seidl;[<span itemprop="pagination">207-221</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_16;We show that equivalence of deterministic linear tree transducers can be decided in polynomial time when their outputs are interpreted over the free group. Due to the cancellation properties offered by the free group, the required constructions are not only more general, but also simpler than the corresponding constructions for proving equivalence of deterministic linear tree-to-word transducers.
Helmut Seidl;Equivalence of Linear Tree Transducers with Output in the Free Group.;Raphaela Löbel, Michael Luttenberger;[<span itemprop="pagination">207-221</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_16;We show that equivalence of deterministic linear tree transducers can be decided in polynomial time when their outputs are interpreted over the free group. Due to the cancellation properties offered by the free group, the required constructions are not only more general, but also simpler than the corresponding constructions for proving equivalence of deterministic linear tree-to-word transducers.
Raphaela Löbel;On the Balancedness of Tree-to-Word Transducers.;Michael Luttenberger, Helmut Seidl;[<span itemprop="pagination">222-236</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_17;A language over an alphabet \(\textsf {B}=\textsf {A}\cup \overline{\textsf {A}}\,\) of opening (\(\textsf {A}\)) and closing (\(\overline{\textsf {A}}\,\)) brackets, is balanced if it is a subset of the Dyck language \({\mathbb D}_\textsf {B}\) over \(\textsf {B}\), and it is well-formed if all words are prefixes of words in \({\mathbb D}_\textsf {B}\). We show that well-formedness of a context-free language is decidable in polynomial time, and that the longest common reduced suffix can be computed in polynomial time. With this at a hand we decide for the class 2-TW of non-linear tree transducers with output alphabet \(\textsf {B}^*\) whether or not the output language is balanced.
Michael Luttenberger;On the Balancedness of Tree-to-Word Transducers.;Raphaela Löbel, Helmut Seidl;[<span itemprop="pagination">222-236</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_17;A language over an alphabet \(\textsf {B}=\textsf {A}\cup \overline{\textsf {A}}\,\) of opening (\(\textsf {A}\)) and closing (\(\overline{\textsf {A}}\,\)) brackets, is balanced if it is a subset of the Dyck language \({\mathbb D}_\textsf {B}\) over \(\textsf {B}\), and it is well-formed if all words are prefixes of words in \({\mathbb D}_\textsf {B}\). We show that well-formedness of a context-free language is decidable in polynomial time, and that the longest common reduced suffix can be computed in polynomial time. With this at a hand we decide for the class 2-TW of non-linear tree transducers with output alphabet \(\textsf {B}^*\) whether or not the output language is balanced.
Helmut Seidl;On the Balancedness of Tree-to-Word Transducers.;Raphaela Löbel, Michael Luttenberger;[<span itemprop="pagination">222-236</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_17;A language over an alphabet \(\textsf {B}=\textsf {A}\cup \overline{\textsf {A}}\,\) of opening (\(\textsf {A}\)) and closing (\(\overline{\textsf {A}}\,\)) brackets, is balanced if it is a subset of the Dyck language \({\mathbb D}_\textsf {B}\) over \(\textsf {B}\), and it is well-formed if all words are prefixes of words in \({\mathbb D}_\textsf {B}\). We show that well-formedness of a context-free language is decidable in polynomial time, and that the longest common reduced suffix can be computed in polynomial time. With this at a hand we decide for the class 2-TW of non-linear tree transducers with output alphabet \(\textsf {B}^*\) whether or not the output language is balanced.
Andreas Maletti;On Tree Substitution Grammars.;Kevin Stier;[<span itemprop="pagination">237-250</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_18;Tree substitution grammars are formal models that are used extensively in natural language processing. It is demonstrated that their expressive power is located strictly between the local tree grammars and the regular tree grammars. A decision procedure for the problem of determining whether a tree substitution grammar generates a local tree language is provided. Unfortunately, the class of tree substitution languages is neither closed under union, nor intersection, nor complements. Indeed unions of tree substitution languages even generate an infinite hierarchy. However, all finite and all co-finite tree languages are tree substitution languages.
Kevin Stier;On Tree Substitution Grammars.;Andreas Maletti;[<span itemprop="pagination">237-250</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_18;Tree substitution grammars are formal models that are used extensively in natural language processing. It is demonstrated that their expressive power is located strictly between the local tree grammars and the regular tree grammars. A decision procedure for the problem of determining whether a tree substitution grammar generates a local tree language is provided. Unfortunately, the class of tree substitution languages is neither closed under union, nor intersection, nor complements. Indeed unions of tree substitution languages even generate an infinite hierarchy. However, all finite and all co-finite tree languages are tree substitution languages.
Augusto Modanese;Sublinear-Time Language Recognition and Decision by One-Dimensional Cellular Automata.;;[<span itemprop="pagination">251-265</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_19;After an apparent hiatus of roughly 30 years, we revisit a seemingly neglected subject in the theory of (one-dimensional) cellular automata: sublinear-time computation. The model considered is that of ACAs, which are language acceptors whose acceptance condition depends on the states of all cells in the automaton. We prove a time hierarchy theorem for sublinear-time ACA classes, analyze their intersection with the regular languages, and, finally, establish strict inclusions in the parallel computation classes \(\mathsf {SC}\) and (uniform) \(\mathsf {AC}\). As an addendum, we introduce and investigate the concept of a decider ACA (DACA) as a candidate for a decider counterpart to (acceptor) ACAs. We show the class of languages decidable in constant time by DACAs equals the locally testable languages, and we also determine \(\varOmega (\sqrt{n})\) as the (tight) time complexity threshold for DACAs up to which no advantage compared to constant time is possible.
Daniel Prusa;Complexity of Searching for 2 by 2 Submatrices in Boolean Matrices.;Michael Wehar;[<span itemprop="pagination">266-279</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_20;We study the problem of finding a given \(2\times 2\) matrix as a submatrix of a given Boolean matrix. Three variants are considered: search for a matching submatrix of any area, of minimum area, or of maximum area. The problem relates to 2D pattern matching, and to fields such as data mining, where the search for submatrices plays an important role. Besides these connections, the problem itself is very natural and its investigation helps to demonstrate differences between search tasks in one-dimensional and multidimensional topologies.
Michael Wehar;Complexity of Searching for 2 by 2 Submatrices in Boolean Matrices.;Daniel Prusa;[<span itemprop="pagination">266-279</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_20;We study the problem of finding a given \(2\times 2\) matrix as a submatrix of a given Boolean matrix. Three variants are considered: search for a matching submatrix of any area, of minimum area, or of maximum area. The problem relates to 2D pattern matching, and to fields such as data mining, where the search for submatrices plays an important role. Besides these connections, the problem itself is very natural and its investigation helps to demonstrate differences between search tasks in one-dimensional and multidimensional topologies.
Eric Rowland;Avoiding 5/4-Powers on the Alphabet of Nonnegative Integers (Extended Abstract).;Manon Stipulanti;[<span itemprop="pagination">280-293</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_21;We identify the structure of the lexicographically least word avoiding 5/4-powers on the alphabet of nonnegative integers.
Manon Stipulanti;Avoiding 5/4-Powers on the Alphabet of Nonnegative Integers (Extended Abstract).;Eric Rowland;[<span itemprop="pagination">280-293</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_21;We identify the structure of the lexicographically least word avoiding 5/4-powers on the alphabet of nonnegative integers.
Josef Rukavicka;Transition Property for α-Power Free Languages with $\alpha \ge 2$ and $k\ge 3$ Letters.;;[<span itemprop="pagination">294-303</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_22;In 1985, Restivo and Salemi presented a list of five problems concerning power free languages. Problem 4 states: Given \(\alpha \)-power-free words u and v, decide whether there is a transition from u to v. Problem 5 states: Given \(\alpha \)-power-free words u and v, find a transition word w, if it exists.
Ryoma Sin'ya;Context-Freeness of Word-MIX Languages.;;[<span itemprop="pagination">304-318</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_23;In this paper we provide a decidable characterisation of the context-freeness of a Word-MIX language \(L_{\!A}(w_1, \ldots , w_k)\), where \(L_{\!A}(w_1, \ldots , w_k)\) is the set of all words over \(A\) that contain the same number of subword occurrences of parameter words \(w_1, \ldots , w_k\).
Andrea Frosini;The Characterization of Rational Numbers Belonging to a Minimal Path in the Stern-Brocot Tree According to a Second Order Balancedness.;Lama Tarsissi;[<span itemprop="pagination">319-331</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_24;In 1842, Dirichlet observed that any real number \(\alpha \) can be obtained as the limit of a sequence \((\frac{p_n}{q_n})\) of irreducible rational numbers. Few years later, M. Stern (1858) and A. Brocot (1861) defined a tree-like arrangement of all the (irreducible) rational numbers whose infinite paths are the Dirichlet sequences of the real numbers and are characterized by their continued fraction representations. The Stern-Brocot tree is equivalent to the Christoffel tree obtained by ordering the Christoffel words according to their standard factorization. We remark that the Fibonacci word’s prefixes belong to a minimal path in the Christoffel tree with respect to the second order balancedness parameter defined on Christoffel words. This alows us to switch back to the Stern-Brocot tree, in order to give a characterization of the continued fraction representation for all the rational numbers belonging to minimal paths with respect to the growth of the second order balancedness.
Lama Tarsissi;The Characterization of Rational Numbers Belonging to a Minimal Path in the Stern-Brocot Tree According to a Second Order Balancedness.;Andrea Frosini;[<span itemprop="pagination">319-331</span>];[<meta content="2020" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-030-48516-0_24;In 1842, Dirichlet observed that any real number \(\alpha \) can be obtained as the limit of a sequence \((\frac{p_n}{q_n})\) of irreducible rational numbers. Few years later, M. Stern (1858) and A. Brocot (1861) defined a tree-like arrangement of all the (irreducible) rational numbers whose infinite paths are the Dirichlet sequences of the real numbers and are characterized by their continued fraction representations. The Stern-Brocot tree is equivalent to the Christoffel tree obtained by ordering the Christoffel words according to their standard factorization. We remark that the Fibonacci word’s prefixes belong to a minimal path in the Christoffel tree with respect to the second order balancedness parameter defined on Christoffel words. This alows us to switch back to the Stern-Brocot tree, in order to give a characterization of the continued fraction representation for all the rational numbers belonging to minimal paths with respect to the growth of the second order balancedness.
Hendrikus J. S. Basten;Context-Free Ambiguity Detection Using Multi-stack Pushdown Automata.;;[<span itemprop="pagination">1-12</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_1;We propose a method for detecting ambiguity in context-free grammars using multi-stack pushdown automata. Since the ambiguity problem is undecidable in general, we use restricted MPDAs that have a limited configuration space. The analysis might thus not be complete, but it is able to detect both ambiguity and unambiguity. Our method is general in the type of automata used. We discuss the suitability of existing MPDAs in our setting and present a new class called bounded-balance MPDAs. These MPDAs allow for infinitely deep nesting/nesting intersection, as long as the nesting depth differences within each scope stay within the balance bound. We compare our contributions to various related MPDAs and ambiguity detection methods.
Nicolas Bedon;Complementation of Branching Automata for Scattered and Countable Series-Parallel Posets.;;[<span itemprop="pagination">13-25</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_2;We prove the closure under complementation of the class of languages of scattered and countable N-free posets recognized by branching automata. The proof relies entirely on effective constructions.
Dmitry Berdinsky;Cayley Automatic Groups and Numerical Characteristics of Turing Transducers.;;[<span itemprop="pagination">26-37</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_3;This paper is devoted to the problem of finding characterizations for Cayley automatic groups. The concept of Cayley automatic groups was recently introduced by Kharlampovich, Khoussainov and Miasnikov. We address this problem by introducing three numerical characteristics of Turing transducers: growth functions, Følner functions and average length growth functions. These three numerical characteristics are the analogs of growth functions, Følner functions and drifts of simple random walks for Cayley graphs of groups. We study these numerical characteristics for Turing transducers obtained from automatic presentations of labeled directed graphs.
Devendra Bhave;A Perfect Class of Context-Sensitive Timed Languages.;Vrunda Dave, Shankara Narayanan Krishna, Ramchandra Phawade, Ashutosh Trivedi;[<span itemprop="pagination">38-50</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_4;Perfect languages—a term coined by Esparza, Ganty, and Majumdar—are the classes of languages that are closed under Boolean operations and enjoy decidable emptiness problem. Perfect languages form the basis for decidable automata-theoretic model-checking for the respective class of models. Regular languages and visibly pushdown languages are paradigmatic examples of perfect languages. Alur and Dill initiated the language-theoretic study of timed languages and introduced timed automata capturing a timed analog of regular languages. However, unlike their untimed counterparts, timed regular languages are not perfect. Alur, Fix, and Henzinger later discovered a perfect subclass of timed languages recognized by event-clock automata. Since then, a number of perfect subclasses of timed context-free languages, such as event-clock visibly pushdown languages, have been proposed. There exist examples of perfect languages even beyond context-free languages:—La Torre, Madhusudan, and Parlato characterized first perfect class of context-sensitive languages via multistack visibly pushdown automata with an explicit bound on number of stages where in each stage at most one stack is used. In this paper we extend their work for timed languages by characterizing a perfect subclass of timed context-sensitive languages called dense-time multistack visibly pushdown languages and provide a logical characterization for this class of timed languages.
Vrunda Dave;A Perfect Class of Context-Sensitive Timed Languages.;Devendra Bhave, Shankara Narayanan Krishna, Ramchandra Phawade, Ashutosh Trivedi;[<span itemprop="pagination">38-50</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_4;Perfect languages—a term coined by Esparza, Ganty, and Majumdar—are the classes of languages that are closed under Boolean operations and enjoy decidable emptiness problem. Perfect languages form the basis for decidable automata-theoretic model-checking for the respective class of models. Regular languages and visibly pushdown languages are paradigmatic examples of perfect languages. Alur and Dill initiated the language-theoretic study of timed languages and introduced timed automata capturing a timed analog of regular languages. However, unlike their untimed counterparts, timed regular languages are not perfect. Alur, Fix, and Henzinger later discovered a perfect subclass of timed languages recognized by event-clock automata. Since then, a number of perfect subclasses of timed context-free languages, such as event-clock visibly pushdown languages, have been proposed. There exist examples of perfect languages even beyond context-free languages:—La Torre, Madhusudan, and Parlato characterized first perfect class of context-sensitive languages via multistack visibly pushdown automata with an explicit bound on number of stages where in each stage at most one stack is used. In this paper we extend their work for timed languages by characterizing a perfect subclass of timed context-sensitive languages called dense-time multistack visibly pushdown languages and provide a logical characterization for this class of timed languages.
Shankara Narayanan Krishna;A Perfect Class of Context-Sensitive Timed Languages.;Devendra Bhave, Vrunda Dave, Ramchandra Phawade, Ashutosh Trivedi;[<span itemprop="pagination">38-50</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_4;Perfect languages—a term coined by Esparza, Ganty, and Majumdar—are the classes of languages that are closed under Boolean operations and enjoy decidable emptiness problem. Perfect languages form the basis for decidable automata-theoretic model-checking for the respective class of models. Regular languages and visibly pushdown languages are paradigmatic examples of perfect languages. Alur and Dill initiated the language-theoretic study of timed languages and introduced timed automata capturing a timed analog of regular languages. However, unlike their untimed counterparts, timed regular languages are not perfect. Alur, Fix, and Henzinger later discovered a perfect subclass of timed languages recognized by event-clock automata. Since then, a number of perfect subclasses of timed context-free languages, such as event-clock visibly pushdown languages, have been proposed. There exist examples of perfect languages even beyond context-free languages:—La Torre, Madhusudan, and Parlato characterized first perfect class of context-sensitive languages via multistack visibly pushdown automata with an explicit bound on number of stages where in each stage at most one stack is used. In this paper we extend their work for timed languages by characterizing a perfect subclass of timed context-sensitive languages called dense-time multistack visibly pushdown languages and provide a logical characterization for this class of timed languages.
Ramchandra Phawade;A Perfect Class of Context-Sensitive Timed Languages.;Devendra Bhave, Vrunda Dave, Shankara Narayanan Krishna, Ashutosh Trivedi;[<span itemprop="pagination">38-50</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_4;Perfect languages—a term coined by Esparza, Ganty, and Majumdar—are the classes of languages that are closed under Boolean operations and enjoy decidable emptiness problem. Perfect languages form the basis for decidable automata-theoretic model-checking for the respective class of models. Regular languages and visibly pushdown languages are paradigmatic examples of perfect languages. Alur and Dill initiated the language-theoretic study of timed languages and introduced timed automata capturing a timed analog of regular languages. However, unlike their untimed counterparts, timed regular languages are not perfect. Alur, Fix, and Henzinger later discovered a perfect subclass of timed languages recognized by event-clock automata. Since then, a number of perfect subclasses of timed context-free languages, such as event-clock visibly pushdown languages, have been proposed. There exist examples of perfect languages even beyond context-free languages:—La Torre, Madhusudan, and Parlato characterized first perfect class of context-sensitive languages via multistack visibly pushdown automata with an explicit bound on number of stages where in each stage at most one stack is used. In this paper we extend their work for timed languages by characterizing a perfect subclass of timed context-sensitive languages called dense-time multistack visibly pushdown languages and provide a logical characterization for this class of timed languages.
Ashutosh Trivedi;A Perfect Class of Context-Sensitive Timed Languages.;Devendra Bhave, Vrunda Dave, Shankara Narayanan Krishna, Ramchandra Phawade;[<span itemprop="pagination">38-50</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_4;Perfect languages—a term coined by Esparza, Ganty, and Majumdar—are the classes of languages that are closed under Boolean operations and enjoy decidable emptiness problem. Perfect languages form the basis for decidable automata-theoretic model-checking for the respective class of models. Regular languages and visibly pushdown languages are paradigmatic examples of perfect languages. Alur and Dill initiated the language-theoretic study of timed languages and introduced timed automata capturing a timed analog of regular languages. However, unlike their untimed counterparts, timed regular languages are not perfect. Alur, Fix, and Henzinger later discovered a perfect subclass of timed languages recognized by event-clock automata. Since then, a number of perfect subclasses of timed context-free languages, such as event-clock visibly pushdown languages, have been proposed. There exist examples of perfect languages even beyond context-free languages:—La Torre, Madhusudan, and Parlato characterized first perfect class of context-sensitive languages via multistack visibly pushdown automata with an explicit bound on number of stages where in each stage at most one stack is used. In this paper we extend their work for timed languages by characterizing a perfect subclass of timed context-sensitive languages called dense-time multistack visibly pushdown languages and provide a logical characterization for this class of timed languages.
Sabine Broda;Position Automaton Construction for Regular Expressions with Intersection.;António Machiavelo, Nelma Moreira, Rogério Reis;[<span itemprop="pagination">51-63</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_5;Positions and derivatives are two essential notions in the conversion methods from regular expressions to equivalent finite automata. Partial derivative based methods have recently been extended to regular expressions with intersection. In this paper, we present a position automaton construction for those expressions. This construction generalizes the notion of position making it compatible with intersection. The resulting automaton is homogeneous and has the partial derivative automaton as its quotient.
António Machiavelo;Position Automaton Construction for Regular Expressions with Intersection.;Sabine Broda, Nelma Moreira, Rogério Reis;[<span itemprop="pagination">51-63</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_5;Positions and derivatives are two essential notions in the conversion methods from regular expressions to equivalent finite automata. Partial derivative based methods have recently been extended to regular expressions with intersection. In this paper, we present a position automaton construction for those expressions. This construction generalizes the notion of position making it compatible with intersection. The resulting automaton is homogeneous and has the partial derivative automaton as its quotient.
Nelma Moreira;Position Automaton Construction for Regular Expressions with Intersection.;Sabine Broda, António Machiavelo, Rogério Reis;[<span itemprop="pagination">51-63</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_5;Positions and derivatives are two essential notions in the conversion methods from regular expressions to equivalent finite automata. Partial derivative based methods have recently been extended to regular expressions with intersection. In this paper, we present a position automaton construction for those expressions. This construction generalizes the notion of position making it compatible with intersection. The resulting automaton is homogeneous and has the partial derivative automaton as its quotient.
Rogério Reis;Position Automaton Construction for Regular Expressions with Intersection.;Sabine Broda, António Machiavelo, Nelma Moreira;[<span itemprop="pagination">51-63</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_5;Positions and derivatives are two essential notions in the conversion methods from regular expressions to equivalent finite automata. Partial derivative based methods have recently been extended to regular expressions with intersection. In this paper, we present a position automaton construction for those expressions. This construction generalizes the notion of position making it compatible with intersection. The resulting automaton is homogeneous and has the partial derivative automaton as its quotient.
Michaël Cadilhac;A Language-Theoretical Approach to Descriptive Complexity.;Andreas Krebs, Klaus-Jörn Lange;[<span itemprop="pagination">64-76</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_6;Logical formulas are naturally decomposed into their subformulas and circuits into their layers. How are these decompositions expressed in a purely language-theoretical setting? We address that question, and in doing so, introduce a product directly on languages that parallels formula composition. This framework makes an essential use of languages of higher-dimensional words, called hyperwords, of arbitrary dimensions. It is shown here that the product thus introduced is associative over classes of languages closed under the product itself. this translates back to extra freedom in the way formulas and circuits can be decomposed.
Andreas Krebs;A Language-Theoretical Approach to Descriptive Complexity.;Michaël Cadilhac, Klaus-Jörn Lange;[<span itemprop="pagination">64-76</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_6;Logical formulas are naturally decomposed into their subformulas and circuits into their layers. How are these decompositions expressed in a purely language-theoretical setting? We address that question, and in doing so, introduce a product directly on languages that parallels formula composition. This framework makes an essential use of languages of higher-dimensional words, called hyperwords, of arbitrary dimensions. It is shown here that the product thus introduced is associative over classes of languages closed under the product itself. this translates back to extra freedom in the way formulas and circuits can be decomposed.
Klaus-Jörn Lange;A Language-Theoretical Approach to Descriptive Complexity.;Michaël Cadilhac, Andreas Krebs;[<span itemprop="pagination">64-76</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_6;Logical formulas are naturally decomposed into their subformulas and circuits into their layers. How are these decompositions expressed in a purely language-theoretical setting? We address that question, and in doing so, introduce a product directly on languages that parallels formula composition. This framework makes an essential use of languages of higher-dimensional words, called hyperwords, of arbitrary dimensions. It is shown here that the product thus introduced is associative over classes of languages closed under the product itself. this translates back to extra freedom in the way formulas and circuits can be decomposed.
Julien Cassaigne;k-Abelian Equivalence and Rationality.;Juhani Karhumäki, Svetlana Puzynina, Markus A. Whiteland;[<span itemprop="pagination">77-88</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_7;Two words u and v are said to be k-abelian equivalent if, for each word x of length at most k, the number of occurrences of x as a factor of u is the same as for v. We study some combinatorial properties of k-abelian equivalence classes. Our starting point is a characterization of k-abelian equivalence by rewriting, so-called k-switching. We show that the set of lexicographically least representatives of equivalence classes is a regular language. From this we infer that the sequence of the numbers of equivalence classes is \(\mathbb {N}\)-rational. We also show that the set of words defining k-abelian singleton classes is regular.
Juhani Karhumäki;k-Abelian Equivalence and Rationality.;Julien Cassaigne, Svetlana Puzynina, Markus A. Whiteland;[<span itemprop="pagination">77-88</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_7;Two words u and v are said to be k-abelian equivalent if, for each word x of length at most k, the number of occurrences of x as a factor of u is the same as for v. We study some combinatorial properties of k-abelian equivalence classes. Our starting point is a characterization of k-abelian equivalence by rewriting, so-called k-switching. We show that the set of lexicographically least representatives of equivalence classes is a regular language. From this we infer that the sequence of the numbers of equivalence classes is \(\mathbb {N}\)-rational. We also show that the set of words defining k-abelian singleton classes is regular.
Svetlana Puzynina;k-Abelian Equivalence and Rationality.;Julien Cassaigne, Juhani Karhumäki, Markus A. Whiteland;[<span itemprop="pagination">77-88</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_7;Two words u and v are said to be k-abelian equivalent if, for each word x of length at most k, the number of occurrences of x as a factor of u is the same as for v. We study some combinatorial properties of k-abelian equivalence classes. Our starting point is a characterization of k-abelian equivalence by rewriting, so-called k-switching. We show that the set of lexicographically least representatives of equivalence classes is a regular language. From this we infer that the sequence of the numbers of equivalence classes is \(\mathbb {N}\)-rational. We also show that the set of words defining k-abelian singleton classes is regular.
Markus A. Whiteland;k-Abelian Equivalence and Rationality.;Julien Cassaigne, Juhani Karhumäki, Svetlana Puzynina;[<span itemprop="pagination">77-88</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_7;Two words u and v are said to be k-abelian equivalent if, for each word x of length at most k, the number of occurrences of x as a factor of u is the same as for v. We study some combinatorial properties of k-abelian equivalence classes. Our starting point is a characterization of k-abelian equivalence by rewriting, so-called k-switching. We show that the set of lexicographically least representatives of equivalence classes is a regular language. From this we infer that the sequence of the numbers of equivalence classes is \(\mathbb {N}\)-rational. We also show that the set of words defining k-abelian singleton classes is regular.
Liang-Ting Chen;Schützenberger Products in a Category.;Henning Urbat;[<span itemprop="pagination">89-101</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_8;The Schützenberger product of monoids is a key tool for the algebraic treatment of language concatenation. In this paper we generalize the Schützenberger product to the level of monoids in an algebraic category \(\mathscr {D}\), leading to a uniform view of the corresponding constructions for monoids (Schützenberger), ordered monoids (Pin), idempotent semirings (Klíma and Polák), and algebras over a field (Reutenauer). In addition, assuming that \(\mathscr {D}\) is part of a Stone-type duality, we derive a characterization of the languages recognized by Schützenberger products.
Henning Urbat;Schützenberger Products in a Category.;Liang-Ting Chen;[<span itemprop="pagination">89-101</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_8;The Schützenberger product of monoids is a key tool for the algebraic treatment of language concatenation. In this paper we generalize the Schützenberger product to the level of monoids in an algebraic category \(\mathscr {D}\), leading to a uniform view of the corresponding constructions for monoids (Schützenberger), ordered monoids (Pin), idempotent semirings (Klíma and Polák), and algebras over a field (Reutenauer). In addition, assuming that \(\mathscr {D}\) is part of a Stone-type duality, we derive a characterization of the languages recognized by Schützenberger products.
Da-Jung Cho;Outfix-Guided Insertion - (Extended Abstract).;Yo-Sub Han, Timothy Ng, Kai Salomaa;[<span itemprop="pagination">102-113</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_9;Motivated by work on bio-operations on DNA strings, we consider an outfix-guided insertion operation that can be viewed as a generalization of the overlap assembly operation on strings studied previously. As the main result we construct a finite language L such that the outfix-guided insertion closure of L is nonregular. We consider also the closure properties of regular and (deterministic) context-free languages under the outfix-guided insertion operation and decision problems related to outfix-guided insertion. Deciding whether a language recognized by a deterministic finite automaton is closed under outfix-guided insertion can be done in polynomial time.
Yo-Sub Han;Outfix-Guided Insertion - (Extended Abstract).;Da-Jung Cho, Timothy Ng, Kai Salomaa;[<span itemprop="pagination">102-113</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_9;Motivated by work on bio-operations on DNA strings, we consider an outfix-guided insertion operation that can be viewed as a generalization of the overlap assembly operation on strings studied previously. As the main result we construct a finite language L such that the outfix-guided insertion closure of L is nonregular. We consider also the closure properties of regular and (deterministic) context-free languages under the outfix-guided insertion operation and decision problems related to outfix-guided insertion. Deciding whether a language recognized by a deterministic finite automaton is closed under outfix-guided insertion can be done in polynomial time.
Timothy Ng;Outfix-Guided Insertion - (Extended Abstract).;Da-Jung Cho, Yo-Sub Han, Kai Salomaa;[<span itemprop="pagination">102-113</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_9;Motivated by work on bio-operations on DNA strings, we consider an outfix-guided insertion operation that can be viewed as a generalization of the overlap assembly operation on strings studied previously. As the main result we construct a finite language L such that the outfix-guided insertion closure of L is nonregular. We consider also the closure properties of regular and (deterministic) context-free languages under the outfix-guided insertion operation and decision problems related to outfix-guided insertion. Deciding whether a language recognized by a deterministic finite automaton is closed under outfix-guided insertion can be done in polynomial time.
Kai Salomaa;Outfix-Guided Insertion - (Extended Abstract).;Da-Jung Cho, Yo-Sub Han, Timothy Ng;[<span itemprop="pagination">102-113</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_9;Motivated by work on bio-operations on DNA strings, we consider an outfix-guided insertion operation that can be viewed as a generalization of the overlap assembly operation on strings studied previously. As the main result we construct a finite language L such that the outfix-guided insertion closure of L is nonregular. We consider also the closure properties of regular and (deterministic) context-free languages under the outfix-guided insertion operation and decision problems related to outfix-guided insertion. Deciding whether a language recognized by a deterministic finite automaton is closed under outfix-guided insertion can be done in polynomial time.
Christian Choffrut;Both Ways Rational Functions.;Bruno Guillon;[<span itemprop="pagination">114-124</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_10;We consider binary relations on words which can be recognized by finite two-tape devices in two different ways: the traditional way where the two tapes are scanned in the same direction and a new one where they are scanned in different directions. The devices of the former type define the family of rational relations, while those of the latter define an a priori really different family. We characterize the partial functions that are in the intersection of the two families. We state a conjecture for the intersection for general, nonfunctional, relations.
Bruno Guillon;Both Ways Rational Functions.;Christian Choffrut;[<span itemprop="pagination">114-124</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_10;We consider binary relations on words which can be recognized by finite two-tape devices in two different ways: the traditional way where the two tapes are scanned in the same direction and a new one where they are scanned in different directions. The devices of the former type define the family of rational relations, while those of the latter define an a priori really different family. We characterize the partial functions that are in the intersection of the two families. We state a conjecture for the intersection for general, nonfunctional, relations.
Luc Dartois;Aperiodic String Transducers.;Ismaël Jecker, Pierre-Alain Reynier;[<span itemprop="pagination">125-137</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_11;Regular string-to-string functions enjoy a nice triple characterization through deterministic two-way transducers (\(\mathrm {2DFT}\)), streaming string transducers (\(\mathrm {SST}\)) and \(\mathrm {MSO}\) definable functions. This result has recently been lifted to \(\mathrm {FO}\) definable functions, with equivalent representations by means of aperiodic \(\mathrm {2DFT}\) and aperiodic 1-bounded \(\mathrm {SST}\), extending a well-known result on regular languages. In this paper, we give three direct transformations: (i) from 1-bounded \(\mathrm {SST}\) to \(\mathrm {2DFT}\), (ii) from \(\mathrm {2DFT}\) to copyless \(\mathrm {SST}\), and (iii) from k-bounded to 1-bounded \(\mathrm {SST}\). We give the complexity of each construction and also prove that they preserve the aperiodicity of transducers. As corollaries, we obtain that \(\mathrm {FO}\) definable string-to-string functions are equivalent to \(\mathrm {SST}\) whose transition monoid is finite and aperiodic, and to aperiodic copyless \(\mathrm {SST}\).
Ismaël Jecker;Aperiodic String Transducers.;Luc Dartois, Pierre-Alain Reynier;[<span itemprop="pagination">125-137</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_11;Regular string-to-string functions enjoy a nice triple characterization through deterministic two-way transducers (\(\mathrm {2DFT}\)), streaming string transducers (\(\mathrm {SST}\)) and \(\mathrm {MSO}\) definable functions. This result has recently been lifted to \(\mathrm {FO}\) definable functions, with equivalent representations by means of aperiodic \(\mathrm {2DFT}\) and aperiodic 1-bounded \(\mathrm {SST}\), extending a well-known result on regular languages. In this paper, we give three direct transformations: (i) from 1-bounded \(\mathrm {SST}\) to \(\mathrm {2DFT}\), (ii) from \(\mathrm {2DFT}\) to copyless \(\mathrm {SST}\), and (iii) from k-bounded to 1-bounded \(\mathrm {SST}\). We give the complexity of each construction and also prove that they preserve the aperiodicity of transducers. As corollaries, we obtain that \(\mathrm {FO}\) definable string-to-string functions are equivalent to \(\mathrm {SST}\) whose transition monoid is finite and aperiodic, and to aperiodic copyless \(\mathrm {SST}\).
Pierre-Alain Reynier;Aperiodic String Transducers.;Luc Dartois, Ismaël Jecker;[<span itemprop="pagination">125-137</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_11;Regular string-to-string functions enjoy a nice triple characterization through deterministic two-way transducers (\(\mathrm {2DFT}\)), streaming string transducers (\(\mathrm {SST}\)) and \(\mathrm {MSO}\) definable functions. This result has recently been lifted to \(\mathrm {FO}\) definable functions, with equivalent representations by means of aperiodic \(\mathrm {2DFT}\) and aperiodic 1-bounded \(\mathrm {SST}\), extending a well-known result on regular languages. In this paper, we give three direct transformations: (i) from 1-bounded \(\mathrm {SST}\) to \(\mathrm {2DFT}\), (ii) from \(\mathrm {2DFT}\) to copyless \(\mathrm {SST}\), and (iii) from k-bounded to 1-bounded \(\mathrm {SST}\). We give the complexity of each construction and also prove that they preserve the aperiodicity of transducers. As corollaries, we obtain that \(\mathrm {FO}\) definable string-to-string functions are equivalent to \(\mathrm {SST}\) whose transition monoid is finite and aperiodic, and to aperiodic copyless \(\mathrm {SST}\).
Tobias Denkinger;An Automata Characterisation for Multiple Context-Free Languages.;;[<span itemprop="pagination">138-150</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_12;We introduce tree stack automata as a new class of automata with storage and identify a restricted form of tree stack automata that recognises exactly the multiple context-free languages.
Stefan Dück;Weighted Automata and Logics on Infinite Graphs.;;[<span itemprop="pagination">151-163</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_13;We show a Büchi-like connection between graph automata and logics for infinite graphs. Using valuation monoids, a very general weight structure able to model computations like average or discounting, we extend this result to the quantitative setting. This gives us the first general results connecting automata and logics over infinite graphs in the qualitative and the quantitative setting.
Jörg Endrullis;Degrees of Infinite Words, Polynomials and Atoms.;Juhani Karhumäki, Jan Willem Klop, Aleksi Saarela;[<span itemprop="pagination">164-176</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_14;Our objects of study are finite state transducers and their power for transforming infinite words. Infinite sequences of symbols are of paramount importance in a wide range of fields, from formal languages to pure mathematics and physics. While finite automata for recognising and transforming languages are well-understood, very little is known about the power of automata to transform infinite words.
Juhani Karhumäki;Degrees of Infinite Words, Polynomials and Atoms.;Jörg Endrullis, Jan Willem Klop, Aleksi Saarela;[<span itemprop="pagination">164-176</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_14;Our objects of study are finite state transducers and their power for transforming infinite words. Infinite sequences of symbols are of paramount importance in a wide range of fields, from formal languages to pure mathematics and physics. While finite automata for recognising and transforming languages are well-understood, very little is known about the power of automata to transform infinite words.
Jan Willem Klop;Degrees of Infinite Words, Polynomials and Atoms.;Jörg Endrullis, Juhani Karhumäki, Aleksi Saarela;[<span itemprop="pagination">164-176</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_14;Our objects of study are finite state transducers and their power for transforming infinite words. Infinite sequences of symbols are of paramount importance in a wide range of fields, from formal languages to pure mathematics and physics. While finite automata for recognising and transforming languages are well-understood, very little is known about the power of automata to transform infinite words.
Aleksi Saarela;Degrees of Infinite Words, Polynomials and Atoms.;Jörg Endrullis, Juhani Karhumäki, Jan Willem Klop;[<span itemprop="pagination">164-176</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_14;Our objects of study are finite state transducers and their power for transforming infinite words. Infinite sequences of symbols are of paramount importance in a wide range of fields, from formal languages to pure mathematics and physics. While finite automata for recognising and transforming languages are well-understood, very little is known about the power of automata to transform infinite words.
Daniil Gasnikov;Ternary Square-Free Partial Words with Many Wildcards.;Arseny M. Shur;[<span itemprop="pagination">177-189</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_15;We contribute to the study of square-free words. The classical notion of a square-free word has a natural generalization to partial words, studied in several papers since 2008. We prove that the maximal density of wildcards in the ternary infinite square-free partial word is surprisingly big: 3/16. In addition, we introduce a related characteristic of infinite square-free words, called flexibility, and find its values for some interesting words and classes of words.
Arseny M. Shur;Ternary Square-Free Partial Words with Many Wildcards.;Daniil Gasnikov;[<span itemprop="pagination">177-189</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_15;We contribute to the study of square-free words. The classical notion of a square-free word has a natural generalization to partial words, studied in several papers since 2008. We prove that the maximal density of wildcards in the ternary infinite square-free partial word is surprisingly big: 3/16. In addition, we introduce a related characteristic of infinite square-free words, called flexibility, and find its values for some interesting words and classes of words.
Viliam Geffert;Alternating Demon Space Is Closed Under Complement and Other Simulations for Sublogarithmic Space.;;[<span itemprop="pagination">190-202</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_16;We present new simulations for \(\text {ASpace}^{\mathrm {dm}}(s(n))\), the class of languages that can be accepted by alternating Turing machines starting with s(n) worktape cells delimited initially. Under weak constructibility assumptions, not excluding monotone functions below \(\log n\), we show: (i) \(\text {ASpace}^{\mathrm {dm}}(s(n))\subseteq \text {DTime}(n\!\cdot \!2^{O(s(n))})\). This extends, to sublogarithmic space, the classical simulation of alternating space by deterministic time. (ii) \(\text {ASpace}^{\mathrm {dm}}(s(n))\subseteq \text {NTimeSpace}(n\!\cdot \!2^{O(s(n))},2^{O(s(n))})\), a simulation with simultaneous bounds on time and space. This improves the known inclusion, stating that \(\text {ASpace}^{\mathrm {dm}}(s(n))\subseteq \text {NSpace}(2^{O(s(n))})\). (iii) \(\text {ASpace}^{\mathrm {dm}}(s(n))=\text {co-}\text {ASpace}^{\mathrm {dm}}(s(n)))\), i.e., the alternating space is closed under complement. This simulation does not depend on whether s(n) is above \(\log n\) nor on whether the original machine gets into infinite loops, which solves a long-standing open problem.
Luisa Herrmann;Weighted Symbolic Automata with Data Storage.;Heiko Vogler;[<span itemprop="pagination">203-215</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_17;We introduce weighted symbolic automata with data storage, which combine and generalize the concepts of automata with storage types, weighted automata, and symbolic automata. By defining two particular data storages, we show that this combination is rich enough to capture symbolic visibly pushdown automata and weighted timed automata. We introduce a weighted MSO-logic and prove a Büchi-Elgot-Trakhtenbrot theorem, i.e., the new logic and the new automaton model are expressively equivalent.
Heiko Vogler;Weighted Symbolic Automata with Data Storage.;Luisa Herrmann;[<span itemprop="pagination">203-215</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_17;We introduce weighted symbolic automata with data storage, which combine and generalize the concepts of automata with storage types, weighted automata, and symbolic automata. By defining two particular data storages, we show that this combination is rich enough to capture symbolic visibly pushdown automata and weighted timed automata. We introduce a weighted MSO-logic and prove a Büchi-Elgot-Trakhtenbrot theorem, i.e., the new logic and the new automaton model are expressively equivalent.
Oscar H. Ibarra;On Families of Full Trios Containing Counter Machine Languages.;Ian McQuillan;[<span itemprop="pagination">216-228</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_18;We look at NFAs augmented with multiple reversal-bounded counters where, during an accepting computation, the behavior of the counters during increasing and decreasing phases is specified by some fixed “pattern”. We consider families of languages defined by various pattern behaviors and show that some correspond to the smallest full trios containing restricted classes of bounded semilinear languages. For example, one such family is exactly the smallest full trio containing all the bounded semilinear languages. Another family is the smallest full trio containing all the bounded context-free languages. Still another is the smallest full trio containing all bounded languages whose Parikh map is a semilinear set where all periodic vectors have at most two non-zero coordinates. We also examine relationships between the families.
Ian McQuillan;On Families of Full Trios Containing Counter Machine Languages.;Oscar H. Ibarra;[<span itemprop="pagination">216-228</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_18;We look at NFAs augmented with multiple reversal-bounded counters where, during an accepting computation, the behavior of the counters during increasing and decreasing phases is specified by some fixed “pattern”. We consider families of languages defined by various pattern behaviors and show that some correspond to the smallest full trios containing restricted classes of bounded semilinear languages. For example, one such family is exactly the smallest full trio containing all the bounded semilinear languages. Another family is the smallest full trio containing all the bounded context-free languages. Still another is the smallest full trio containing all bounded languages whose Parikh map is a semilinear set where all periodic vectors have at most two non-zero coordinates. We also examine relationships between the families.
Jozef Jirásek Jr.;Non-regular Maximal Prefix-Free Subsets of Regular Languages.;;[<span itemprop="pagination">229-242</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_19;We investigate non-regular maximal prefix-free subsets (MPFS) of regular languages. We give a method to decide whether or not a regular language has any non-regular MPFS.
Jozef Jirásek Jr.;Operations on Unambiguous Finite Automata.;Galina Jirásková, Juraj Sebej;[<span itemprop="pagination">243-255</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_20;A nondeterministic finite automaton is unambiguous if it has at most one accepting computation on every input string. We investigate the complexity of basic regular operations on languages represented by unambiguous finite automata. We get tight upper bounds for intersection (mn), left and right quotients (\(2^n-1\)), positive closure (\({3\over 4}\cdot 2^n-1\)), star (\({3\over 4}\cdot 2^n\)), shuffle (\(2^{mn}-1\)), and concatenation (\({3\over 4}\cdot 2^{m+n}-1\)). To prove tightness, we use a binary alphabet for intersection and left and right quotients, a ternary alphabet for star and positive closure, a five-letter alphabet for shuffle, and a seven-letter alphabet for concatenation. We also get some partial results for union and complementation.
Galina Jirásková;Operations on Unambiguous Finite Automata.;Jozef Jirásek Jr., Juraj Sebej;[<span itemprop="pagination">243-255</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_20;A nondeterministic finite automaton is unambiguous if it has at most one accepting computation on every input string. We investigate the complexity of basic regular operations on languages represented by unambiguous finite automata. We get tight upper bounds for intersection (mn), left and right quotients (\(2^n-1\)), positive closure (\({3\over 4}\cdot 2^n-1\)), star (\({3\over 4}\cdot 2^n\)), shuffle (\(2^{mn}-1\)), and concatenation (\({3\over 4}\cdot 2^{m+n}-1\)). To prove tightness, we use a binary alphabet for intersection and left and right quotients, a ternary alphabet for star and positive closure, a five-letter alphabet for shuffle, and a seven-letter alphabet for concatenation. We also get some partial results for union and complementation.
Juraj Sebej;Operations on Unambiguous Finite Automata.;Jozef Jirásek Jr., Galina Jirásková;[<span itemprop="pagination">243-255</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_20;A nondeterministic finite automaton is unambiguous if it has at most one accepting computation on every input string. We investigate the complexity of basic regular operations on languages represented by unambiguous finite automata. We get tight upper bounds for intersection (mn), left and right quotients (\(2^n-1\)), positive closure (\({3\over 4}\cdot 2^n-1\)), star (\({3\over 4}\cdot 2^n\)), shuffle (\(2^{mn}-1\)), and concatenation (\({3\over 4}\cdot 2^{m+n}-1\)). To prove tightness, we use a binary alphabet for intersection and left and right quotients, a ternary alphabet for star and positive closure, a five-letter alphabet for shuffle, and a seven-letter alphabet for concatenation. We also get some partial results for union and complementation.
Dietrich Kuske;The Trace Monoids in the Queue Monoid and in the Direct Product of Two Free Monoids.;Olena Prianychnykova;[<span itemprop="pagination">256-267</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_21;We prove that a trace monoid embeds into the queue monoid if and only if it embeds into the direct product of two free monoids. We also give a decidable characterization of these trace monoids.
Olena Prianychnykova;The Trace Monoids in the Queue Monoid and in the Direct Product of Two Free Monoids.;Dietrich Kuske;[<span itemprop="pagination">256-267</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_21;We prove that a trace monoid embeds into the queue monoid if and only if it embeds into the direct product of two free monoids. We also give a decidable characterization of these trace monoids.
Kent Kwee;On Ordered RRWW-Automata.;Friedrich Otto;[<span itemprop="pagination">268-279</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_22;It is known that the deterministic ordered restarting automaton accepts exactly the regular languages, while its nondeterministic variant accepts some languages that are not even growing context-sensitive. Here we study an extension of the ordered restarting automaton, the so-called ORRWW-automaton, which is obtained from the previous model by separating the restart operation from the rewrite operation. First we show that the deterministic ORRWW-automaton still characterizes just the regular languages. Then we prove that this also holds for the stateless variant of the nondeterministic ORRWW-automaton, which is obtained by splitting the transition relation into two parts, where the first part is used until a rewrite operation is performed, and the second part is used thereafter. Finally, we show that the nondeterministic ORRWW-automaton is even more expressive than the nondeterministic ordered restarting automaton.
Friedrich Otto;On Ordered RRWW-Automata.;Kent Kwee;[<span itemprop="pagination">268-279</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_22;It is known that the deterministic ordered restarting automaton accepts exactly the regular languages, while its nondeterministic variant accepts some languages that are not even growing context-sensitive. Here we study an extension of the ordered restarting automaton, the so-called ORRWW-automaton, which is obtained from the previous model by separating the restart operation from the rewrite operation. First we show that the deterministic ORRWW-automaton still characterizes just the regular languages. Then we prove that this also holds for the stateless variant of the nondeterministic ORRWW-automaton, which is obtained by splitting the transition relation into two parts, where the first part is used until a rewrite operation is performed, and the second part is used thereafter. Finally, we show that the nondeterministic ORRWW-automaton is even more expressive than the nondeterministic ordered restarting automaton.
Sébastien Labbé;Bispecial Factors in the Brun S-Adic System.;Julien Leroy;[<span itemprop="pagination">280-292</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_23;We study the bispecial factors in the S-adic system associated with the Brun Multidimensional Continued Fraction algorithm. More precisely, by describing how strong and weak bispecial words can appear, we get a sub-language of the Brun language for which all bispecial words are neutral.
Julien Leroy;Bispecial Factors in the Brun S-Adic System.;Sébastien Labbé;[<span itemprop="pagination">280-292</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_23;We study the bispecial factors in the S-adic system associated with the Brun Multidimensional Continued Fraction algorithm. More precisely, by describing how strong and weak bispecial words can appear, we get a sub-language of the Brun language for which all bispecial words are neutral.
Andreas Maletti;Compositions of Tree-to-Tree Statistical Machine Translation Models.;;[<span itemprop="pagination">293-305</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_24;Compositions of well-known tree-to-tree translation models used in statistical machine translation are investigated. Synchronous context-free grammars are closed under composition in both the unweighted as well as the weighted case. In addition, it is demonstrated that there is a close connection between compositions of synchronous tree-substitution grammars and compositions of certain tree transducers because the intermediate trees can encode finite-state information. Utilizing these close ties, the composition closure of synchronous tree-substitution grammars is identified in the unweighted and weighted case. In particular, in the weighted case, these results build on a novel lifting strategy that will prove useful also in other setups.
Florin Manea;On the Solvability Problem for Restricted Classes of Word Equations.;Dirk Nowotka, Markus L. Schmid;[<span itemprop="pagination">306-318</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_25;We investigate the complexity of the solvability problem for restricted classes of word equations with and without regular constraints. For general word equations, the solvability problem remains \({{\mathrm{\mathsf {NP}}}}\)-hard, even if the variables on both sides are ordered, and for word equations with regular constraints, the solvability problems remains \({{\mathrm{\mathsf {NP}}}}\)-hard for variable disjoint (i. e., the two sides share no variables) equations with two variables, only one of which is repeated. On the other hand, word equations with only one repeated variable (but an arbitrary number of variables) and at least one non-repeated variable on each side, can be solved in polynomial-time.
Dirk Nowotka;On the Solvability Problem for Restricted Classes of Word Equations.;Florin Manea, Markus L. Schmid;[<span itemprop="pagination">306-318</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_25;We investigate the complexity of the solvability problem for restricted classes of word equations with and without regular constraints. For general word equations, the solvability problem remains \({{\mathrm{\mathsf {NP}}}}\)-hard, even if the variables on both sides are ordered, and for word equations with regular constraints, the solvability problems remains \({{\mathrm{\mathsf {NP}}}}\)-hard for variable disjoint (i. e., the two sides share no variables) equations with two variables, only one of which is repeated. On the other hand, word equations with only one repeated variable (but an arbitrary number of variables) and at least one non-repeated variable on each side, can be solved in polynomial-time.
Markus L. Schmid;On the Solvability Problem for Restricted Classes of Word Equations.;Florin Manea, Dirk Nowotka;[<span itemprop="pagination">306-318</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_25;We investigate the complexity of the solvability problem for restricted classes of word equations with and without regular constraints. For general word equations, the solvability problem remains \({{\mathrm{\mathsf {NP}}}}\)-hard, even if the variables on both sides are ordered, and for word equations with regular constraints, the solvability problems remains \({{\mathrm{\mathsf {NP}}}}\)-hard for variable disjoint (i. e., the two sides share no variables) equations with two variables, only one of which is repeated. On the other hand, word equations with only one repeated variable (but an arbitrary number of variables) and at least one non-repeated variable on each side, can be solved in polynomial-time.
Henryk Michalewski;Unambiguous Büchi Is Weak.;Michal Skrzypczak;[<span itemprop="pagination">319-331</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_26;A non-deterministic automaton on infinite trees is unambiguous if it has at most one accepting run on every tree. For a given unambiguous parity automaton \(\mathcal {A} \) of index (i, 2j) we construct an alternating automaton \(\textsc {Transformation}(\mathcal {A})\) which accepts the same language, but is simpler in terms of alternating hierarchy of automata. If \(\mathcal {A} \) is a Büchi automaton (\(i=0, j=1\)), then \(\textsc {Transformation}(\mathcal {A})\) is a weak alternating automaton. In general, \(\textsc {Transformation}(\mathcal {A})\) belongs to the class \(\mathrm {Comp}({i}+1,2{j})\), in particular it is simultaneously of alternating index (i, 2j) and of the dual index \((i+1,2j+1)\). The main theorem of this paper is a correctness proof of the algorithm \(\textsc {Transformation}\). The transformation algorithm is based on a separation algorithm of Arnold and Santocanale (2005) and extends results of Finkel and Simonnet (2009).
Michal Skrzypczak;Unambiguous Büchi Is Weak.;Henryk Michalewski;[<span itemprop="pagination">319-331</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_26;A non-deterministic automaton on infinite trees is unambiguous if it has at most one accepting run on every tree. For a given unambiguous parity automaton \(\mathcal {A} \) of index (i, 2j) we construct an alternating automaton \(\textsc {Transformation}(\mathcal {A})\) which accepts the same language, but is simpler in terms of alternating hierarchy of automata. If \(\mathcal {A} \) is a Büchi automaton (\(i=0, j=1\)), then \(\textsc {Transformation}(\mathcal {A})\) is a weak alternating automaton. In general, \(\textsc {Transformation}(\mathcal {A})\) belongs to the class \(\mathrm {Comp}({i}+1,2{j})\), in particular it is simultaneously of alternating index (i, 2j) and of the dual index \((i+1,2j+1)\). The main theorem of this paper is a correctness proof of the algorithm \(\textsc {Transformation}\). The transformation algorithm is based on a separation algorithm of Arnold and Santocanale (2005) and extends results of Finkel and Simonnet (2009).
Dirk Nowotka;One-Unknown Word Equations and Three-Unknown Constant-Free Word Equations.;Aleksi Saarela;[<span itemprop="pagination">332-343</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_27;We prove connections between one-unknown word equations and three-unknown constant-free word equations, and use them to prove that the number of equations in an independent system of three-unknown constant-free equations is at most logarithmic with respect to the length of the shortest equation in the system. We also study two well-known conjectures. The first conjecture claims that there is a constant c such that every one-unknown equation has either infinitely many solutions or at most c. The second conjecture claims that there is a constant c such that every independent system of three-unknown constant-free equations with a nonperiodic solution is of size at most c. We prove that the first conjecture implies the second one, possibly for a different constant.
Aleksi Saarela;One-Unknown Word Equations and Three-Unknown Constant-Free Word Equations.;Dirk Nowotka;[<span itemprop="pagination">332-343</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_27;We prove connections between one-unknown word equations and three-unknown constant-free word equations, and use them to prove that the number of equations in an independent system of three-unknown constant-free equations is at most logarithmic with respect to the length of the shortest equation in the system. We also study two well-known conjectures. The first conjecture claims that there is a constant c such that every one-unknown equation has either infinitely many solutions or at most c. The second conjecture claims that there is a constant c such that every independent system of three-unknown constant-free equations with a nonperiodic solution is of size at most c. We prove that the first conjecture implies the second one, possibly for a different constant.
Pascal Ochem;Avoidability of Formulas with Two Variables.;Matthieu Rosenfeld;[<span itemprop="pagination">344-354</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_28;In combinatorics on words, a word w over an alphabet \(\varSigma \) is said to avoid a pattern p over an alphabet \(\varDelta \) of variables if there is no factor f of w such that \(f=h(p)\) where \(h\,{:}\,\varDelta ^*\rightarrow \varSigma ^*\) is a non-erasing morphism. A pattern p is said to be k-avoidable if there exists an infinite word over a k-letter alphabet that avoids p. We consider the patterns such that at most two variables appear at least twice, or equivalently, the formulas with at most two variables. For each such formula, we determine whether it is 2-avoidable.
Matthieu Rosenfeld;Avoidability of Formulas with Two Variables.;Pascal Ochem;[<span itemprop="pagination">344-354</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_28;In combinatorics on words, a word w over an alphabet \(\varSigma \) is said to avoid a pattern p over an alphabet \(\varDelta \) of variables if there is no factor f of w such that \(f=h(p)\) where \(h\,{:}\,\varDelta ^*\rightarrow \varSigma ^*\) is a non-erasing morphism. A pattern p is said to be k-avoidable if there exists an infinite word over a k-letter alphabet that avoids p. We consider the patterns such that at most two variables appear at least twice, or equivalently, the formulas with at most two variables. For each such formula, we determine whether it is 2-avoidable.
Adrien Boiret;Deciding Equivalence of Linear Tree-to-Word Transducers in Polynomial Time.;Raphaela Palenta;[<span itemprop="pagination">355-367</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_29;We show that the equivalence of linear top-down tree-to-word transducers is decidable in polynomial time. Linear tree-to-word transducers are non-copying but not necessarily order-preserving and can be used to express XML and other document transformations. The result is based on a partial normal form that provides a basic characterization of the languages produced by linear tree-to-word transducers.
Raphaela Palenta;Deciding Equivalence of Linear Tree-to-Word Transducers in Polynomial Time.;Adrien Boiret;[<span itemprop="pagination">355-367</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_29;We show that the equivalence of linear top-down tree-to-word transducers is decidable in polynomial time. Linear tree-to-word transducers are non-copying but not necessarily order-preserving and can be used to express XML and other document transformations. The result is based on a partial normal form that provides a basic characterization of the languages produced by linear tree-to-word transducers.
Erik Paul;On Finite and Polynomial Ambiguity of Weighted Tree Automata.;;[<span itemprop="pagination">368-379</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_30;We consider finite and polynomial ambiguity of weighted tree automata. Concerning finite ambiguity, we show that a finitely ambiguous weighted tree automaton can be decomposed into a sum of unambiguous automata. For polynomial ambiguity, we show how to decompose a polynomially ambiguous weighted tree automaton into simpler polynomially ambiguous automata and then analyze the structure of these simpler automata. We also outline how these results can be used to capture the ambiguity of weighted tree automata with weighted logics.
Marek Szykula;An Extremal Series of Eulerian Synchronizing Automata.;Vojtech Vorel;[<span itemprop="pagination">380-392</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_31;We present an infinite series of n-state Eulerian automata whose reset words have length at least \((n^2-3)/2\). This improves the current lower bound on the length of shortest reset words in Eulerian automata. We conjecture that \((n^2-3)/2\) also forms an upper bound for this class and we experimentally verify it for small automata by an exhaustive computation.
Vojtech Vorel;An Extremal Series of Eulerian Synchronizing Automata.;Marek Szykula;[<span itemprop="pagination">380-392</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_31;We present an infinite series of n-state Eulerian automata whose reset words have length at least \((n^2-3)/2\). This improves the current lower bound on the length of shortest reset words in Eulerian automata. We conjecture that \((n^2-3)/2\) also forms an upper bound for this class and we experimentally verify it for small automata by an exhaustive computation.
Yuya Uezato;Monoid-Based Approach to the Inclusion Problem on Superdeterministic Pushdown Automata.;Yasuhiko Minamide;[<span itemprop="pagination">393-405</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_32;We present a new and simple decidability proof for the language inclusion problem between context-free languages and languages accepted by superdeterministic pushdown automata (Sdpdas). The language class of Sdpdas is one of the largest language classes \(\mathcal {C}\) for which the inclusion \(L_{\text {cfl}} \subseteq L_{\mathcal {C}}\) is decidable for an arbitrary context-free language \(L_{\text {cfl}}\) and arbitrary language \(L_{\mathcal {C}}\) in \(\mathcal {C}\). We introduce generalized pushdown automata and reformulate Sdpdas as a subclass of them. This reformulation naturally leads to a monoid that captures Sdpdas. The monoid is key to our simple decidability proof because we translate the inclusion problem on Sdpdas to the corresponding monoid inclusion problem. In addition to the decidability result, we present a new undecidability result regarding the inclusion problem on indexed languages.
Yasuhiko Minamide;Monoid-Based Approach to the Inclusion Problem on Superdeterministic Pushdown Automata.;Yuya Uezato;[<span itemprop="pagination">393-405</span>];[<meta content="2016" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-662-53132-7_32;We present a new and simple decidability proof for the language inclusion problem between context-free languages and languages accepted by superdeterministic pushdown automata (Sdpdas). The language class of Sdpdas is one of the largest language classes \(\mathcal {C}\) for which the inclusion \(L_{\text {cfl}} \subseteq L_{\mathcal {C}}\) is decidable for an arbitrary context-free language \(L_{\text {cfl}}\) and arbitrary language \(L_{\mathcal {C}}\) in \(\mathcal {C}\). We introduce generalized pushdown automata and reformulate Sdpdas as a subclass of them. This reformulation naturally leads to a monoid that captures Sdpdas. The monoid is key to our simple decidability proof because we translate the inclusion problem on Sdpdas to the corresponding monoid inclusion problem. In addition to the decidability result, we present a new undecidability result regarding the inclusion problem on indexed languages.
Volker Diekert;On First-Order Fragments for Words and Mazurkiewicz Traces.;Manfred Kufleitner;[<span itemprop="pagination">1-19</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_1;We summarize several characterizations, inclusions, and separations on fragments of first-order logic over words and Mazurkiewicz traces. The results concerning Mazurkiewicz traces can be seen as generalizations of those for words. It turns out that over traces it is crucial, how easy concurrency can be expressed. Since there is no concurrency in words, this distinction does not occur there. In general, the possibility of expressing concurrency also increases the complexity of the satisfiability problem.
Manfred Kufleitner;On First-Order Fragments for Words and Mazurkiewicz Traces.;Volker Diekert;[<span itemprop="pagination">1-19</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_1;We summarize several characterizations, inclusions, and separations on fragments of first-order logic over words and Mazurkiewicz traces. The results concerning Mazurkiewicz traces can be seen as generalizations of those for words. It turns out that over traces it is crucial, how easy concurrency can be expressed. Since there is no concurrency in words, this distinction does not occur there. In general, the possibility of expressing concurrency also increases the complexity of the satisfiability problem.
Thomas A. Henzinger;Quantitative Generalizations of Languages.;;[<span itemprop="pagination">20-22</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_2;In the traditional view, a language is a set of words, i.e., a function from words to boolean values. We call this view “qualitative,” because each word either belongs to or does not belong to a language. Let Σ be an alphabet, and let us consider infinite words over Σ. Formally, a qualitative language over Σ is a function A: \(\Sigma^\omega\rightarrow\mathbb{B}\). There are many applications of qualitative languages. For example, qualitative languages are used to specify the legal behaviors of systems, and zero-sum objectives of games played on graphs. In the former case, each behavior of a system is either legal or illegal. in the latter case, each outcome of a game is either winning or losing. For defining languages, it is convenient to use finite acceptors (or generators). In particular, qualitative languages are often defined using finite-state machines (so-called ω-automata) whose transitions are labeled by letters from Σ. For example, the states of an ω-automaton may represent states of a system, and the transition labels may represent atomic observables of a behavior. There is a rich and well-studied theory of finite-state acceptors of qualitative languages, namely, the theory of theω-regular languages.
Michal Kunc;What Do We Know About Language Equations?;;[<span itemprop="pagination">23-27</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_3;In the talk we give an overview of recent developments in the area of language equations, with an emphasis on methods for dealing with non-classical types of equations whose theory has not been successfully developed already in the previous decades, and on results forming the current borderline of our knowledge. This abstract is in particular meant to provide the interested listener with references to the material discussed in the talk.
Ming Li;Information Distance and Applications.;;[<span itemprop="pagination">28</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_4;We know how to measure distance from Turku to Toronto. However, do you know how to measure the distance between two information carrying entities? For example: two genomes, two music scores, two programs, two articles, two emails, two concepts, or from a question to an answer? Furthermore, such a distance measure must be application-independent, must be universal in the sense it is provably better than all other distances, and must be applicable.
Jacques Sakarovitch;Finite Automata and the Writing of Numbers.;;[<span itemprop="pagination">29-30</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_5;Numbers do exist, independently of the way we represent them, of the way we write them. And there are many ways to write them: integers as finite sequence of digits once a base is fixed, rational numbers as a pair of integer or as an ultimately periodic infinite sequence of digits, or reals as an infinite sequence of digits but also as a continued fraction, just to quote a few. Operations on numbers are defined, independently of the way they are computed. But when they are computed they amounts to be algorithms that work on the representations of numbers.
Kai Salomaa;Descriptional Complexity of Nondeterministic Finite Automata.;;[<span itemprop="pagination">31-35</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_6;In this talk, I will survey recent results and discuss open problems on the state and transition complexity of nondeterministic finite automata.
Marcella Anselmo;From Determinism to Non-determinism in Recognizable Two-Dimensional Languages.;Dora Giammarresi, Maria Madonia;[<span itemprop="pagination">36-47</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_7;Tiling systems that recognize two-dimensional languages are intrinsically non-deterministic models. We introduce the notion of deterministic tiling system that generalizes deterministic automata for strings. The corresponding family of languages matches all the requirements of a robust deterministic class. Furthermore we show that, differently from the one-dimensional case, there exist many classes between deterministic and non-deterministic families that we separate by means of examples and decidability properties.
Dora Giammarresi;From Determinism to Non-determinism in Recognizable Two-Dimensional Languages.;Marcella Anselmo, Maria Madonia;[<span itemprop="pagination">36-47</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_7;Tiling systems that recognize two-dimensional languages are intrinsically non-deterministic models. We introduce the notion of deterministic tiling system that generalizes deterministic automata for strings. The corresponding family of languages matches all the requirements of a robust deterministic class. Furthermore we show that, differently from the one-dimensional case, there exist many classes between deterministic and non-deterministic families that we separate by means of examples and decidability properties.
Maria Madonia;From Determinism to Non-determinism in Recognizable Two-Dimensional Languages.;Marcella Anselmo, Dora Giammarresi;[<span itemprop="pagination">36-47</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_7;Tiling systems that recognize two-dimensional languages are intrinsically non-deterministic models. We introduce the notion of deterministic tiling system that generalizes deterministic automata for strings. The corresponding family of languages matches all the requirements of a robust deterministic class. Furthermore we show that, differently from the one-dimensional case, there exist many classes between deterministic and non-deterministic families that we separate by means of examples and decidability properties.
Marie-Pierre Béal;Coding Partitions: Regularity, Maximality and Global Ambiguity.;Fabio Burderi, Antonio Restivo;[<span itemprop="pagination">48-59</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_8;The canonical coding partition of a set of words is the finest partition such that the words contained in at least two factorizations of a same sequence belong to a same class. In the case the set is not uniquely decipherable, it partitions the set into one unambiguous class and other parts that localize the ambiguities in the factorizations of finite sequences.
Fabio Burderi;Coding Partitions: Regularity, Maximality and Global Ambiguity.;Marie-Pierre Béal, Antonio Restivo;[<span itemprop="pagination">48-59</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_8;The canonical coding partition of a set of words is the finest partition such that the words contained in at least two factorizations of a same sequence belong to a same class. In the case the set is not uniquely decipherable, it partitions the set into one unambiguous class and other parts that localize the ambiguities in the factorizations of finite sequences.
Antonio Restivo;Coding Partitions: Regularity, Maximality and Global Ambiguity.;Marie-Pierre Béal, Fabio Burderi;[<span itemprop="pagination">48-59</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_8;The canonical coding partition of a set of words is the finest partition such that the words contained in at least two factorizations of a same sequence belong to a same class. In the case the set is not uniquely decipherable, it partitions the set into one unambiguous class and other parts that localize the ambiguities in the factorizations of finite sequences.
Aleksandrs Belovs;Multi-letter Reversible and Quantum Finite Automata.;Ansis Rosmanis, Juris Smotrovs;[<span itemprop="pagination">60-71</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_9;The regular language (a + b)*a (the words in alphabet {a, b} having a as the last letter) is at the moment a classical example of a language not recognizable by a one-way quantum finite automaton (QFA). Up to now, there have been introduced many different models of QFAs, with increasing capabilities, but none of them can cope with this language.
Ansis Rosmanis;Multi-letter Reversible and Quantum Finite Automata.;Aleksandrs Belovs, Juris Smotrovs;[<span itemprop="pagination">60-71</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_9;The regular language (a + b)*a (the words in alphabet {a, b} having a as the last letter) is at the moment a classical example of a language not recognizable by a one-way quantum finite automaton (QFA). Up to now, there have been introduced many different models of QFAs, with increasing capabilities, but none of them can cope with this language.
Juris Smotrovs;Multi-letter Reversible and Quantum Finite Automata.;Aleksandrs Belovs, Ansis Rosmanis;[<span itemprop="pagination">60-71</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_9;The regular language (a + b)*a (the words in alphabet {a, b} having a as the last letter) is at the moment a classical example of a language not recognizable by a one-way quantum finite automaton (QFA). Up to now, there have been introduced many different models of QFAs, with increasing capabilities, but none of them can cope with this language.
Alberto Bertoni;Approximability and Non-approximability Results in Computing the Mean Speedup of Trace Monoids.;Roberto Radicioni;[<span itemprop="pagination">72-83</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_10;The “mean speedup” of a trace monoid can be interpreted as an index of the “intrinsic parallelism”. We study the problem of computing the mean speedup under two conditions: (1) uniform distribution on the words of given length and (2) uniform distribution on the traces of given height. In the first case, we give an approximability result showing a probabilistic fully polynomial time approximation scheme, while, in the second case, we prove that the problem is NP-hard to approximate within n1 − ε for every ε&gt. 0, unless NP = coR.
Roberto Radicioni;Approximability and Non-approximability Results in Computing the Mean Speedup of Trace Monoids.;Alberto Bertoni;[<span itemprop="pagination">72-83</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_10;The “mean speedup” of a trace monoid can be interpreted as an index of the “intrinsic parallelism”. We study the problem of computing the mean speedup under two conditions: (1) uniform distribution on the words of given length and (2) uniform distribution on the traces of given height. In the first case, we give an approximability result showing a probabilistic fully polynomial time approximation scheme, while, in the second case, we prove that the problem is NP-hard to approximate within n1 − ε for every ε&gt. 0, unless NP = coR.
Laurent Bienvenu;The Dynamics of Cellular Automata in Shift-Invariant Topologies.;Mathieu Sablik;[<span itemprop="pagination">84-95</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_11;We study the dynamics of cellular automata, and more specifically their transitivity and expansivity, when the set of configurations is endowed with a shift-invariant (pseudo-)distance. We first give an original proof of the non-transitivity of cellular automata when the set of configurations is endowed with the Besicovitch pseudo-distance. We then show that the Besicovitch pseudo-distance induces a distance on the set of shift-invariant measures and on the whole space of measures, and we prove that in these spaces also, cellular automata cannot be expansive nor transitive.
Mathieu Sablik;The Dynamics of Cellular Automata in Shift-Invariant Topologies.;Laurent Bienvenu;[<span itemprop="pagination">84-95</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_11;We study the dynamics of cellular automata, and more specifically their transitivity and expansivity, when the set of configurations is endowed with a shift-invariant (pseudo-)distance. We first give an original proof of the non-transitivity of cellular automata when the set of configurations is endowed with the Besicovitch pseudo-distance. We then show that the Besicovitch pseudo-distance induces a distance on the set of shift-invariant measures and on the whole space of measures, and we prove that in these spaces also, cellular automata cannot be expansive nor transitive.
Francine Blanchet-Sadri;Two Element Unavoidable Sets of Partial Words.;N. C. Brownstein, Justin Palumbo;[<span itemprop="pagination">96-107</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_12;The notion of an unavoidable set of words appears frequently in the fields of mathematics and theoretical computer science, in particular with its connection to the study of combinatorics on words. The theory of unavoidable sets has seen extensive study over the past twenty years. In this paper we extend the definition of unavoidable sets of words to unavoidable sets of partial words. Partial words, or finite sequences that may contain a number of “do not know” symbols or holes, appear in natural ways in several areas of current interest such as molecular biology, data communication, DNA computing, etc. We demonstrate the utility of the notion of unavoidability on partial words by making use of it to identify several new classes of unavoidable sets of full words. Along the way we begin work on classifying the unavoidable sets of partial words of small cardinality. We pose a conjecture, and show that affirmative proof of this conjecture gives a sufficient condition for classifying all the unavoidable sets of partial words of size two. Lastly we give a result which makes the conjecture easy to verify for a significant number of cases.
N. C. Brownstein;Two Element Unavoidable Sets of Partial Words.;Francine Blanchet-Sadri, Justin Palumbo;[<span itemprop="pagination">96-107</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_12;The notion of an unavoidable set of words appears frequently in the fields of mathematics and theoretical computer science, in particular with its connection to the study of combinatorics on words. The theory of unavoidable sets has seen extensive study over the past twenty years. In this paper we extend the definition of unavoidable sets of words to unavoidable sets of partial words. Partial words, or finite sequences that may contain a number of “do not know” symbols or holes, appear in natural ways in several areas of current interest such as molecular biology, data communication, DNA computing, etc. We demonstrate the utility of the notion of unavoidability on partial words by making use of it to identify several new classes of unavoidable sets of full words. Along the way we begin work on classifying the unavoidable sets of partial words of small cardinality. We pose a conjecture, and show that affirmative proof of this conjecture gives a sufficient condition for classifying all the unavoidable sets of partial words of size two. Lastly we give a result which makes the conjecture easy to verify for a significant number of cases.
Justin Palumbo;Two Element Unavoidable Sets of Partial Words.;Francine Blanchet-Sadri, N. C. Brownstein;[<span itemprop="pagination">96-107</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_12;The notion of an unavoidable set of words appears frequently in the fields of mathematics and theoretical computer science, in particular with its connection to the study of combinatorics on words. The theory of unavoidable sets has seen extensive study over the past twenty years. In this paper we extend the definition of unavoidable sets of words to unavoidable sets of partial words. Partial words, or finite sequences that may contain a number of “do not know” symbols or holes, appear in natural ways in several areas of current interest such as molecular biology, data communication, DNA computing, etc. We demonstrate the utility of the notion of unavoidability on partial words by making use of it to identify several new classes of unavoidable sets of full words. Along the way we begin work on classifying the unavoidable sets of partial words of small cardinality. We pose a conjecture, and show that affirmative proof of this conjecture gives a sufficient condition for classifying all the unavoidable sets of partial words of size two. Lastly we give a result which makes the conjecture easy to verify for a significant number of cases.
Henning Bordihn;Hairpin Finite Automata.;Markus Holzer, Martin Kutrib;[<span itemprop="pagination">108-119</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_13;We introduce and investigate nondeterministic finite automata with the additional ability to apply the hairpin inversion operation to the remaining part of the input. We consider three different modes of hairpin operations, namely left-most hairpin, general hairpin, and right-most hairpin. We show that these operations do not increase the computation power, when the number of operations is bounded by a constant. An unbounded number of these operations leads to language families that are properly contained in the family of context-sensitive languages and are supersets of the family of regular languages. Moreover, we show that in most cases we obtain incomparability results for the language families under consideration. Finally, we summarize closure properties of language families accepted by variants of hairpin finite automata.
Markus Holzer;Hairpin Finite Automata.;Henning Bordihn, Martin Kutrib;[<span itemprop="pagination">108-119</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_13;We introduce and investigate nondeterministic finite automata with the additional ability to apply the hairpin inversion operation to the remaining part of the input. We consider three different modes of hairpin operations, namely left-most hairpin, general hairpin, and right-most hairpin. We show that these operations do not increase the computation power, when the number of operations is bounded by a constant. An unbounded number of these operations leads to language families that are properly contained in the family of context-sensitive languages and are supersets of the family of regular languages. Moreover, we show that in most cases we obtain incomparability results for the language families under consideration. Finally, we summarize closure properties of language families accepted by variants of hairpin finite automata.
Martin Kutrib;Hairpin Finite Automata.;Henning Bordihn, Markus Holzer;[<span itemprop="pagination">108-119</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_13;We introduce and investigate nondeterministic finite automata with the additional ability to apply the hairpin inversion operation to the remaining part of the input. We consider three different modes of hairpin operations, namely left-most hairpin, general hairpin, and right-most hairpin. We show that these operations do not increase the computation power, when the number of operations is bounded by a constant. An unbounded number of these operations leads to language families that are properly contained in the family of context-sensitive languages and are supersets of the family of regular languages. Moreover, we show that in most cases we obtain incomparability results for the language families under consideration. Finally, we summarize closure properties of language families accepted by variants of hairpin finite automata.
Robert Brijder;Characterizing Reduction Graphs for Gene Assembly in Ciliates.;Hendrik Jan Hoogeboom;[<span itemprop="pagination">120-131</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_14;The biological process of gene assembly has been modeled based on three types of string rewriting rules, called string pointer rules, defined on so-called legal strings. It has been shown that reduction graphs, graphs that are based on the notion of breakpoint graph in the theory of sorting by reversal, for legal strings provide valuable insights into the gene assembly process. We characterize which legal strings obtain the same reduction graph (up to isomorphism), and moreover we characterize which graphs are (isomorphic to) reduction graphs.
Hendrik Jan Hoogeboom;Characterizing Reduction Graphs for Gene Assembly in Ciliates.;Robert Brijder;[<span itemprop="pagination">120-131</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_14;The biological process of gene assembly has been modeled based on three types of string rewriting rules, called string pointer rules, defined on so-called legal strings. It has been shown that reduction graphs, graphs that are based on the notion of breakpoint graph in the theory of sorting by reversal, for legal strings provide valuable insights into the gene assembly process. We characterize which legal strings obtain the same reduction graph (up to isomorphism), and moreover we characterize which graphs are (isomorphic to) reduction graphs.
Dario Carotenuto;2-Visibly Pushdown Automata.;Aniello Murano, Adriano Peron;[<span itemprop="pagination">132-144</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_15;Visibly Pushdown Automata (VPA) are a special case of pushdown machines where the stack operations are driven by the input. In this paper, we consider VPA with two stacks, namely 2-VPA. These automata introduce a useful model to effectively describe concurrent pushdown systems using a simple communication mechanism between stacks. We show that 2-VPA are strictly more expressive than VPA. Indeed, 2-VPA accept some context-sensitive languages that are not context-free and some context-free languages that are not accepted by any VPA. Nevertheless, the class of languages accepted by 2-VPA is closed under all boolean operations and determinizable in ExpTime, but does not preserve decidability of emptiness problem. By adding an ordering constraint on stacks (2-OVPA), decidability of emptiness can be recovered (preserving desirable closure properties) and solved in PTime. Using these properties along with the automata-theoretic approach, we prove that the model checking problem over 2-OVPA models against 2-OVPA specifications is ExpTime-complete.
Aniello Murano;2-Visibly Pushdown Automata.;Dario Carotenuto, Adriano Peron;[<span itemprop="pagination">132-144</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_15;Visibly Pushdown Automata (VPA) are a special case of pushdown machines where the stack operations are driven by the input. In this paper, we consider VPA with two stacks, namely 2-VPA. These automata introduce a useful model to effectively describe concurrent pushdown systems using a simple communication mechanism between stacks. We show that 2-VPA are strictly more expressive than VPA. Indeed, 2-VPA accept some context-sensitive languages that are not context-free and some context-free languages that are not accepted by any VPA. Nevertheless, the class of languages accepted by 2-VPA is closed under all boolean operations and determinizable in ExpTime, but does not preserve decidability of emptiness problem. By adding an ordering constraint on stacks (2-OVPA), decidability of emptiness can be recovered (preserving desirable closure properties) and solved in PTime. Using these properties along with the automata-theoretic approach, we prove that the model checking problem over 2-OVPA models against 2-OVPA specifications is ExpTime-complete.
Adriano Peron;2-Visibly Pushdown Automata.;Dario Carotenuto, Aniello Murano;[<span itemprop="pagination">132-144</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_15;Visibly Pushdown Automata (VPA) are a special case of pushdown machines where the stack operations are driven by the input. In this paper, we consider VPA with two stacks, namely 2-VPA. These automata introduce a useful model to effectively describe concurrent pushdown systems using a simple communication mechanism between stacks. We show that 2-VPA are strictly more expressive than VPA. Indeed, 2-VPA accept some context-sensitive languages that are not context-free and some context-free languages that are not accepted by any VPA. Nevertheless, the class of languages accepted by 2-VPA is closed under all boolean operations and determinizable in ExpTime, but does not preserve decidability of emptiness problem. By adding an ordering constraint on stacks (2-OVPA), decidability of emptiness can be recovered (preserving desirable closure properties) and solved in PTime. Using these properties along with the automata-theoretic approach, we prove that the model checking problem over 2-OVPA models against 2-OVPA specifications is ExpTime-complete.
Jean-Marc Champarnaud;None;Faissal Ouardi, Djelloul Ziadi;[<span itemprop="pagination">145-156</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_16;The aim of this paper is to describe a quadratic algorithm to compute the equation \(\mathbb{K}\)-automaton of a regular \(\mathbb{K}\)-expression as defined by Lombardy and Sakarovitch. Our construction is based on an extension to regular \(\mathbb{K}\)-expressions of the notion of c-continuation that we introduced to compute the equation automaton of a regular expression as a quotient of its position automaton.
Faissal Ouardi;None;Jean-Marc Champarnaud, Djelloul Ziadi;[<span itemprop="pagination">145-156</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_16;The aim of this paper is to describe a quadratic algorithm to compute the equation \(\mathbb{K}\)-automaton of a regular \(\mathbb{K}\)-expression as defined by Lombardy and Sakarovitch. Our construction is based on an extension to regular \(\mathbb{K}\)-expressions of the notion of c-continuation that we introduced to compute the equation automaton of a regular expression as a quotient of its position automaton.
Djelloul Ziadi;None;Jean-Marc Champarnaud, Faissal Ouardi;[<span itemprop="pagination">145-156</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_16;The aim of this paper is to describe a quadratic algorithm to compute the equation \(\mathbb{K}\)-automaton of a regular \(\mathbb{K}\)-expression as defined by Lombardy and Sakarovitch. Our construction is based on an extension to regular \(\mathbb{K}\)-expressions of the notion of c-continuation that we introduced to compute the equation automaton of a regular expression as a quotient of its position automaton.
Javier Esparza;None;Stefan Kiefer, Michael Luttenberger;[<span itemprop="pagination">157-168</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_17;Fixed point equations x = F(x) over ω-continuous semirings are a natural mathematical foundation of interprocedural program analysis. Equations over the semiring of the real numbers can be solved numerically using Newton’s method. We generalize the method to any ω-continuous semiring and show that it converges faster to the least fixed point than the Kleene sequence 0, F(0), F(F(0)),... We prove that the Newton approximants in the semiring of languages coincide with finite-index approximations studied by several authors in the 1960s. Finally, we apply our results to the analysis of stochastic context-free grammars.
Stefan Kiefer;None;Javier Esparza, Michael Luttenberger;[<span itemprop="pagination">157-168</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_17;Fixed point equations x = F(x) over ω-continuous semirings are a natural mathematical foundation of interprocedural program analysis. Equations over the semiring of the real numbers can be solved numerically using Newton’s method. We generalize the method to any ω-continuous semiring and show that it converges faster to the least fixed point than the Kleene sequence 0, F(0), F(F(0)),... We prove that the Newton approximants in the semiring of languages coincide with finite-index approximations studied by several authors in the 1960s. Finally, we apply our results to the analysis of stochastic context-free grammars.
Michael Luttenberger;None;Javier Esparza, Stefan Kiefer;[<span itemprop="pagination">157-168</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_17;Fixed point equations x = F(x) over ω-continuous semirings are a natural mathematical foundation of interprocedural program analysis. Equations over the semiring of the real numbers can be solved numerically using Newton’s method. We generalize the method to any ω-continuous semiring and show that it converges faster to the least fixed point than the Kleene sequence 0, F(0), F(F(0)),... We prove that the Newton approximants in the semiring of languages coincide with finite-index approximations studied by several authors in the 1960s. Finally, we apply our results to the analysis of stochastic context-free grammars.
Rusins Freivalds;Non-constructive Methods for Finite Probabilistic Automata.;;[<span itemprop="pagination">169-180</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_18;Size (the number of states) of finite probabilistic automata with an isolated cut-point can be exponentially smaller than the size of any equivalent finite deterministic automaton. The result is presented in two versions. The first version depends on Artin’s Conjecture (1927) in Number Theory. The second version does not depend on conjectures but the numerical estimates are worse. In both versions the method of the proof does not allow an explicit description of the languages used. Since our finite probabilistic automata are reversible, these results imply a similar result for quantum finite automata.
Dominik D. Freydenberger;The Unambiguity of Segmented Morphisms.;Daniel Reidenbach;[<span itemprop="pagination">181-192</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_19;A segmented morphism \(\sigma_n: \Delta^* \longrightarrow \{ {\ensuremath{\mathtt{a}}}, {\ensuremath{\mathtt{b}}} \}^*\), n ∈ ℕ, maps each symbol in Δ onto a word which consists of n distinct subwords in \({\ensuremath{\mathtt{a}}} {\ensuremath{\mathtt{b}}}^+ {\ensuremath{\mathtt{a}}}\). In the present paper, we examine the impact of n on the unambiguity of σn with respect to any α ∈ Δ + , i. e. the question of whether there does not exist a morphism τ satisfying τ(α) = σn(α) and, for some symbol x in α, τ(x) ≠ σn(x). To this end, we consider the set U(σn) of those α ∈ Δ +  with respect to which σn is unambiguous, and we comprehensively describe its relation to any U(σm), m ≠ n. Our paper thus contributes fundamental (and, in parts, fairly counter-intuitive) results to the recently initiated research on the ambiguity of morphisms.
Daniel Reidenbach;The Unambiguity of Segmented Morphisms.;Dominik D. Freydenberger;[<span itemprop="pagination">181-192</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_19;A segmented morphism \(\sigma_n: \Delta^* \longrightarrow \{ {\ensuremath{\mathtt{a}}}, {\ensuremath{\mathtt{b}}} \}^*\), n ∈ ℕ, maps each symbol in Δ onto a word which consists of n distinct subwords in \({\ensuremath{\mathtt{a}}} {\ensuremath{\mathtt{b}}}^+ {\ensuremath{\mathtt{a}}}\). In the present paper, we examine the impact of n on the unambiguity of σn with respect to any α ∈ Δ + , i. e. the question of whether there does not exist a morphism τ satisfying τ(α) = σn(α) and, for some symbol x in α, τ(x) ≠ σn(x). To this end, we consider the set U(σn) of those α ∈ Δ +  with respect to which σn is unambiguous, and we comprehensively describe its relation to any U(σm), m ≠ n. Our paper thus contributes fundamental (and, in parts, fairly counter-intuitive) results to the recently initiated research on the ambiguity of morphisms.
Anna E. Frid;Commutation of Binary Factorial Languages.;;[<span itemprop="pagination">193-204</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_20;We solve the commutation equation AB = BA for binary factorial languages A and B. As we show, the situations when such languages commute can be naturally classified. The result is based on the existence and uniqueness of a canonical decomposition of a factorial language, proved by S. V. Avgustinovich and the author in 2005. It continues investigation of the semigroup of factorial languages.
Hermann Gruber;Inapproximability of Nondeterministic State and Transition Complexity Assuming P=!NP.;Markus Holzer;[<span itemprop="pagination">205-216</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_21;Inapproximability results concerning minimization of nondeterministic finite automata relative to given deterministic finite automata were obtained only recently, modulo cryptographic assumptions [4]. Here we give upper and lower bounds on the approximability of this problem utilizing only the common assumption P ≠ NP, in the setup where the input is a finite language specified by a truth table. To this end, we derive an improved inapproximability result for the biclique edge cover problem. The obtained lower bounds on approximability can be sharpened in the case where the input is given as a deterministic finite automaton over a binary alphabet. This settles most of the open problems stated in [4]. Note that the biclique edge cover problem was recently studied by the authors as lower bound method for the nondeterministic state complexity of finite automata [5].
Markus Holzer;Inapproximability of Nondeterministic State and Transition Complexity Assuming P=!NP.;Hermann Gruber;[<span itemprop="pagination">205-216</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_21;Inapproximability results concerning minimization of nondeterministic finite automata relative to given deterministic finite automata were obtained only recently, modulo cryptographic assumptions [4]. Here we give upper and lower bounds on the approximability of this problem utilizing only the common assumption P ≠ NP, in the setup where the input is a finite language specified by a truth table. To this end, we derive an improved inapproximability result for the biclique edge cover problem. The obtained lower bounds on approximability can be sharpened in the case where the input is given as a deterministic finite automaton over a binary alphabet. This settles most of the open problems stated in [4]. Note that the biclique edge cover problem was recently studied by the authors as lower bound method for the nondeterministic state complexity of finite automata [5].
Yo-Sub Han;State Complexity of Union and Intersection of Finite Languages.;Kai Salomaa;[<span itemprop="pagination">217-228</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_22;We investigate the state complexity of union and intersection for finite languages. Note that the problem of obtaining the tight bounds for both operations was open. We compute the upper bounds based on the structural properties of minimal deterministic finite-state automata (DFAs) for finite languages. Then, we show that the upper bounds are tight if we have a variable sized alphabet that can depend on the size of input DFAs. In addition, we prove that the upper bounds are unreachable for any fixed sized alphabet.
Kai Salomaa;State Complexity of Union and Intersection of Finite Languages.;Yo-Sub Han;[<span itemprop="pagination">217-228</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_22;We investigate the state complexity of union and intersection for finite languages. Note that the problem of obtaining the tight bounds for both operations was open. We compute the upper bounds based on the structural properties of minimal deterministic finite-state automata (DFAs) for finite languages. Then, we show that the upper bounds are tight if we have a variable sized alphabet that can depend on the size of input DFAs. In addition, we prove that the upper bounds are unreachable for any fixed sized alphabet.
Johanna Högberg;Bisimulation Minimisation for Weighted Tree Automata.;Andreas Maletti, Jonathan May;[<span itemprop="pagination">229-241</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_23;We generalise existing forward and backward bisimulation minimisation algorithms for tree automata to weighted tree automata. The obtained algorithms work for all semirings and retain the time complexity of their unweighted variants for all additively cancellative semirings. On all other semirings the time complexity is slightly higher (linear instead of logarithmic in the number of states). We discuss implementations of these algorithms on a typical task in natural language processing.
Andreas Maletti;Bisimulation Minimisation for Weighted Tree Automata.;Johanna Högberg, Jonathan May;[<span itemprop="pagination">229-241</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_23;We generalise existing forward and backward bisimulation minimisation algorithms for tree automata to weighted tree automata. The obtained algorithms work for all semirings and retain the time complexity of their unweighted variants for all additively cancellative semirings. On all other semirings the time complexity is slightly higher (linear instead of logarithmic in the number of states). We discuss implementations of these algorithms on a typical task in natural language processing.
Jonathan May;Bisimulation Minimisation for Weighted Tree Automata.;Johanna Högberg, Andreas Maletti;[<span itemprop="pagination">229-241</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_23;We generalise existing forward and backward bisimulation minimisation algorithms for tree automata to weighted tree automata. The obtained algorithms work for all semirings and retain the time complexity of their unweighted variants for all additively cancellative semirings. On all other semirings the time complexity is slightly higher (linear instead of logarithmic in the number of states). We discuss implementations of these algorithms on a typical task in natural language processing.
Artur Jez;Conjunctive Grammars Can Generate Non-regular Unary Languages.;;[<span itemprop="pagination">242-253</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_24;Conjunctive grammars were introduced by A. Okhotin in [1] as a natural extension of context-free grammars with an additional operation of intersection in the body of any production of the grammar. Several theorems and algorithms for context-free grammars generalize to the conjunctive case. Still some questions remained open. A. Okhotin posed nine problems concerning those grammars. One of them was a question, whether a conjunctive grammar over unary alphabet can generate only regular languages. We give a negative answer, contrary to the conjectured positive one, by constructing a conjunctive grammar for the language \(\{ a^{4^{n}} : n \in \mathbb{N} \}\). We then generalise this result—for every set of numbers L such that their representation in some k-ary system is regular set we show that \(\{ a^{k^{n}} : n \in L \}\) is generated by some conjunctive grammar over unary alphabet.
Jozef Jirásek;Deterministic Blow-Ups of Minimal Nondeterministic Finite Automata over a Fixed Alphabet.;Galina Jirásková, Alexander Szabari;[<span itemprop="pagination">254-265</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_25;We show that for all integers n and α such that \(n \leqslant \alpha \leqslant 2^n,\) there exists a minimal nondeterministic finite automaton of n states with a four-letter input alphabet whose equivalent minimal deterministic finite automaton has exactly α states. It follows that in the case of a four-letter alphabet, there are no “magic numbers”, i.e., the holes in the hierarchy. This improves a similar result obtained by Geffert for a growing alphabet of size n + 2 (Proc. 7th DCFS, Como, Italy, 23–37).
Galina Jirásková;Deterministic Blow-Ups of Minimal Nondeterministic Finite Automata over a Fixed Alphabet.;Jozef Jirásek, Alexander Szabari;[<span itemprop="pagination">254-265</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_25;We show that for all integers n and α such that \(n \leqslant \alpha \leqslant 2^n,\) there exists a minimal nondeterministic finite automaton of n states with a four-letter input alphabet whose equivalent minimal deterministic finite automaton has exactly α states. It follows that in the case of a four-letter alphabet, there are no “magic numbers”, i.e., the holes in the hierarchy. This improves a similar result obtained by Geffert for a growing alphabet of size n + 2 (Proc. 7th DCFS, Como, Italy, 23–37).
Alexander Szabari;Deterministic Blow-Ups of Minimal Nondeterministic Finite Automata over a Fixed Alphabet.;Jozef Jirásek, Galina Jirásková;[<span itemprop="pagination">254-265</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_25;We show that for all integers n and α such that \(n \leqslant \alpha \leqslant 2^n,\) there exists a minimal nondeterministic finite automaton of n states with a four-letter input alphabet whose equivalent minimal deterministic finite automaton has exactly α states. It follows that in the case of a four-letter alphabet, there are no “magic numbers”, i.e., the holes in the hierarchy. This improves a similar result obtained by Geffert for a growing alphabet of size n + 2 (Proc. 7th DCFS, Como, Italy, 23–37).
Sandrine Julia;None;Tran Vinh Duc;[<span itemprop="pagination">266-277</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_26;We consider the following decision problem: “Is a rational ω-language generated by a code ?” Since 1994, the codes admit a in terms of infinite words. We derive from this result the definition of a new class of languages, the reduced languages. A code is a reduced language but the converse does not hold. The idea is to “reduce” easy-to-obtain minimal ω-generators in order to obtain codes as ω-generators.
Tran Vinh Duc;None;Sandrine Julia;[<span itemprop="pagination">266-277</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_26;We consider the following decision problem: “Is a rational ω-language generated by a code ?” Since 1994, the codes admit a in terms of infinite words. We derive from this result the definition of a new class of languages, the reduced languages. A code is a reduced language but the converse does not hold. The idea is to “reduce” easy-to-obtain minimal ω-generators in order to obtain codes as ω-generators.
Dalia Krieger;Avoiding Approximate Squares.;Pascal Ochem, Narad Rampersad, Jeffrey O. Shallit;[<span itemprop="pagination">278-289</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_27;As is well-known, Axel Thue constructed an infinite word over a 3-letter alphabet that contains no squares, that is, no nonempty subwords of the form xx. In this paper we consider a variation on this problem, where we try to avoid approximate squares, that is, subwords of the form xx′ where |x| = |x′| and x and x′ are “nearly” identical.
Pascal Ochem;Avoiding Approximate Squares.;Dalia Krieger, Narad Rampersad, Jeffrey O. Shallit;[<span itemprop="pagination">278-289</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_27;As is well-known, Axel Thue constructed an infinite word over a 3-letter alphabet that contains no squares, that is, no nonempty subwords of the form xx. In this paper we consider a variation on this problem, where we try to avoid approximate squares, that is, subwords of the form xx′ where |x| = |x′| and x and x′ are “nearly” identical.
Narad Rampersad;Avoiding Approximate Squares.;Dalia Krieger, Pascal Ochem, Jeffrey O. Shallit;[<span itemprop="pagination">278-289</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_27;As is well-known, Axel Thue constructed an infinite word over a 3-letter alphabet that contains no squares, that is, no nonempty subwords of the form xx. In this paper we consider a variation on this problem, where we try to avoid approximate squares, that is, subwords of the form xx′ where |x| = |x′| and x and x′ are “nearly” identical.
Jeffrey O. Shallit;Avoiding Approximate Squares.;Dalia Krieger, Pascal Ochem, Narad Rampersad;[<span itemprop="pagination">278-289</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_27;As is well-known, Axel Thue constructed an infinite word over a 3-letter alphabet that contains no squares, that is, no nonempty subwords of the form xx. In this paper we consider a variation on this problem, where we try to avoid approximate squares, that is, subwords of the form xx′ where |x| = |x′| and x and x′ are “nearly” identical.
Peter Leupold;Duplication Roots.;;[<span itemprop="pagination">290-299</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_28;Recently the duplication closure of words and languages has received much interest. We investigate a reversal of it: the duplication root reduces a word to a square-free one. After stating a few elementary properties of this type of root, we explore the question whether or not a language has finite duplication root. For regular languages and uniformly bounded duplication root this is decidable.
Remco Loos;Complexity Theory for Splicing Systems.;Mitsunori Ogihara;[<span itemprop="pagination">300-311</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_29;This paper proposes a notion of time complexity in splicing systems and presents fundamental properties of SPLTIME, the class of languages with splicing system time complexity t(n). Its relations to classes based on standard computational models are explored. It is shown that for any function t(n), SPLTIME[t(n)] is included in 1NSPACE[t(n)]. Expanding on this result, 1NSPACE[t(n)] is characterized in terms of splicing systems: it is the class of languages accepted by a t(n)-space uniform family of extended splicing systems having production time O(t(n)) with regular rules described by finite automata with at most a constant number of states. As to lower bounds, it is shown that for all functions t(n) ≥ logn, all languages accepted by a pushdown automaton with maximal stack height t(|x|) for a word x are in SPLTIME[t(n)]. From this result, it follows that the regular languages are in SPLTIME[O(log(n))] and that the context-free languages are in SPLTIME[O(n)].
Mitsunori Ogihara;Complexity Theory for Splicing Systems.;Remco Loos;[<span itemprop="pagination">300-311</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_29;This paper proposes a notion of time complexity in splicing systems and presents fundamental properties of SPLTIME, the class of languages with splicing system time complexity t(n). Its relations to classes based on standard computational models are explored. It is shown that for any function t(n), SPLTIME[t(n)] is included in 1NSPACE[t(n)]. Expanding on this result, 1NSPACE[t(n)] is characterized in terms of splicing systems: it is the class of languages accepted by a t(n)-space uniform family of extended splicing systems having production time O(t(n)) with regular rules described by finite automata with at most a constant number of states. As to lower bounds, it is shown that for all functions t(n) ≥ logn, all languages accepted by a pushdown automaton with maximal stack height t(|x|) for a word x are in SPLTIME[t(n)]. From this result, it follows that the regular languages are in SPLTIME[O(log(n))] and that the context-free languages are in SPLTIME[O(n)].
Andreas Malcher;Descriptional Complexity of Bounded Context-Free Languages.;Giovanni Pighizzini;[<span itemprop="pagination">312-323</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_30;Finite-turn pushdown automata (PDA) are investigated concerning their descriptional complexity. It is known that they accept exactly the class of ultralinear context-free languages. Furthermore, the increase in size when converting arbitrary PDAs accepting ultralinear languages to finite-turn PDAs cannot be bounded by any recursive function. The latter phenomenon is known as non-recursive trade-off. In this paper, finite-turn PDAs accepting letter-bounded languages are considered. It turns out that in this case the non-recursive trade-off is reduced to a recursive trade-off, more precisely, to an exponential trade-off. A conversion algorithm is presented and the optimality of the construction is shown by proving tight lower bounds. Furthermore, the question of reducing the number of turns of a given finite-turn PDA is studied. Again, a conversion algorithm is provided which shows that in this case the trade-off is at most polynomial.
Giovanni Pighizzini;Descriptional Complexity of Bounded Context-Free Languages.;Andreas Malcher;[<span itemprop="pagination">312-323</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_30;Finite-turn pushdown automata (PDA) are investigated concerning their descriptional complexity. It is known that they accept exactly the class of ultralinear context-free languages. Furthermore, the increase in size when converting arbitrary PDAs accepting ultralinear languages to finite-turn PDAs cannot be bounded by any recursive function. The latter phenomenon is known as non-recursive trade-off. In this paper, finite-turn PDAs accepting letter-bounded languages are considered. It turns out that in this case the non-recursive trade-off is reduced to a recursive trade-off, more precisely, to an exponential trade-off. A conversion algorithm is presented and the optimality of the construction is shown by proving tight lower bounds. Furthermore, the question of reducing the number of turns of a given finite-turn PDA is studied. Again, a conversion algorithm is provided which shows that in this case the trade-off is at most polynomial.
Christian Mathissen;Definable Transductions and Weighted Logics for Texts.;;[<span itemprop="pagination">324-336</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_31;A text is a word together with an additional linear order on it. We study quantitative models for texts, i. e. text series which assign to texts elements of a semiring. We consider an algebraic notion of recognizability following Reutenauer and Bozapalidis and show that recognizable text series coincide with text series definable in weighted logics as introduced by Droste and Gastin. In order to do so, we study certain definable transductions and show that they are compatible with weighted logics. Moreover, we show that the behavior of weighted parenthesizing automata coincides with certain definable series.
Edward Ochmanski;A Star Operation for Star-Free Trace Languages.;Krystyna Stawikowska;[<span itemprop="pagination">337-345</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_32;The paper deals with star-free languages in trace monoids. We define a constrained star operation, named star-free star, and show a new characterisation of star-free trace languages, using this operation instead of complement. We obtain this characterisation combining a star-free star characterisation for word languages and logical characterisation of trace languages (Ebinger/Muscholl). Moreover, some new, simple proofs of known results are presented in the paper.
Krystyna Stawikowska;A Star Operation for Star-Free Trace Languages.;Edward Ochmanski;[<span itemprop="pagination">337-345</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_32;The paper deals with star-free languages in trace monoids. We define a constrained star operation, named star-free star, and show a new characterisation of star-free trace languages, using this operation instead of complement. We obtain this characterisation combining a star-free star characterisation for word languages and logical characterisation of trace languages (Ebinger/Muscholl). Moreover, some new, simple proofs of known results are presented in the paper.
Lutz Priese;Finite Automata on Unranked and Unordered DAGs.;;[<span itemprop="pagination">346-360</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_33;We introduce linear expressions for unrestricted dags (directed acyclic graphs) and finite deterministic and nondeterministic automata operating on them. Those dag automata are a conservative extension of the Tu,u-automata of Courcelle on unranked, unordered trees and forests. Several examples of dag languages acceptable and not acceptable by dag automata and some closure properties are given.
Yuri Pritykin;On Almost Periodicity Criteria for Morphic Sequences in Some Particular Cases.;;[<span itemprop="pagination">361-370</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_34;In some particular cases we give criteria for morphic sequences to be almost periodic (=uniformly recurrent). Namely, we deal with fixed points of non-erasing morphisms and with automatic sequences. In both cases a polynomial-time algorithm solving the problem is found. A result more or less supporting the conjecture of decidability of the general problem is given.
Gwénaël Richomme;A Local Balance Property of Episturmian Words.;;[<span itemprop="pagination">371-381</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_35;We prove that episturmian words and Arnoux-Rauzy sequences can be characterized using a local balance property. We also give a new characterization of epistandard words.
Marinella Sciortino;Suffix Automata and Standard Sturmian Words.;Luca Q. Zamboni;[<span itemprop="pagination">382-398</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_36;Blumer et al. showed (cf. [3,2]) that the suffix automaton of a word w must have at least |w| + 1 states and at most 2|w| − 1 states. In this paper we characterize the language L of all binary words w whose minimal suffix automaton \(\mathcal{S}(w)\) has exactly |w| + 1 states. they are precisely all prefixes of standard Sturmian words. In particular, we give an explicit construction of suffix automaton of words that are palindromic prefixes of standard words. Moreover, we establish a necessary and sufficient condition on \(\mathcal{S}(w)\) which ensures that if w ∈ L and a ∈ {0,1} then wa ∈ L. By using such a condition, we show how to construct the automaton \(\mathcal{S}(wa)\) from \(\mathcal{S}(w)\). More generally, we provide a simple construction that by starting from an automaton recognizing all suffixes of a word w over a finite alphabet A, allows to obtain an automaton that recognizes the suffixes of wa, a ∈ A.
Luca Q. Zamboni;Suffix Automata and Standard Sturmian Words.;Marinella Sciortino;[<span itemprop="pagination">382-398</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_36;Blumer et al. showed (cf. [3,2]) that the suffix automaton of a word w must have at least |w| + 1 states and at most 2|w| − 1 states. In this paper we characterize the language L of all binary words w whose minimal suffix automaton \(\mathcal{S}(w)\) has exactly |w| + 1 states. they are precisely all prefixes of standard Sturmian words. In particular, we give an explicit construction of suffix automaton of words that are palindromic prefixes of standard words. Moreover, we establish a necessary and sufficient condition on \(\mathcal{S}(w)\) which ensures that if w ∈ L and a ∈ {0,1} then wa ∈ L. By using such a condition, we show how to construct the automaton \(\mathcal{S}(wa)\) from \(\mathcal{S}(w)\). More generally, we provide a simple construction that by starting from an automaton recognizing all suffixes of a word w over a finite alphabet A, allows to obtain an automaton that recognizes the suffixes of wa, a ∈ A.
Victor L. Selivanov;None;;[<span itemprop="pagination">399-410</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_37;We develop a theory of regular aperiodic ω-languages in parallel with the theory around the Wagner hierarchy. In particular, we characterize the Wadge degrees of regular aperiodic ω-languages, find an effective version of the Wadge reducibility adequate for this class of languages and prove “aperiodic analogs” of the Büchi-Landweber determinacy theorem and of Landweber’s description of regular open and regular Gδ sets.
Hellis Tamm;On Transition Minimality of Bideterministic Automata.;;[<span itemprop="pagination">411-421</span>];[<meta content="2007" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-540-73208-2_38;Bideterministic automata are deterministic automata with the property of their reversal automata also being deterministic. Bideterministic automata have previously been shown to be unique (up to an isomorphism) minimal NFAs with respect to the number of states. In this paper, we show that in addition to state minimality, bideterministic automata are also transition-minimal NFAs. However, as this transition minimality is not necessarily unique, we also present the necessary and sufficient conditions for a bideterministic automaton to be uniquely transition-minimal among NFAs. Furthermore, we show that bideterministic automata are transition-minimal ε-NFAs.
Golnaz Badkobeh;Hunting Redundancies in Strings.;Supaporn Chairungsee, Maxime Crochemore;[<span itemprop="pagination">1-14</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_1;The notion of redundancies in texts, regarded as sequences of symbols, appear under various concepts in the literature of Combinatorics on words and of Algorithms on strings: repetitions, repeats, runs, covers, seeds, and palindromes, for example.
Supaporn Chairungsee;Hunting Redundancies in Strings.;Golnaz Badkobeh, Maxime Crochemore;[<span itemprop="pagination">1-14</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_1;The notion of redundancies in texts, regarded as sequences of symbols, appear under various concepts in the literature of Combinatorics on words and of Algorithms on strings: repetitions, repeats, runs, covers, seeds, and palindromes, for example.
Maxime Crochemore;Hunting Redundancies in Strings.;Golnaz Badkobeh, Supaporn Chairungsee;[<span itemprop="pagination">1-14</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_1;The notion of redundancies in texts, regarded as sequences of symbols, appear under various concepts in the literature of Combinatorics on words and of Algorithms on strings: repetitions, repeats, runs, covers, seeds, and palindromes, for example.
Antonio Restivo;Some Remarks on Automata Minimality.;Roberto Vaglica;[<span itemprop="pagination">15-27</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_2;It is well known that the minimization problem of deterministic finite automata (DFAs) is related to the indistinguishability notion of states (cf. [HMU00]). Indeed, a well known technique to minimize a DFA, essentially, consists in finding pairs of states that are equivalent (or indistinguishable), namely pairs of states (p,q) such that it is impossible to assert the difference between p and q only by starting in each of the two states and asking whether or not a given input string leads to a final state. Since, in the testing states equivalence, the notion of initial state is irrelevant, some of the main techniques for the minimization of automata, such as Moore’s algorithm [Moo56] and Hopcroft’s algorithm [Hop71], do not care what is the initial state of the automaton, when applied to accessible automata (i.e. such that all states can be reached from the initial state). Therefore a natural question that arises is, for accessible automata, on what does minimality depend? Obviously, it depends on both the automata transitions and the set of final states. In this paper, our main focus is to investigate to what extent minimality depends on the particular subset of final states.
Roberto Vaglica;Some Remarks on Automata Minimality.;Antonio Restivo;[<span itemprop="pagination">15-27</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_2;It is well known that the minimization problem of deterministic finite automata (DFAs) is related to the indistinguishability notion of states (cf. [HMU00]). Indeed, a well known technique to minimize a DFA, essentially, consists in finding pairs of states that are equivalent (or indistinguishable), namely pairs of states (p,q) such that it is impossible to assert the difference between p and q only by starting in each of the two states and asking whether or not a given input string leads to a final state. Since, in the testing states equivalence, the notion of initial state is irrelevant, some of the main techniques for the minimization of automata, such as Moore’s algorithm [Moo56] and Hopcroft’s algorithm [Hop71], do not care what is the initial state of the automaton, when applied to accessible automata (i.e. such that all states can be reached from the initial state). Therefore a natural question that arises is, for accessible automata, on what does minimality depend? Obviously, it depends on both the automata transitions and the set of final states. In this paper, our main focus is to investigate to what extent minimality depends on the particular subset of final states.
Arseny M. Shur;Growth Properties of Power-Free Languages.;;[<span itemprop="pagination">28-43</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_3;The aim of this paper is to give a short survey of the area formed by the intersection of two popular lines of investigation in formal language theory. The first line, originated by Thue in 1906, concerns about repetition-free words and languages. The second line is the study of growth functions for words and languages. it can be traced back to the classical papers by Morse and Hedlund on symbolic dynamics (1938, 1940). Growth functions of repetition-free languages are investigated since 1980’s. Most of the results were obtained for power-free languages, but some ideas can be applied for languages avoiding patterns and Abelian-power-free languages as well.
Thomas Wilke;A Functional Program for Regular Expressions Matching - Abstract of Invited Talk.;;[<span itemprop="pagination">44-45</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_4;Regular expressions [4] and tools to handle them, especially tools for regular expression matching—an early one is described in the seminal paper [5] by Ken Thompson—, are one of the major achievements of formal language and automata theory. Google counts 303,000 results for “regular expressions matching” (May 4, 2011). there are numerous command line tools for working with regular expressions such as grep. Google released a regular expression C++ library not long ago [3]. almost every programming language provides support for regular expressions. and even the text editor I am using to produce the source code of this LaTeX document has an extensive regular expression library.
Sheng Yu;State Complexity Research and Approximation.;Yuan Gao;[<span itemprop="pagination">46-57</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_5;A number of basic questions concerning the state complexity research are discussed, which include why many basic problems weren’t studied earlier, whether there is a general algorithm for state complexity, and whether there is a new approach in this area of research. The new concept of state complexity approximation is also discussed. We show that this new concept can be used to obtain good results when the exact state complexities are difficult to find.
Yuan Gao;State Complexity Research and Approximation.;Sheng Yu;[<span itemprop="pagination">46-57</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_5;A number of basic questions concerning the state complexity research are discussed, which include why many basic problems weren’t studied earlier, whether there is a general algorithm for state complexity, and whether there is a new approach in this area of research. The new concept of state complexity approximation is also discussed. We show that this new concept can be used to obtain good results when the exact state complexities are difficult to find.
Giovanni Battaglia;Counting the Orderings for Multisets in Consecutive Ones Property and PQ-Trees.;Roberto Grossi, Noemi Scutellà;[<span itemprop="pagination">58-69</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_6;A binary matrix satisfies the consecutive ones property (C1P) if its columns can be permuted such that the 1s in each row of the resulting matrix are consecutive. Equivalently, a family of setsF = {Q1,...,Qm}, where Qi ⊆ R for some universe R, satisfies the C1P if the symbols in R can be permuted such that the elements of each set Qi ∈ F occur consecutively, as a contiguous segment of the permutation of R’s symbols. Motivated by combinatorial problems on sequences with repeated symbols, we consider the C1P version on multisets and prove that counting the orderings (permutations) thus generated is #P-complete. We prove completeness results also for counting the permutations generated by PQ-trees (which are related to the C1P), thus showing that a polynomial-time algorithm is unlikely to exist when dealing with multisets and sequences with repeated symbols.
Roberto Grossi;Counting the Orderings for Multisets in Consecutive Ones Property and PQ-Trees.;Giovanni Battaglia, Noemi Scutellà;[<span itemprop="pagination">58-69</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_6;A binary matrix satisfies the consecutive ones property (C1P) if its columns can be permuted such that the 1s in each row of the resulting matrix are consecutive. Equivalently, a family of setsF = {Q1,...,Qm}, where Qi ⊆ R for some universe R, satisfies the C1P if the symbols in R can be permuted such that the elements of each set Qi ∈ F occur consecutively, as a contiguous segment of the permutation of R’s symbols. Motivated by combinatorial problems on sequences with repeated symbols, we consider the C1P version on multisets and prove that counting the orderings (permutations) thus generated is #P-complete. We prove completeness results also for counting the permutations generated by PQ-trees (which are related to the C1P), thus showing that a polynomial-time algorithm is unlikely to exist when dealing with multisets and sequences with repeated symbols.
Noemi Scutellà;Counting the Orderings for Multisets in Consecutive Ones Property and PQ-Trees.;Giovanni Battaglia, Roberto Grossi;[<span itemprop="pagination">58-69</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_6;A binary matrix satisfies the consecutive ones property (C1P) if its columns can be permuted such that the 1s in each row of the resulting matrix are consecutive. Equivalently, a family of setsF = {Q1,...,Qm}, where Qi ⊆ R for some universe R, satisfies the C1P if the symbols in R can be permuted such that the elements of each set Qi ∈ F occur consecutively, as a contiguous segment of the permutation of R’s symbols. Motivated by combinatorial problems on sequences with repeated symbols, we consider the C1P version on multisets and prove that counting the orderings (permutations) thus generated is #P-complete. We prove completeness results also for counting the permutations generated by PQ-trees (which are related to the C1P), thus showing that a polynomial-time algorithm is unlikely to exist when dealing with multisets and sequences with repeated symbols.
Francine Blanchet-Sadri;Avoiding Abelian Powers in Partial Words.;Sean Simmons;[<span itemprop="pagination">70-81</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_7;We study abelian repetitions in partial words, or sequences that may contain some unknown positions or holes. First, we look at the avoidance of abelian pth powers in infinite partial words, where p &gt. 2, extending recent results regarding the case where p = 2. We investigate, for a given p, the smallest alphabet size needed to construct an infinite partial word with finitely or infinitely many holes that avoids abelian pth powers. We construct in particular an infinite binary partial word with infinitely many holes that avoids 6th powers. Then we show, in a number of cases, that the number of abelian p-free partial words of length n with h holes over a given alphabet grows exponentially as n increases. Finally, we prove that we cannot avoid abelian pth powers under arbitrary insertion of holes in an infinite word.
Sean Simmons;Avoiding Abelian Powers in Partial Words.;Francine Blanchet-Sadri;[<span itemprop="pagination">70-81</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_7;We study abelian repetitions in partial words, or sequences that may contain some unknown positions or holes. First, we look at the avoidance of abelian pth powers in infinite partial words, where p &gt. 2, extending recent results regarding the case where p = 2. We investigate, for a given p, the smallest alphabet size needed to construct an infinite partial word with finitely or infinitely many holes that avoids abelian pth powers. We construct in particular an infinite binary partial word with infinitely many holes that avoids 6th powers. Then we show, in a number of cases, that the number of abelian p-free partial words of length n with h holes over a given alphabet grows exponentially as n increases. Finally, we prove that we cannot avoid abelian pth powers under arbitrary insertion of holes in an infinite word.
Paola Bonizzoni;Regular Splicing Languages Must Have a Constant.;Natasha Jonoska;[<span itemprop="pagination">82-92</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_8;In spite of wide investigations of finite splicing systems in formal language theory, basic questions, such as their characterization, remain unsolved. In search for understanding the class of finite splicing systems, it has been conjectured that a necessary condition for a regular language L to be a splicing language is that L must have a constant in the Schützenberger’s sense. We prove this longstanding conjecture to be true. The result is based on properties of strongly connected components of the minimal deterministic finite state automaton for a regular splicing language.
Natasha Jonoska;Regular Splicing Languages Must Have a Constant.;Paola Bonizzoni;[<span itemprop="pagination">82-92</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_8;In spite of wide investigations of finite splicing systems in formal language theory, basic questions, such as their characterization, remain unsolved. In search for understanding the class of finite splicing systems, it has been conjectured that a necessary condition for a regular language L to be a splicing language is that L must have a constant in the Schützenberger’s sense. We prove this longstanding conjecture to be true. The result is based on properties of strongly connected components of the minimal deterministic finite state automaton for a regular splicing language.
Sabine Broda;The Average Transition Complexity of Glushkov and Partial Derivative Automata.;António Machiavelo, Nelma Moreira, Rogério Reis;[<span itemprop="pagination">93-104</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_9;In this paper, the relation between the Glushkov automaton (\(\mathcal{A}_{\mathrm{pos}}\)) and the partial derivative automaton (\(\mathcal{A}_{\mathrm{pd}}\)) of a given regular expression, in terms of transition complexity, is studied. The average transition complexity of \(\mathcal{A}_{\mathrm{pos}}\) was proved by Nicaud to be linear in the size of the corresponding expression. This result was obtained using an upper bound of the number of transitions of \(\mathcal{A}_{\mathrm{pos}}\). Here we present a new quadratic construction of \(\mathcal{A}_{\mathrm{pos}}\) that leads to a more elegant and straightforward implementation, and that allows the exact counting of the number of transitions. Based on that, a better estimation of the average size is presented. Asymptotically, and as the alphabet size grows, the number of transitions per state is on average 2.
António Machiavelo;The Average Transition Complexity of Glushkov and Partial Derivative Automata.;Sabine Broda, Nelma Moreira, Rogério Reis;[<span itemprop="pagination">93-104</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_9;In this paper, the relation between the Glushkov automaton (\(\mathcal{A}_{\mathrm{pos}}\)) and the partial derivative automaton (\(\mathcal{A}_{\mathrm{pd}}\)) of a given regular expression, in terms of transition complexity, is studied. The average transition complexity of \(\mathcal{A}_{\mathrm{pos}}\) was proved by Nicaud to be linear in the size of the corresponding expression. This result was obtained using an upper bound of the number of transitions of \(\mathcal{A}_{\mathrm{pos}}\). Here we present a new quadratic construction of \(\mathcal{A}_{\mathrm{pos}}\) that leads to a more elegant and straightforward implementation, and that allows the exact counting of the number of transitions. Based on that, a better estimation of the average size is presented. Asymptotically, and as the alphabet size grows, the number of transitions per state is on average 2.
Nelma Moreira;The Average Transition Complexity of Glushkov and Partial Derivative Automata.;Sabine Broda, António Machiavelo, Rogério Reis;[<span itemprop="pagination">93-104</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_9;In this paper, the relation between the Glushkov automaton (\(\mathcal{A}_{\mathrm{pos}}\)) and the partial derivative automaton (\(\mathcal{A}_{\mathrm{pd}}\)) of a given regular expression, in terms of transition complexity, is studied. The average transition complexity of \(\mathcal{A}_{\mathrm{pos}}\) was proved by Nicaud to be linear in the size of the corresponding expression. This result was obtained using an upper bound of the number of transitions of \(\mathcal{A}_{\mathrm{pos}}\). Here we present a new quadratic construction of \(\mathcal{A}_{\mathrm{pos}}\) that leads to a more elegant and straightforward implementation, and that allows the exact counting of the number of transitions. Based on that, a better estimation of the average size is presented. Asymptotically, and as the alphabet size grows, the number of transitions per state is on average 2.
Rogério Reis;The Average Transition Complexity of Glushkov and Partial Derivative Automata.;Sabine Broda, António Machiavelo, Nelma Moreira;[<span itemprop="pagination">93-104</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_9;In this paper, the relation between the Glushkov automaton (\(\mathcal{A}_{\mathrm{pos}}\)) and the partial derivative automaton (\(\mathcal{A}_{\mathrm{pd}}\)) of a given regular expression, in terms of transition complexity, is studied. The average transition complexity of \(\mathcal{A}_{\mathrm{pos}}\) was proved by Nicaud to be linear in the size of the corresponding expression. This result was obtained using an upper bound of the number of transitions of \(\mathcal{A}_{\mathrm{pos}}\). Here we present a new quadratic construction of \(\mathcal{A}_{\mathrm{pos}}\) that leads to a more elegant and straightforward implementation, and that allows the exact counting of the number of transitions. Based on that, a better estimation of the average size is presented. Asymptotically, and as the alphabet size grows, the number of transitions per state is on average 2.
Janusz A. Brzozowski;Theory of Átomata.;Hellis Tamm;[<span itemprop="pagination">105-116</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_10;We show that every regular language defines a unique nondeterministic finite automaton (NFA), which we call “átomaton”, whose states are the “atoms” of the language, that is, non-empty intersections of complemented or uncomplemented left quotients of the language. We describe methods of constructing the átomaton, and prove that it is isomorphic to the normal automaton of Sengoku, and to an automaton of Matz and Potthoff. We study “atomic” NFA’s in which the right language of every state is a union of atoms. We generalize Brzozowski’s double-reversal method for minimizing a deterministic finite automaton (DFA), showing that the result of applying the subset construction to an NFA is a minimal DFA if and only if the reverse of the NFA is atomic.
Hellis Tamm;Theory of Átomata.;Janusz A. Brzozowski;[<span itemprop="pagination">105-116</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_10;We show that every regular language defines a unique nondeterministic finite automaton (NFA), which we call “átomaton”, whose states are the “atoms” of the language, that is, non-empty intersections of complemented or uncomplemented left quotients of the language. We describe methods of constructing the átomaton, and prove that it is isomorphic to the normal automaton of Sengoku, and to an automaton of Matz and Potthoff. We study “atomic” NFA’s in which the right language of every state is a union of atoms. We generalize Brzozowski’s double-reversal method for minimizing a deterministic finite automaton (DFA), showing that the result of applying the subset construction to an NFA is a minimal DFA if and only if the reverse of the NFA is atomic.
Janusz A. Brzozowski;Syntactic Complexity of Ideal and Closed Languages.;Yuli Ye;[<span itemprop="pagination">117-128</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_11;The state complexity of a regular language is the number of states in the minimal deterministic automaton accepting the language. The syntactic complexity of a regular language is the cardinality of its syntactic semigroup. The syntactic complexity of a subclass of regular languages is the worst-case syntactic complexity taken as a function of the state complexity n of languages in that class. We prove that nn − 1 is a tight upper bound on the complexity of right ideals and prefix-closed languages, and that there exist left ideals and suffix-closed languages of syntactic complexity nn − 1 + n − 1, and two-sided ideals and factor-closed languages of syntactic complexity nn − 2 + (n − 2)2n − 2 + 1.
Yuli Ye;Syntactic Complexity of Ideal and Closed Languages.;Janusz A. Brzozowski;[<span itemprop="pagination">117-128</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_11;The state complexity of a regular language is the number of states in the minimal deterministic automaton accepting the language. The syntactic complexity of a regular language is the cardinality of its syntactic semigroup. The syntactic complexity of a subclass of regular languages is the worst-case syntactic complexity taken as a function of the state complexity n of languages in that class. We prove that nn − 1 is a tight upper bound on the complexity of right ideals and prefix-closed languages, and that there exist left ideals and suffix-closed languages of syntactic complexity nn − 1 + n − 1, and two-sided ideals and factor-closed languages of syntactic complexity nn − 2 + (n − 2)2n − 2 + 1.
Pascal Caron;Generalized One-Unambiguity.;Yo-Sub Han, Ludovic Mignot;[<span itemprop="pagination">129-140</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_12;Brüggemann-Klein and Wood have introduced a new family of regular languages, the one-unambiguous regular languages, a very important notion in XML DTDs. A regular language L is one-unambiguous if and only if there exists a regular expression E over the operators of sum, catenation and Kleene star such that L(E) = L and the position automaton of E is deterministic. It implies that for a one-unambiguous expression, there exists an equivalent linear-size deterministic recognizer. In this paper, we extend the notion of one-unambiguity to weak one-unambiguity over regular expressions using the complement operator ¬. We show that a DFA with at most (n + 2) states can be computed from a weakly one-unambiguous expression and that it is decidable whether or not a given DFA recognizes a weakly one-unambiguous language.
Yo-Sub Han;Generalized One-Unambiguity.;Pascal Caron, Ludovic Mignot;[<span itemprop="pagination">129-140</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_12;Brüggemann-Klein and Wood have introduced a new family of regular languages, the one-unambiguous regular languages, a very important notion in XML DTDs. A regular language L is one-unambiguous if and only if there exists a regular expression E over the operators of sum, catenation and Kleene star such that L(E) = L and the position automaton of E is deterministic. It implies that for a one-unambiguous expression, there exists an equivalent linear-size deterministic recognizer. In this paper, we extend the notion of one-unambiguity to weak one-unambiguity over regular expressions using the complement operator ¬. We show that a DFA with at most (n + 2) states can be computed from a weakly one-unambiguous expression and that it is decidable whether or not a given DFA recognizes a weakly one-unambiguous language.
Ludovic Mignot;Generalized One-Unambiguity.;Pascal Caron, Yo-Sub Han;[<span itemprop="pagination">129-140</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_12;Brüggemann-Klein and Wood have introduced a new family of regular languages, the one-unambiguous regular languages, a very important notion in XML DTDs. A regular language L is one-unambiguous if and only if there exists a regular expression E over the operators of sum, catenation and Kleene star such that L(E) = L and the position automaton of E is deterministic. It implies that for a one-unambiguous expression, there exists an equivalent linear-size deterministic recognizer. In this paper, we extend the notion of one-unambiguity to weak one-unambiguity over regular expressions using the complement operator ¬. We show that a DFA with at most (n + 2) states can be computed from a weakly one-unambiguous expression and that it is decidable whether or not a given DFA recognizes a weakly one-unambiguous language.
Gérard Cécé;Simulations over Two-Dimensional On-Line Tessellation Automata.;Alain Giorgetti;[<span itemprop="pagination">141-152</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_13;We study the notion of simulation over a class of automata which recognize 2D languages (languages of arrays of letters). This class of two-dimensional On-line Tessellation Automata (2OTA) accepts the same class of languages as the class of tiling systems, considered as the natural extension of classical regular word languages to the 2D case. We prove that simulation over 2OTA implies language inclusion. Even if the existence of a simulation relation between two 2OTA is shown to be a NP-complete problem in time, this is an important result since the inclusion problem is undecidable in general in this class of languages. Then we prove the existence of a unique maximal autosimulation relation in a given 2OTA and the existence of a unique minimal 2OTA which is simulation equivalent to this given 2OTA, both computable in polynomial time.
Alain Giorgetti;Simulations over Two-Dimensional On-Line Tessellation Automata.;Gérard Cécé;[<span itemprop="pagination">141-152</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_13;We study the notion of simulation over a class of automata which recognize 2D languages (languages of arrays of letters). This class of two-dimensional On-line Tessellation Automata (2OTA) accepts the same class of languages as the class of tiling systems, considered as the natural extension of classical regular word languages to the 2D case. We prove that simulation over 2OTA implies language inclusion. Even if the existence of a simulation relation between two 2OTA is shown to be a NP-complete problem in time, this is an important result since the inclusion problem is undecidable in general in this class of languages. Then we prove the existence of a unique maximal autosimulation relation in a given 2OTA and the existence of a unique minimal 2OTA which is simulation equivalent to this given 2OTA, both computable in polynomial time.
Peter Cerno;Δ-Clearing Restarting Automata and CFL \makebox{\sf CFL}.;Frantisek Mráz;[<span itemprop="pagination">153-164</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_14;Δ-clearing restarting automata represent a new restricted model of restarting automata which, based on a limited context, can either delete a substring of the current content of its tape or replace a substring by a special auxiliary symbol Δ, which cannot be overwritten anymore, but it can be deleted later. The main result of this paper consists in proving that besides their limited operations, Δ-clearing restarting automata recognize all context-free languages.
Frantisek Mráz;Δ-Clearing Restarting Automata and CFL \makebox{\sf CFL}.;Peter Cerno;[<span itemprop="pagination">153-164</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_14;Δ-clearing restarting automata represent a new restricted model of restarting automata which, based on a limited context, can either delete a substring of the current content of its tape or replace a substring by a special auxiliary symbol Δ, which cannot be overwritten anymore, but it can be deleted later. The main result of this paper consists in proving that besides their limited operations, Δ-clearing restarting automata recognize all context-free languages.
Emilie Charlier;Enumeration and Decidable Properties of Automatic Sequences.;Narad Rampersad, Jeffrey O. Shallit;[<span itemprop="pagination">165-179</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_15;We show that various aspects of k-automatic sequences — such as having an unbordered factor of length n — are both decidable and effectively enumerable. As a consequence it follows that many related sequences are either k-automatic or k-regular. These include many sequences previously studied in the literature, such as the recurrence function, the appearance function, and the repetitivity index. We also give a new characterization of the class of k-regular sequences. Many results extend to other sequences defined in terms of Pisot numeration systems.
Narad Rampersad;Enumeration and Decidable Properties of Automatic Sequences.;Emilie Charlier, Jeffrey O. Shallit;[<span itemprop="pagination">165-179</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_15;We show that various aspects of k-automatic sequences — such as having an unbordered factor of length n — are both decidable and effectively enumerable. As a consequence it follows that many related sequences are either k-automatic or k-regular. These include many sequences previously studied in the literature, such as the recurrence function, the appearance function, and the repetitivity index. We also give a new characterization of the class of k-regular sequences. Many results extend to other sequences defined in terms of Pisot numeration systems.
Jeffrey O. Shallit;Enumeration and Decidable Properties of Automatic Sequences.;Emilie Charlier, Narad Rampersad;[<span itemprop="pagination">165-179</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_15;We show that various aspects of k-automatic sequences — such as having an unbordered factor of length n — are both decidable and effectively enumerable. As a consequence it follows that many related sequences are either k-automatic or k-regular. These include many sequences previously studied in the literature, such as the recurrence function, the appearance function, and the repetitivity index. We also give a new characterization of the class of k-regular sequences. Many results extend to other sequences defined in terms of Pisot numeration systems.
Namit Chaturvedi;None;Jörg Olschewski, Wolfgang Thomas;[<span itemprop="pagination">180-191</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_16;Infinite games are studied in a format where two players, called Player 1 and Player 2, generate a play by building up an ω-word as they choose letters in turn. A game is specified by the ω-language which contains the plays won by Player 2. We analyze ω-languages generated from certain classes \({\cal K}\) of regular languages of finite words (called *-languages), using natural transformations of *-languages into ω-languages. Winning strategies for infinite games can be represented again in terms of *-languages. Continuing work of Selivanov (2007) and Rabinovich et al. (2007), we analyze how these “strategy *-languages” are related to the original language class \({\cal K}\). In contrast to that work, we exhibit classes \({\cal K}\) where strategy representations strictly exceed \({\cal K}\).
Jörg Olschewski;None;Namit Chaturvedi, Wolfgang Thomas;[<span itemprop="pagination">180-191</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_16;Infinite games are studied in a format where two players, called Player 1 and Player 2, generate a play by building up an ω-word as they choose letters in turn. A game is specified by the ω-language which contains the plays won by Player 2. We analyze ω-languages generated from certain classes \({\cal K}\) of regular languages of finite words (called *-languages), using natural transformations of *-languages into ω-languages. Winning strategies for infinite games can be represented again in terms of *-languages. Continuing work of Selivanov (2007) and Rabinovich et al. (2007), we analyze how these “strategy *-languages” are related to the original language class \({\cal K}\). In contrast to that work, we exhibit classes \({\cal K}\) where strategy representations strictly exceed \({\cal K}\).
Wolfgang Thomas;None;Namit Chaturvedi, Jörg Olschewski;[<span itemprop="pagination">180-191</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_16;Infinite games are studied in a format where two players, called Player 1 and Player 2, generate a play by building up an ω-word as they choose letters in turn. A game is specified by the ω-language which contains the plays won by Player 2. We analyze ω-languages generated from certain classes \({\cal K}\) of regular languages of finite words (called *-languages), using natural transformations of *-languages into ω-languages. Winning strategies for infinite games can be represented again in terms of *-languages. Continuing work of Selivanov (2007) and Rabinovich et al. (2007), we analyze how these “strategy *-languages” are related to the original language class \({\cal K}\). In contrast to that work, we exhibit classes \({\cal K}\) where strategy representations strictly exceed \({\cal K}\).
Volker Diekert;Solving Word Problems in Group Extensions over Infinite Words.;Alexei G. Myasnikov;[<span itemprop="pagination">192-203</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_17;Non-Archimedean words have been introduced as a new type of infinite words which can be investigated through classical methods in combinatorics on words due to a length function. The length function, however, takes values in the additive group of polynomials ℤ[t] (and not, as traditionally, in ℕ), which yields various new properties. Non-Archimedean words allow to solve a number of algorithmic problems in geometric and algorithmic group theory. There is a connection to the first-order theory in free groups (Tarski Problems), too.
Alexei G. Myasnikov;Solving Word Problems in Group Extensions over Infinite Words.;Volker Diekert;[<span itemprop="pagination">192-203</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_17;Non-Archimedean words have been introduced as a new type of infinite words which can be investigated through classical methods in combinatorics on words due to a length function. The length function, however, takes values in the additive group of polynomials ℤ[t] (and not, as traditionally, in ℕ), which yields various new properties. Non-Archimedean words allow to solve a number of algorithmic problems in geometric and algorithmic group theory. There is a connection to the first-order theory in free groups (Tarski Problems), too.
Michael Domaratzki;Abelian Primitive Words.;Narad Rampersad;[<span itemprop="pagination">204-215</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_18;We investigate Abelian primitive words, which are words that are not Abelian powers. We show the set of Abelian primitive words is not context-free. We can determine whether a word is Abelian primitive in linear time. Also different from classical primitive words, we find that a word may have more than one Abelian root. We also consider enumeration of Abelian primitive words.
Narad Rampersad;Abelian Primitive Words.;Michael Domaratzki;[<span itemprop="pagination">204-215</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_18;We investigate Abelian primitive words, which are words that are not Abelian powers. We show the set of Abelian primitive words is not context-free. We can determine whether a word is Abelian primitive in linear time. Also different from classical primitive words, we find that a word may have more than one Abelian root. We also consider enumeration of Abelian primitive words.
Zoltán Ésik;Scattered Context-Free Linear Orderings.;;[<span itemprop="pagination">216-227</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_19;We show that it is decidable in exponential time whether the lexicographic ordering of a context-free language is scattered, or a well-ordering.
Gabriele Fici;On Prefix Normal Words.;Zsuzsanna Lipták;[<span itemprop="pagination">228-238</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_20;We present a new class of binary words: the prefix normal words. They are defined by the property that for any given length k, no factor of length k has more a’s than the prefix of the same length. These words arise in the context of indexing for jumbled pattern matching (a.k.a. permutation matching or Parikh vector matching), where the aim is to decide whether a string has a factor with a given multiplicity of characters, i.e., with a given Parikh vector. Using prefix normal words, we give the first non-trivial characterization of binary words having the same set of Parikh vectors of factors. We prove that the language of prefix normal words is not context-free and is strictly contained in the language of pre-necklaces, which are prefixes of powers of Lyndon words. We discuss further properties and state open problems.
Zsuzsanna Lipták;On Prefix Normal Words.;Gabriele Fici;[<span itemprop="pagination">228-238</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_20;We present a new class of binary words: the prefix normal words. They are defined by the property that for any given length k, no factor of length k has more a’s than the prefix of the same length. These words arise in the context of indexing for jumbled pattern matching (a.k.a. permutation matching or Parikh vector matching), where the aim is to decide whether a string has a factor with a given multiplicity of characters, i.e., with a given Parikh vector. Using prefix normal words, we give the first non-trivial characterization of binary words having the same set of Parikh vectors of factors. We prove that the language of prefix normal words is not context-free and is strictly contained in the language of pre-necklaces, which are prefixes of powers of Lyndon words. We discuss further properties and state open problems.
Vladimir V. Gusev;On Non-complete Sets and Restivo's Conjecture.;Elena V. Pribavkina;[<span itemprop="pagination">239-250</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_21;A finite set S of words over the alphabet Σ is called non-complete if \(\textit{Fact}(S^*)\ne\Sigma^*\). A word \(w\in\Sigma^*\setminus\textit{Fact}(S^*)\) is said to be uncompletable. We present a series of non-complete sets Sk whose minimal uncompletable words have length 5k2 − 17k + 13, where k ≥ 4 is the maximal length of words in Sk. This is an infinite series of counterexamples to Restivo’s conjecture, which states that any non-complete set possesses an uncompletable word of length at most 2k2.
Elena V. Pribavkina;On Non-complete Sets and Restivo's Conjecture.;Vladimir V. Gusev;[<span itemprop="pagination">239-250</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_21;A finite set S of words over the alphabet Σ is called non-complete if \(\textit{Fact}(S^*)\ne\Sigma^*\). A word \(w\in\Sigma^*\setminus\textit{Fact}(S^*)\) is said to be uncompletable. We present a series of non-complete sets Sk whose minimal uncompletable words have length 5k2 − 17k + 13, where k ≥ 4 is the maximal length of words in Sk. This is an infinite series of counterexamples to Restivo’s conjecture, which states that any non-complete set possesses an uncompletable word of length at most 2k2.
Benjamin Hellouin de Menibus;Self-organization in Cellular Automata: A Particle-Based Approach.;Mathieu Sablik;[<span itemprop="pagination">251-263</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_22;For some classes of cellular automata, we observe empirically a phenomenon of self-organization: starting from a random configuration, regular strips separated by defects appear in the space-time diagram. When there is no creation of defects, all defects have the same direction after some time. In this article, we propose to formalise this phenomenon. Starting from the notion of propagation of defect by a cellular automaton formalized in [Piv07b, Piv07a], we show that, when iterating the automaton on a random configuration, defects in one direction only remain asymptotically.
Mathieu Sablik;Self-organization in Cellular Automata: A Particle-Based Approach.;Benjamin Hellouin de Menibus;[<span itemprop="pagination">251-263</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_22;For some classes of cellular automata, we observe empirically a phenomenon of self-organization: starting from a random configuration, regular strips separated by defects appear in the space-time diagram. When there is no creation of defects, all defects have the same direction after some time. In this article, we propose to formalise this phenomenon. Starting from the notion of propagation of defect by a cellular automaton formalized in [Piv07b, Piv07a], we show that, when iterating the automaton on a random configuration, defects in one direction only remain asymptotically.
Markus Holzer;Chop Operations and Expressions: Descriptional Complexity Considerations.;Sebastian Jakobi;[<span itemprop="pagination">264-275</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_23;The chop or fusion operation was recently introduced in [S. A. Babu, P. K. Pandya: Chop Expressions and Discrete Duration Calculus. Modern Applications of Automata Theory, World Scientific, 2010], where a characterization of regular languages in terms of chop expressions was shown. Simply speaking, the chop or fusion of two words is a concatenation were the touching letters are coalesced, if both letters are equal. otherwise the operation is undefined. We investigate the descriptional complexity of the chop operation and its iteration for deterministic and nondeterministic finite automata as well as for regular expressions. In most cases tight bounds are shown. Moreover, we also consider the conversion problem between finite automata, regular expressions, and chop expressions. Again, for most conversions we get tight bounds in order of magnitude. It is worth mentioning that regular expressions can be transformed into equivalent chop expressions of polynomial size, but chop expressions can be exponentially more succinct than regular expressions.
Sebastian Jakobi;Chop Operations and Expressions: Descriptional Complexity Considerations.;Markus Holzer;[<span itemprop="pagination">264-275</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_23;The chop or fusion operation was recently introduced in [S. A. Babu, P. K. Pandya: Chop Expressions and Discrete Duration Calculus. Modern Applications of Automata Theory, World Scientific, 2010], where a characterization of regular languages in terms of chop expressions was shown. Simply speaking, the chop or fusion of two words is a concatenation were the touching letters are coalesced, if both letters are equal. otherwise the operation is undefined. We investigate the descriptional complexity of the chop operation and its iteration for deterministic and nondeterministic finite automata as well as for regular expressions. In most cases tight bounds are shown. Moreover, we also consider the conversion problem between finite automata, regular expressions, and chop expressions. Again, for most conversions we get tight bounds in order of magnitude. It is worth mentioning that regular expressions can be transformed into equivalent chop expressions of polynomial size, but chop expressions can be exponentially more succinct than regular expressions.
Markus Holzer;Nodes Connected by Path Languages.;Martin Kutrib, Ursula Leiter;[<span itemprop="pagination">276-287</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_24;We investigate reachability problems on different types of labeled graphs constrained to formal languages from a family \(\mathcal{L}\). If every language in \(\mathcal{L}\) is accepted by a one-way nondeterministic storage automaton, then we give an appealing characterization of the computational complexity of the labeled graph reachability problem in terms of two-way nondeterministic storage automata with auxiliary worktape that is logarithmic-space bounded. Moreover, we also consider acyclic graphs in the underlying reachability instance, obtaining a lower bound result for auxiliary storage automata that are simultaneously space and time restricted.
Martin Kutrib;Nodes Connected by Path Languages.;Markus Holzer, Ursula Leiter;[<span itemprop="pagination">276-287</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_24;We investigate reachability problems on different types of labeled graphs constrained to formal languages from a family \(\mathcal{L}\). If every language in \(\mathcal{L}\) is accepted by a one-way nondeterministic storage automaton, then we give an appealing characterization of the computational complexity of the labeled graph reachability problem in terms of two-way nondeterministic storage automata with auxiliary worktape that is logarithmic-space bounded. Moreover, we also consider acyclic graphs in the underlying reachability instance, obtaining a lower bound result for auxiliary storage automata that are simultaneously space and time restricted.
Ursula Leiter;Nodes Connected by Path Languages.;Markus Holzer, Martin Kutrib;[<span itemprop="pagination">276-287</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_24;We investigate reachability problems on different types of labeled graphs constrained to formal languages from a family \(\mathcal{L}\). If every language in \(\mathcal{L}\) is accepted by a one-way nondeterministic storage automaton, then we give an appealing characterization of the computational complexity of the labeled graph reachability problem in terms of two-way nondeterministic storage automata with auxiliary worktape that is logarithmic-space bounded. Moreover, we also consider acyclic graphs in the underlying reachability instance, obtaining a lower bound result for auxiliary storage automata that are simultaneously space and time restricted.
Norbert Hundeshagen;Characterizing the Regular Languages by Nonforgetting Restarting Automata.;Friedrich Otto;[<span itemprop="pagination">288-299</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_25;We study nonforgetting R- and nonforgetting deterministic RR-automata of window size one, that is, nf-R(1)- and det-nf-RR(1)-automata. Our main result shows that the monotone variants of these two types of restarting automata characterize the regular languages. On the other hand, we prove that already the non-monotone deterministic nonforgetting R(1)-automata accept a class of languages that is incomparable to the class of semi-linear languages with respect to inclusion, but that properly includes the class of languages that are accepted by globally deterministic cooperating distributed systems of stateless deterministic R(1)-automata.
Friedrich Otto;Characterizing the Regular Languages by Nonforgetting Restarting Automata.;Norbert Hundeshagen;[<span itemprop="pagination">288-299</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_25;We study nonforgetting R- and nonforgetting deterministic RR-automata of window size one, that is, nf-R(1)- and det-nf-RR(1)-automata. Our main result shows that the monotone variants of these two types of restarting automata characterize the regular languages. On the other hand, we prove that already the non-monotone deterministic nonforgetting R(1)-automata accept a class of languages that is incomparable to the class of semi-linear languages with respect to inclusion, but that properly includes the class of languages that are accepted by globally deterministic cooperating distributed systems of stateless deterministic R(1)-automata.
Oscar H. Ibarra;On Two-Way Transducers.;Hsu-Chun Yen;[<span itemprop="pagination">300-311</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_26;We look at some classes of two-way transducers with auxiliary memory and investigate their containment and equivalence problems. We believe that our results are the strongest known to date concerning two-way transducers.
Hsu-Chun Yen;On Two-Way Transducers.;Oscar H. Ibarra;[<span itemprop="pagination">300-311</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_26;We look at some classes of two-way transducers with auxiliary memory and investigate their containment and equivalence problems. We believe that our results are the strongest known to date concerning two-way transducers.
Juha Kortelainen;There Does Not Exist a Minimal Full Trio with Respect to Bounded Context-Free Languages.;Tuukka Salmi;[<span itemprop="pagination">312-323</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_27;We solve an old conjecture of Autebert et al. [1] saying that there does not exist any minimal full trio with respect to bounded context-free languages.
Tuukka Salmi;There Does Not Exist a Minimal Full Trio with Respect to Bounded Context-Free Languages.;Juha Kortelainen;[<span itemprop="pagination">312-323</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_27;We solve an old conjecture of Autebert et al. [1] saying that there does not exist any minimal full trio with respect to bounded context-free languages.
Michal Kunc;Describing Periodicity in Two-Way Deterministic Finite Automata Using Transformation Semigroups.;Alexander Okhotin;[<span itemprop="pagination">324-336</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_28;A framework for the study of periodic behaviour of two-way deterministic finite automata (2DFA) is developed. Computations of 2DFAs are represented by a two-way analogue of transformation semigroups, every element of which describes the behaviour of a 2DFA on a certain string x. A subsemigroup generated by this element represents the behaviour on strings in x + . The main contribution of this paper is a description of all such monogenic subsemigroups up to isomorphism. This characterization is then used to show that transforming an n-state 2DFA over a one-letter alphabet to an equivalent sweeping 2DFA requires exactly n + 1 states, and transforming it to a one-way automaton requires exactly \(\max_{0 \leqslant \ell \leqslant n} G(n-\ell)+\ell+1\) states, where G(k) is the maximum order of a permutation of k elements.
Alexander Okhotin;Describing Periodicity in Two-Way Deterministic Finite Automata Using Transformation Semigroups.;Michal Kunc;[<span itemprop="pagination">324-336</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_28;A framework for the study of periodic behaviour of two-way deterministic finite automata (2DFA) is developed. Computations of 2DFAs are represented by a two-way analogue of transformation semigroups, every element of which describes the behaviour of a 2DFA on a certain string x. A subsemigroup generated by this element represents the behaviour on strings in x + . The main contribution of this paper is a description of all such monogenic subsemigroups up to isomorphism. This characterization is then used to show that transforming an n-state 2DFA over a one-letter alphabet to an equivalent sweeping 2DFA requires exactly n + 1 states, and transforming it to a one-way automaton requires exactly \(\max_{0 \leqslant \ell \leqslant n} G(n-\ell)+\ell+1\) states, where G(k) is the maximum order of a permutation of k elements.
Florin Manea;Deciding Networks of Evolutionary Processors.;;[<span itemprop="pagination">337-349</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_29;In this paper we discuss the usage of Accepting Networks of Evolutionary Processors (ANEPs for short) as deciding devices. In this context we define a new halting condition for this model, which seems more coherent with the rest of the theory than the previous such definition, and show that all the computability results reported so far remain valid in the new framework. Moreover, we give a direct and efficient simulation of an arbitrary ANEP by a complete ANEP, thus, showing that the efficiency of deciding a language by ANEPs is not influenced by the network’s topology. Finally, we obtain a surprising characterization of PNP[log] as the class of languages that can be decided in polynomial time by ANEPs.
Roberto Mantaci;From Linear Partitions to Parallelogram Polyominoes.;Paolo Massazza;[<span itemprop="pagination">350-361</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_30;We provide a bijection between parallelogram polyominoes and suitable pairs of linear partitions. This lets us design a CAT (Constant Amortized Time) algorithm for generating all parallelogram polyominoes of size n using \(O(\sqrt n)\) space.
Paolo Massazza;From Linear Partitions to Parallelogram Polyominoes.;Roberto Mantaci;[<span itemprop="pagination">350-361</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_30;We provide a bijection between parallelogram polyominoes and suitable pairs of linear partitions. This lets us design a CAT (Constant Amortized Time) algorithm for generating all parallelogram polyominoes of size n using \(O(\sqrt n)\) space.
Andrey N. Plyushchenko;None;Arseny M. Shur;[<span itemprop="pagination">362-373</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_31;In this paper we examine Brzozowski’s conjecture for the two-generated free Burnside semigroup satisfying x2 = x3. The elements of this semigroup are classes of equivalent words, and the conjecture claims that all elements are regular languages. The case of the identity x2 = x3 is the only one, for which Brzozowski’s conjecture is neither proved nor disproved. We prove the conjecture for all the elements containing an overlap-free or an “almost” overlap-free word. In addition, we show that all but finitely many of these elements are “big” languages in terms of growth rate.
Arseny M. Shur;None;Andrey N. Plyushchenko;[<span itemprop="pagination">362-373</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_31;In this paper we examine Brzozowski’s conjecture for the two-generated free Burnside semigroup satisfying x2 = x3. The elements of this semigroup are classes of equivalent words, and the conjecture claims that all elements are regular languages. The case of the identity x2 = x3 is the only one, for which Brzozowski’s conjecture is neither proved nor disproved. We prove the conjecture for all the elements containing an overlap-free or an “almost” overlap-free word. In addition, we show that all but finitely many of these elements are “big” languages in terms of growth rate.
Emanuele Rodaro;Never Minimal Automata and the Rainbow Bipartite Subgraph Problem.;Pedro V. Silva;[<span itemprop="pagination">374-385</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_32;Never minimal automata, introduced in [4], are strongly connected automata which are not minimal for any choice of their final states. In [4] the authors raise the question whether recognizing such automata is a polynomial time task or not. In this paper, we show that the complement of this problem is equivalent to the problem of checking whether or not in an edge-colored graph there is a bipartite subgraph whose edges are colored using all the colors. We prove that this graph theoretic problem is NP-complete, showing that checking the property of never-minimality is unlikely a polynomial time task.
Pedro V. Silva;Never Minimal Automata and the Rainbow Bipartite Subgraph Problem.;Emanuele Rodaro;[<span itemprop="pagination">374-385</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_32;Never minimal automata, introduced in [4], are strongly connected automata which are not minimal for any choice of their final states. In [4] the authors raise the question whether recognizing such automata is a polynomial time task or not. In this paper, we show that the complement of this problem is equivalent to the problem of checking whether or not in an edge-colored graph there is a bipartite subgraph whose edges are colored using all the colors. We prove that this graph theoretic problem is NP-complete, showing that checking the property of never-minimality is unlikely a polynomial time task.
Victor L. Selivanov;Boolean Algebras of Regular Languages.;Anton Konovalov;[<span itemprop="pagination">386-396</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_33;We characterize up to isomorphism the Boolean algebras of regular languages and of regular aperiodic languages, and show decidability of classes of regular languages related to these characterizations.
Anton Konovalov;Boolean Algebras of Regular Languages.;Victor L. Selivanov;[<span itemprop="pagination">386-396</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_33;We characterize up to isomorphism the Boolean algebras of regular languages and of regular aperiodic languages, and show decidability of classes of regular languages related to these characterizations.
Jeffrey O. Shallit;Fife's Theorem Revisited.;;[<span itemprop="pagination">397-405</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_34;We give another proof of a theorem of Fife — understood broadly as providing a finite automaton that gives a complete description of all infinite binary overlap-free words. Our proof is significantly simpler than those in the literature. As an application we give a complete characterization of the overlap-free words that are 2-automatic.
Edita Pelantová;Infinite Words Rich and Almost Rich in Generalized Palindromes.;Stepán Starosta;[<span itemprop="pagination">406-416</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_35;We focus on Θ-rich and almost Θ-rich words over a finite alphabet \(\mathcal{A}\), where Θ is an involutive antimorphism over \(\mathcal{A}^*\). We show that any recurrent almost Θ-rich word u is an image of a recurrent Θ′-rich word under a suitable morphism, where Θ′ is again an involutive antimorphism. Moreover, if the word u is uniformly recurrent, we show that Θ′ can be set to the reversal mapping. We also treat one special case of almost Θ-rich words. We show that every Θ-standard word with seed is an image of an Arnoux-Rauzy word.
Stepán Starosta;Infinite Words Rich and Almost Rich in Generalized Palindromes.;Edita Pelantová;[<span itemprop="pagination">406-416</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_35;We focus on Θ-rich and almost Θ-rich words over a finite alphabet \(\mathcal{A}\), where Θ is an involutive antimorphism over \(\mathcal{A}^*\). We show that any recurrent almost Θ-rich word u is an image of a recurrent Θ′-rich word under a suitable morphism, where Θ′ is again an involutive antimorphism. Moreover, if the word u is uniformly recurrent, we show that Θ′ can be set to the reversal mapping. We also treat one special case of almost Θ-rich words. We show that every Θ-standard word with seed is an image of an Arnoux-Rauzy word.
Nuri Tasdemir;Models of Pushdown Automata with Reset.;A. C. Cem Say;[<span itemprop="pagination">417-428</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_36;We examine various pushdown automaton variants that are architecturally intermediate between the one-way PDA and the two-way PDA (2PDA), where leftward moves of the input head can only reset it to the left end of the tape, and some component of the machine configuration may be “forgotten”, that is, reset to its initial value, whenever such a move is performed. Most of these model variants are shown to be equivalent in power to either the 2PDA or the one-way PDA. One exception is the Resettable Pushdown Automaton (RPDA), where the stack contents are lost every time the input is reset, and which we prove to be intermediate in power between the PDA and the 2PDA. We give full characterizations of the classes of languages recognized by both the deterministic and the nondeterministic versions of the RPDA.
A. C. Cem Say;Models of Pushdown Automata with Reset.;Nuri Tasdemir;[<span itemprop="pagination">417-428</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_36;We examine various pushdown automaton variants that are architecturally intermediate between the one-way PDA and the two-way PDA (2PDA), where leftward moves of the input head can only reset it to the left end of the tape, and some component of the machine configuration may be “forgotten”, that is, reset to its initial value, whenever such a move is performed. Most of these model variants are shown to be equivalent in power to either the 2PDA or the one-way PDA. One exception is the Resettable Pushdown Automaton (RPDA), where the stack contents are lost every time the input is reset, and which we prove to be intermediate in power between the PDA and the 2PDA. We give full characterizations of the classes of languages recognized by both the deterministic and the nondeterministic versions of the RPDA.
Ryo Yoshinaka;Towards Dual Approaches for Learning Context-Free Grammars Based on Syntactic Concept Lattices.;;[<span itemprop="pagination">429-440</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_37;Recent studies on grammatical inference have demonstrated the benefits of “distributional learning” for learning context-free and context-sensitive languages. Distributional learning models and exploits the relation between strings and contexts in the language of the learning target. There are two main approaches. One, which we call primal, constructs nonterminals whose language is characterized by strings. The other, which we call dual, uses contexts to characterize the language of a nonterminal of the conjecture grammar. This paper demonstrates and discusses the duality of those approaches by presenting some powerful learning algorithms along the way.
Narad Rampersad;On Highly Repetitive and Power Free Words.;Elise Vaslet;[<span itemprop="pagination">441-451</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_38;Answering a question of Richomme, Currie and Rampersad proved that 7/3 is the infimum of the real numbers α &gt. 2 such that there exists an infinite binary word that avoids α-powers but is highly 2-repetitive, i.e., contains arbitrarily large squares beginning at every position. In this paper, we prove similar statements about β-repetitive words, for some other β’s, on the binary and the ternary alphabets.
Elise Vaslet;On Highly Repetitive and Power Free Words.;Narad Rampersad;[<span itemprop="pagination">441-451</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_38;Answering a question of Richomme, Currie and Rampersad proved that 7/3 is the infimum of the real numbers α &gt. 2 such that there exists an infinite binary word that avoids α-powers but is highly 2-repetitive, i.e., contains arbitrarily large squares beginning at every position. In this paper, we prove similar statements about β-repetitive words, for some other β’s, on the binary and the ternary alphabets.
Georg Zetzsche;A Sufficient Condition for Erasing Productions to Be Avoidable.;;[<span itemprop="pagination">452-463</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_39;In each grammar model, it is an important question whether erasing productions are necessary to generate all languages. Using the concept of grammars with control languages by Salomaa, which offers a uniform treatment of a variety of grammar models, we present a condition on the class of control languages that guarantees that erasing productions are avoidable in the resulting grammar model. On the one hand, this generalizes the previous result that in Petri net controlled grammars, erasing productions can be eliminated. On the other hand, it allows us to infer that the same is true for vector grammars.
Daniela Battaglino;Encoding Centered Polyominoes by Means of a Regular Language.;Jean-Marc Fedou, Andrea Frosini, Simone Rinaldi;[<span itemprop="pagination">464-465</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_40;In [3] the authors proposed a classification of convex polyominoes based on the number of changes of direction in the paths connecting any two cells of a polyomino. More precisely, a convex polyomino is k-convex if every pair of its cells can be connected by a monotone path with at most k changes of direction. In 1-convex (also called L-convex) polyominoes, any two cells can be connected by a path with at most one change of direction.
Jean-Marc Fedou;Encoding Centered Polyominoes by Means of a Regular Language.;Daniela Battaglino, Andrea Frosini, Simone Rinaldi;[<span itemprop="pagination">464-465</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_40;In [3] the authors proposed a classification of convex polyominoes based on the number of changes of direction in the paths connecting any two cells of a polyomino. More precisely, a convex polyomino is k-convex if every pair of its cells can be connected by a monotone path with at most k changes of direction. In 1-convex (also called L-convex) polyominoes, any two cells can be connected by a path with at most one change of direction.
Andrea Frosini;Encoding Centered Polyominoes by Means of a Regular Language.;Daniela Battaglino, Jean-Marc Fedou, Simone Rinaldi;[<span itemprop="pagination">464-465</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_40;In [3] the authors proposed a classification of convex polyominoes based on the number of changes of direction in the paths connecting any two cells of a polyomino. More precisely, a convex polyomino is k-convex if every pair of its cells can be connected by a monotone path with at most k changes of direction. In 1-convex (also called L-convex) polyominoes, any two cells can be connected by a path with at most one change of direction.
Simone Rinaldi;Encoding Centered Polyominoes by Means of a Regular Language.;Daniela Battaglino, Jean-Marc Fedou, Andrea Frosini;[<span itemprop="pagination">464-465</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_40;In [3] the authors proposed a classification of convex polyominoes based on the number of changes of direction in the paths connecting any two cells of a polyomino. More precisely, a convex polyomino is k-convex if every pair of its cells can be connected by a monotone path with at most k changes of direction. In 1-convex (also called L-convex) polyominoes, any two cells can be connected by a path with at most one change of direction.
Jérôme Chandesris;Computational Aspects of Asynchronous Cellular Automata.;Alberto Dennunzio, Enrico Formenti, Luca Manzoni;[<span itemprop="pagination">466-468</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_41;Cellular Automata (CA) are a computational model widely used in many scientific fields. A CA consists of identical finite automata arranged over a regular lattice (i.e. every configuration of a CA is an element of Aℤ where A is a finite set of local states). Each automaton updates its state on the basis of its own state and the one of its neighbors according to a local rule. All updates are synchronous.
Alberto Dennunzio;Computational Aspects of Asynchronous Cellular Automata.;Jérôme Chandesris, Enrico Formenti, Luca Manzoni;[<span itemprop="pagination">466-468</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_41;Cellular Automata (CA) are a computational model widely used in many scientific fields. A CA consists of identical finite automata arranged over a regular lattice (i.e. every configuration of a CA is an element of Aℤ where A is a finite set of local states). Each automaton updates its state on the basis of its own state and the one of its neighbors according to a local rule. All updates are synchronous.
Enrico Formenti;Computational Aspects of Asynchronous Cellular Automata.;Jérôme Chandesris, Alberto Dennunzio, Luca Manzoni;[<span itemprop="pagination">466-468</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_41;Cellular Automata (CA) are a computational model widely used in many scientific fields. A CA consists of identical finite automata arranged over a regular lattice (i.e. every configuration of a CA is an element of Aℤ where A is a finite set of local states). Each automaton updates its state on the basis of its own state and the one of its neighbors according to a local rule. All updates are synchronous.
Luca Manzoni;Computational Aspects of Asynchronous Cellular Automata.;Jérôme Chandesris, Alberto Dennunzio, Enrico Formenti;[<span itemprop="pagination">466-468</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_41;Cellular Automata (CA) are a computational model widely used in many scientific fields. A CA consists of identical finite automata arranged over a regular lattice (i.e. every configuration of a CA is an element of Aℤ where A is a finite set of local states). Each automaton updates its state on the basis of its own state and the one of its neighbors according to a local rule. All updates are synchronous.
Alessandra Cherubini;Short 3-Collapsing Words over a 2-Letter Alphabet.;Achille Frigeri, Brunetto Piochi;[<span itemprop="pagination">469-471</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_42;Let \(\mathcal{A}=(Q,\Sigma,\delta)\) be a finite deterministic complete automaton. \(\mathcal{A}\) is called k-compressible if there is a word w ∈ Σ +  such that the image of the state set Q under the action of w has at most size |Q| − k, in such case the word w is called k-compressing for \(\mathcal{A}\). A word w ∈ Σ +  is k-collapsing if it is k-compressing for each k-compressible automaton of the alphabet Σ and it is k-synchronizing if it is k-compressing for each k-compressible automaton with k + 1 states (see [1,2] for details).
Achille Frigeri;Short 3-Collapsing Words over a 2-Letter Alphabet.;Alessandra Cherubini, Brunetto Piochi;[<span itemprop="pagination">469-471</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_42;Let \(\mathcal{A}=(Q,\Sigma,\delta)\) be a finite deterministic complete automaton. \(\mathcal{A}\) is called k-compressible if there is a word w ∈ Σ +  such that the image of the state set Q under the action of w has at most size |Q| − k, in such case the word w is called k-compressing for \(\mathcal{A}\). A word w ∈ Σ +  is k-collapsing if it is k-compressing for each k-compressible automaton of the alphabet Σ and it is k-synchronizing if it is k-compressing for each k-compressible automaton with k + 1 states (see [1,2] for details).
Brunetto Piochi;Short 3-Collapsing Words over a 2-Letter Alphabet.;Alessandra Cherubini, Achille Frigeri;[<span itemprop="pagination">469-471</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_42;Let \(\mathcal{A}=(Q,\Sigma,\delta)\) be a finite deterministic complete automaton. \(\mathcal{A}\) is called k-compressible if there is a word w ∈ Σ +  such that the image of the state set Q under the action of w has at most size |Q| − k, in such case the word w is called k-compressing for \(\mathcal{A}\). A word w ∈ Σ +  is k-collapsing if it is k-compressing for each k-compressible automaton of the alphabet Σ and it is k-synchronizing if it is k-compressing for each k-compressible automaton with k + 1 states (see [1,2] for details).
Manfred Droste;A Cascade Decomposition of Weighted Finite Transition Systems.;Ingmar Meinecke, Branimir Seselja, Andreja Tepavcevic;[<span itemprop="pagination">472-473</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_43;We consider weighted finite transition systems with weights from naturally ordered semirings. Such semirings comprise distributive lattices as well as the natural numbers with ordinary addition and multiplication, and the max -plus-semiring. For these systems we explore the concepts of covering and cascade product. We show a cascade decomposition result for such weighted finite transition systems using special partitions of the state set of the system. This extends a classical result of automata theory to the weighted setting.
Ingmar Meinecke;A Cascade Decomposition of Weighted Finite Transition Systems.;Manfred Droste, Branimir Seselja, Andreja Tepavcevic;[<span itemprop="pagination">472-473</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_43;We consider weighted finite transition systems with weights from naturally ordered semirings. Such semirings comprise distributive lattices as well as the natural numbers with ordinary addition and multiplication, and the max -plus-semiring. For these systems we explore the concepts of covering and cascade product. We show a cascade decomposition result for such weighted finite transition systems using special partitions of the state set of the system. This extends a classical result of automata theory to the weighted setting.
Branimir Seselja;A Cascade Decomposition of Weighted Finite Transition Systems.;Manfred Droste, Ingmar Meinecke, Andreja Tepavcevic;[<span itemprop="pagination">472-473</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_43;We consider weighted finite transition systems with weights from naturally ordered semirings. Such semirings comprise distributive lattices as well as the natural numbers with ordinary addition and multiplication, and the max -plus-semiring. For these systems we explore the concepts of covering and cascade product. We show a cascade decomposition result for such weighted finite transition systems using special partitions of the state set of the system. This extends a classical result of automata theory to the weighted setting.
Andreja Tepavcevic;A Cascade Decomposition of Weighted Finite Transition Systems.;Manfred Droste, Ingmar Meinecke, Branimir Seselja;[<span itemprop="pagination">472-473</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_43;We consider weighted finite transition systems with weights from naturally ordered semirings. Such semirings comprise distributive lattices as well as the natural numbers with ordinary addition and multiplication, and the max -plus-semiring. For these systems we explore the concepts of covering and cascade product. We show a cascade decomposition result for such weighted finite transition systems using special partitions of the state set of the system. This extends a classical result of automata theory to the weighted setting.
Kaoru Fujioka;Morphic Characterizations in Terms of Insertion Systems with a Context of Length One.;;[<span itemprop="pagination">474-475</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_44;Representing a class of languages through operations on its subclasses is a traditional issue within formal language theory. Among the variety of representation theorems for context-free languages, Chomsky-Schützenberger theorem is unique in that it consists of Dyck languages, regular languages, and simple operations. In this work, we obtain some characterizations and representation theorems of context-free languages and regular languages in Chomsky hierarchy by insertion systems, strictly locally testable languages, and morphisms in the framework of Chomsky-Schützenberger theorem.
Anna Kasprzik;Inference of Residual Finite-State Tree Automata from Membership Queries and Finite Positive Data.;;[<span itemprop="pagination">476-477</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_45;The area of Grammatical Inference centers on learning algorithms: Algorithms that infer a description (e.g., a grammar or an automaton) for an unknown formal language from given information in finitely many steps. Various conceivable learning settings have been outlined, and based on those a range of algorithms have been developed. One of the language classes studied most extensively with respect to its algorithmical learnability is the class of regular string languages.
Sergey Kitaev;On the Representability of Line Graphs.;Pavel Salimov, Christopher Severs, Henning Úlfarsson;[<span itemprop="pagination">478-479</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_46;A graph G = (V,E) is representable if there exists a word W over the alphabet V such that letters x and y alternate in W if and only if (x,y) ∈ E for each x ≠ y. Such a W is called a word-representant of G. Note that in this paper we use the term graph to mean a finite, simple graph, even though the definition of representable is applicable to more general graphs.
Pavel Salimov;On the Representability of Line Graphs.;Sergey Kitaev, Christopher Severs, Henning Úlfarsson;[<span itemprop="pagination">478-479</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_46;A graph G = (V,E) is representable if there exists a word W over the alphabet V such that letters x and y alternate in W if and only if (x,y) ∈ E for each x ≠ y. Such a W is called a word-representant of G. Note that in this paper we use the term graph to mean a finite, simple graph, even though the definition of representable is applicable to more general graphs.
Christopher Severs;On the Representability of Line Graphs.;Sergey Kitaev, Pavel Salimov, Henning Úlfarsson;[<span itemprop="pagination">478-479</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_46;A graph G = (V,E) is representable if there exists a word W over the alphabet V such that letters x and y alternate in W if and only if (x,y) ∈ E for each x ≠ y. Such a W is called a word-representant of G. Note that in this paper we use the term graph to mean a finite, simple graph, even though the definition of representable is applicable to more general graphs.
Henning Úlfarsson;On the Representability of Line Graphs.;Sergey Kitaev, Pavel Salimov, Christopher Severs;[<span itemprop="pagination">478-479</span>];[<meta content="2011" itemprop="datePublished"/>];https://doi.org/10.1007/978-3-642-22321-1_46;A graph G = (V,E) is representable if there exists a word W over the alphabet V such that letters x and y alternate in W if and only if (x,y) ∈ E for each x ≠ y. Such a W is called a word-representant of G. Note that in this paper we use the term graph to mean a finite, simple graph, even though the definition of representable is applicable to more general graphs.
