Venue;Author;Co-Authors;Title;Abstract
0;Hermann Gruber;Markus Holzer, Christian Rauch;On 25 Years of CIAA Through the Lens of Data Science;We investigate the structure of the co-authorship graph for the Conference on Implementation and Application of Automata (CIAA) with techniques from network sciences. This allows us to answer a broad variety of questions on collaboration patterns. Our findings are in line with (statistical) properties of other co-authorship networks from biology, physics and mathematics as conducted earlier by pioneers of network sciences.
0;Markus Holzer;Hermann Gruber, Christian Rauch;On 25 Years of CIAA Through the Lens of Data Science;We investigate the structure of the co-authorship graph for the Conference on Implementation and Application of Automata (CIAA) with techniques from network sciences. This allows us to answer a broad variety of questions on collaboration patterns. Our findings are in line with (statistical) properties of other co-authorship networks from biology, physics and mathematics as conducted earlier by pioneers of network sciences.
0;Christian Rauch;Hermann Gruber, Markus Holzer;On 25 Years of CIAA Through the Lens of Data Science;We investigate the structure of the co-authorship graph for the Conference on Implementation and Application of Automata (CIAA) with techniques from network sciences. This allows us to answer a broad variety of questions on collaboration patterns. Our findings are in line with (statistical) properties of other co-authorship networks from biology, physics and mathematics as conducted earlier by pioneers of network sciences.
0;Nelma Moreira;Rogério Reis;Manipulation of Regular Expressions Using Derivatives: An Overview;The notions of derivative and partial derivative of regular expressions revealed themselves to be very powerful and have been successfully extended to many other formal language classes and algebraic structures. Although the undisputed elegance of this formalism, its efficient practical use is still a challenging research topic. Here we give a brief historical overview and summarise some of these aspects.
0;Rogério Reis;Nelma Moreira;Manipulation of Regular Expressions Using Derivatives: An Overview;The notions of derivative and partial derivative of regular expressions revealed themselves to be very powerful and have been successfully extended to many other formal language classes and algebraic structures. Although the undisputed elegance of this formalism, its efficient practical use is still a challenging research topic. Here we give a brief historical overview and summarise some of these aspects.
0;Sicheol Sung;Hyunjoon Cheon, Yo-Sub Han;How to Settle the ReDoS Problem: Back to the Classical Automata Theory;Most regular-expression matching engines in practice are based on the Thompson construction and the Spencer matching algorithm. While these engines work fast and efficiently, a serious problem, the regular expression denial-of-service (ReDoS), has been reported recently. ReDoS is an algorithm complexity attack, which exploits the backtracking feature of the engine, and makes the service unresponsive indefinitely. Researchers suggested a few remedies to cope with the ReDoS problem, yet they are often ad-hoc or undesirable in practice. We instead propose a hybrid matching scheme that selects between the Thompson and the Spencer matching algorithms depending on the needed features. We also suggest to use the position construction for its intrinsic characteristics for fast matching. We evaluate the proposed approach using a benchmark dataset collected from various open-source projects, and compare the performance with the current approach. The experimental results show that a hybrid matcher reduces the ReDoS-vulnerability by 96% and 99.98% in full and partial matching, respectively. Moreover, 55% of the most problematic regular expressions become invulnerable to ReDoS by the position construction.
0;Hyunjoon Cheon;Sicheol Sung, Yo-Sub Han;How to Settle the ReDoS Problem: Back to the Classical Automata Theory;Most regular-expression matching engines in practice are based on the Thompson construction and the Spencer matching algorithm. While these engines work fast and efficiently, a serious problem, the regular expression denial-of-service (ReDoS), has been reported recently. ReDoS is an algorithm complexity attack, which exploits the backtracking feature of the engine, and makes the service unresponsive indefinitely. Researchers suggested a few remedies to cope with the ReDoS problem, yet they are often ad-hoc or undesirable in practice. We instead propose a hybrid matching scheme that selects between the Thompson and the Spencer matching algorithms depending on the needed features. We also suggest to use the position construction for its intrinsic characteristics for fast matching. We evaluate the proposed approach using a benchmark dataset collected from various open-source projects, and compare the performance with the current approach. The experimental results show that a hybrid matcher reduces the ReDoS-vulnerability by 96% and 99.98% in full and partial matching, respectively. Moreover, 55% of the most problematic regular expressions become invulnerable to ReDoS by the position construction.
0;Yo-Sub Han;Sicheol Sung, Hyunjoon Cheon;How to Settle the ReDoS Problem: Back to the Classical Automata Theory;Most regular-expression matching engines in practice are based on the Thompson construction and the Spencer matching algorithm. While these engines work fast and efficiently, a serious problem, the regular expression denial-of-service (ReDoS), has been reported recently. ReDoS is an algorithm complexity attack, which exploits the backtracking feature of the engine, and makes the service unresponsive indefinitely. Researchers suggested a few remedies to cope with the ReDoS problem, yet they are often ad-hoc or undesirable in practice. We instead propose a hybrid matching scheme that selects between the Thompson and the Spencer matching algorithms depending on the needed features. We also suggest to use the position construction for its intrinsic characteristics for fast matching. We evaluate the proposed approach using a benchmark dataset collected from various open-source projects, and compare the performance with the current approach. The experimental results show that a hybrid matcher reduces the ReDoS-vulnerability by 96% and 99.98% in full and partial matching, respectively. Moreover, 55% of the most problematic regular expressions become invulnerable to ReDoS by the position construction.
0;Brink van der Merwe;Martin Berglund;Ordered Context-Free Grammars;We propose a new unambiguous grammar formalism, referred to as ordered context-free grammars, which is identical to context-free grammars, apart from the property that it also places an order on parse trees. Since only a minor modification to ordered context-free grammars is required to obtain parsing expression grammars, the relationship between context-free grammars and parsing expression grammars becomes more evident. By preserving how ordered context-free grammars support left-recursion, parsing expression grammars is modified to support left recursion in ways much more natural than current approaches.
0;Martin Berglund;Brink van der Merwe;Ordered Context-Free Grammars;We propose a new unambiguous grammar formalism, referred to as ordered context-free grammars, which is identical to context-free grammars, apart from the property that it also places an order on parse trees. Since only a minor modification to ordered context-free grammars is required to obtain parsing expression grammars, the relationship between context-free grammars and parsing expression grammars becomes more evident. By preserving how ordered context-free grammars support left-recursion, parsing expression grammars is modified to support left recursion in ways much more natural than current approaches.
0;Florent Jacquemard;Lydia Rodriguez de la Nava;Symbolic Weighted Language Models, Quantitative Parsing and Automated Music Transcription;We study several classes of symbolic weighted formalisms: automata (swA), transducers (swT) and visibly pushdown extensions (swVPA, swVPT). They combine the respective extensions of their symbolic and weighted counterparts, allowing a quantitative evaluation of words over a large or infinite input alphabet.
0;Lydia Rodriguez de la Nava;Florent Jacquemard;Symbolic Weighted Language Models, Quantitative Parsing and Automated Music Transcription;We study several classes of symbolic weighted formalisms: automata (swA), transducers (swT) and visibly pushdown extensions (swVPA, swVPT). They combine the respective extensions of their symbolic and weighted counterparts, allowing a quantitative evaluation of words over a large or infinite input alphabet.
0;Florian Bruse;Maurice Herwig, Martin Lange;A Similarity Measure for Formal Languages Based on Convergent Geometric Series;We present a distance metric on formal languages based on the accumulated weight of words in their symmetric difference. The contribution of an individual word to this weight decreases exponentially in its length, guaranteeing the distance between languages to be a real value between 0 and 1. We show that this distance is computable for regular languages. As an application, we show how the similarity measure derived from a modification of this metric can be used in automatic grading of particular standard exercises in formal language theory classes.
0;Maurice Herwig;Florian Bruse, Martin Lange;A Similarity Measure for Formal Languages Based on Convergent Geometric Series;We present a distance metric on formal languages based on the accumulated weight of words in their symmetric difference. The contribution of an individual word to this weight decreases exponentially in its length, guaranteeing the distance between languages to be a real value between 0 and 1. We show that this distance is computable for regular languages. As an application, we show how the similarity measure derived from a modification of this metric can be used in automatic grading of particular standard exercises in formal language theory classes.
0;Martin Lange;Florian Bruse, Maurice Herwig;A Similarity Measure for Formal Languages Based on Convergent Geometric Series;We present a distance metric on formal languages based on the accumulated weight of words in their symmetric difference. The contribution of an individual word to this weight decreases exponentially in its length, guaranteeing the distance between languages to be a real value between 0 and 1. We show that this distance is computable for regular languages. As an application, we show how the similarity measure derived from a modification of this metric can be used in automatic grading of particular standard exercises in formal language theory classes.
0;Frank Drewes;Richard Mörbitz, Heiko Vogler;Hybrid Tree Automata and the Yield Theorem for Constituent Tree Automata;We introduce an automaton model for recognizing sets of hybrid trees, the hybrid tree automaton (HTA). Special cases of hybrid trees are constituent trees and dependency trees, as they occur in natural language processing. This includes the cases of discontinuous constituent trees and non-projective dependency trees. In general, a hybrid tree is a tree over a ranked alphabet in which symbols can additionally be equipped with an index, i.e., a natural number which indicates the position of that symbol in the yield of the hybrid tree. As a special case of HTA, we define constituent tree automata (CTA) which recognize sets of constituent trees. We show that the set of yields of a CTA-recognizable set of constituent trees is an LCFRS language, and vice versa.
0;Richard Mörbitz;Frank Drewes, Heiko Vogler;Hybrid Tree Automata and the Yield Theorem for Constituent Tree Automata;We introduce an automaton model for recognizing sets of hybrid trees, the hybrid tree automaton (HTA). Special cases of hybrid trees are constituent trees and dependency trees, as they occur in natural language processing. This includes the cases of discontinuous constituent trees and non-projective dependency trees. In general, a hybrid tree is a tree over a ranked alphabet in which symbols can additionally be equipped with an index, i.e., a natural number which indicates the position of that symbol in the yield of the hybrid tree. As a special case of HTA, we define constituent tree automata (CTA) which recognize sets of constituent trees. We show that the set of yields of a CTA-recognizable set of constituent trees is an LCFRS language, and vice versa.
0;Heiko Vogler;Frank Drewes, Richard Mörbitz;Hybrid Tree Automata and the Yield Theorem for Constituent Tree Automata;We introduce an automaton model for recognizing sets of hybrid trees, the hybrid tree automaton (HTA). Special cases of hybrid trees are constituent trees and dependency trees, as they occur in natural language processing. This includes the cases of discontinuous constituent trees and non-projective dependency trees. In general, a hybrid tree is a tree over a ranked alphabet in which symbols can additionally be equipped with an index, i.e., a natural number which indicates the position of that symbol in the yield of the hybrid tree. As a special case of HTA, we define constituent tree automata (CTA) which recognize sets of constituent trees. We show that the set of yields of a CTA-recognizable set of constituent trees is an LCFRS language, and vice versa.
0;Jakub Ruszil;;Some Results Concerning Careful Synchronization of Partial Automata and Subset Synchronization of DFA’s;The goal of this paper is to present a family of partial automata that achieve length \(\varTheta (3^{\frac{n}{3}})\) of the shortest carefully synchronizing words, but using \(\frac{2}{9}n + 2\) letters, thus substantially improving the result obtained in [<a aria-label="Reference 19" data-test="citation-ref" data-track="click" data-track-action="reference anchor" data-track-label="link" href="#ref-CR19" id="ref-link-section-d1316498e638" title="Martyugin, P.V.: Careful synchronization of partial automata with restricted alphabets. In: Bulatov, A.A., Shur, A.M. (eds.) CSR 2013. LNCS, vol. 7913, pp. 76–87. Springer, Heidelberg (2013).                   https://doi.org/10.1007/978-3-642-38536-0_7                                  ">19], which is \(\frac{1}{3}n + 1\) letters. Additionally, modifying our idea we obtain a family of automata over a three letter alphabet and a subexponential length of the shortest carefully synchronizing words and, as a corollary of that construction, a series of binary automata with a subexponential length of word reducing set of states to a particular subset.
0;Laura K. Hutchinson;Robert Mercaş, Daniel Reidenbach;A Toolkit for Parikh Matrices;The Parikh matrix mapping is a concept that provides information on the number of occurrences of certain (scattered) subwords in a word. Although Parikh matrices have been thoroughly studied, many of their basic properties remain open. In the present paper, we describe a toolkit that has been developed to support research in this field. Its functionality includes elementary and advanced operations related to Parikh matrices and the recently introduced variants of \(\mathbb {P}\)-Parikh matrices and \(\mathbb {L}\)-Parikh matrices.
0;Robert Mercaş;Laura K. Hutchinson, Daniel Reidenbach;A Toolkit for Parikh Matrices;The Parikh matrix mapping is a concept that provides information on the number of occurrences of certain (scattered) subwords in a word. Although Parikh matrices have been thoroughly studied, many of their basic properties remain open. In the present paper, we describe a toolkit that has been developed to support research in this field. Its functionality includes elementary and advanced operations related to Parikh matrices and the recently introduced variants of \(\mathbb {P}\)-Parikh matrices and \(\mathbb {L}\)-Parikh matrices.
0;Daniel Reidenbach;Laura K. Hutchinson, Robert Mercaş;A Toolkit for Parikh Matrices;The Parikh matrix mapping is a concept that provides information on the number of occurrences of certain (scattered) subwords in a word. Although Parikh matrices have been thoroughly studied, many of their basic properties remain open. In the present paper, we describe a toolkit that has been developed to support research in this field. Its functionality includes elementary and advanced operations related to Parikh matrices and the recently introduced variants of \(\mathbb {P}\)-Parikh matrices and \(\mathbb {L}\)-Parikh matrices.
0;Martin Kutrib;Uwe Meyer;Syntax Checking Either Way;We consider parsers of deterministic context-free languages and study the sizes of their syntax checking components. More precisely, we allow the input processing from left to right or, alternatively, from right to left, whatever is best for the given language. We establish an infinite sequence of deterministic context-free languages \(L_k\), for \(k\ge 1\), such that there is an exponential size trade-off between a deterministic pushdown automaton that reads its input from right to left and another one that reads its input from left to right. Concerning the constructibility of such a parser out of a given deterministic context-free language, it is shown that it is undecidable whether the reversal of a given deterministic context-free language is again deterministic context free. Furthermore, we study the expressive capacity of the family of languages whose reversals are deterministic context free. Finally, we turn to the family of deterministic context-free languages whose reversals are also deterministic context free and collect several of their closure properties.
0;Uwe Meyer;Martin Kutrib;Syntax Checking Either Way;We consider parsers of deterministic context-free languages and study the sizes of their syntax checking components. More precisely, we allow the input processing from left to right or, alternatively, from right to left, whatever is best for the given language. We establish an infinite sequence of deterministic context-free languages \(L_k\), for \(k\ge 1\), such that there is an exponential size trade-off between a deterministic pushdown automaton that reads its input from right to left and another one that reads its input from left to right. Concerning the constructibility of such a parser out of a given deterministic context-free language, it is shown that it is undecidable whether the reversal of a given deterministic context-free language is again deterministic context free. Furthermore, we study the expressive capacity of the family of languages whose reversals are deterministic context free. Finally, we turn to the family of deterministic context-free languages whose reversals are also deterministic context free and collect several of their closure properties.
0;Martin Kutrib;Andreas Malcher, Matthias Wendlandt;On the Power of Pushing or Stationary Moves for Input-Driven Pushdown Automata;Input-driven pushdown automata (\(\text {IDPDA}\)s) are pushdown automata where the next action on the pushdown store (push, pop, nothing) is solely governed by the input symbol. Nowadays such devices are usually defined such that every push operation pushes exactly one additional symbol on the pushdown store and, in addition, the devices work in real time so that stationary moves are not allowed. Here, we relax this strong definition and consider \(\text {IDPDA}\)s that may push more than one symbol in one step (\(\text {push-IDPDA}\)) or may perform stationary moves (\(\text {stat-IDPDA}\)). We study the computational power of the extended variants both in the deterministic and nondeterministic case, we investigate several decidability questions for the new automata classes, and we obtain useful interesting representations by inverse homomorphisms.
0;Andreas Malcher;Martin Kutrib, Matthias Wendlandt;On the Power of Pushing or Stationary Moves for Input-Driven Pushdown Automata;Input-driven pushdown automata (\(\text {IDPDA}\)s) are pushdown automata where the next action on the pushdown store (push, pop, nothing) is solely governed by the input symbol. Nowadays such devices are usually defined such that every push operation pushes exactly one additional symbol on the pushdown store and, in addition, the devices work in real time so that stationary moves are not allowed. Here, we relax this strong definition and consider \(\text {IDPDA}\)s that may push more than one symbol in one step (\(\text {push-IDPDA}\)) or may perform stationary moves (\(\text {stat-IDPDA}\)). We study the computational power of the extended variants both in the deterministic and nondeterministic case, we investigate several decidability questions for the new automata classes, and we obtain useful interesting representations by inverse homomorphisms.
0;Matthias Wendlandt;Martin Kutrib, Andreas Malcher;On the Power of Pushing or Stationary Moves for Input-Driven Pushdown Automata;Input-driven pushdown automata (\(\text {IDPDA}\)s) are pushdown automata where the next action on the pushdown store (push, pop, nothing) is solely governed by the input symbol. Nowadays such devices are usually defined such that every push operation pushes exactly one additional symbol on the pushdown store and, in addition, the devices work in real time so that stationary moves are not allowed. Here, we relax this strong definition and consider \(\text {IDPDA}\)s that may push more than one symbol in one step (\(\text {push-IDPDA}\)) or may perform stationary moves (\(\text {stat-IDPDA}\)). We study the computational power of the extended variants both in the deterministic and nondeterministic case, we investigate several decidability questions for the new automata classes, and we obtain useful interesting representations by inverse homomorphisms.
0;Michal Hospodár;Viktor Olejár;The Cut Operation in Subclasses of Convex Languages (Extended Abstract);The cut of two languages is a subset of their concatenation given by the leftmost maximal substring match. We study the state complexity of the cut operation assuming that both operands belong to some, possibly different, subclasses of convex languages, namely, right, left, two-sided, and all-sided ideal, prefix-, suffix-, factor-, and subword-closed, and -free languages. For all considered pairs of classes, we get the exact state complexity of cut. We show that it is m whenever the first language is a right ideal, and it is \(m+n-1\) or \(m+n-2\) if the first language is prefix-closed or prefix-free. In the other cases, the state complexity of cut is between \(mn-2n-m+4\) and \(mn-n+m\), the latter being the known state complexity of cut on regular languages. All our witnesses are described over a fixed alphabet of size at most three, except for three cases when the witness languages are described over an alphabet of size m or \(m-1\).
0;Viktor Olejár;Michal Hospodár;The Cut Operation in Subclasses of Convex Languages (Extended Abstract);The cut of two languages is a subset of their concatenation given by the leftmost maximal substring match. We study the state complexity of the cut operation assuming that both operands belong to some, possibly different, subclasses of convex languages, namely, right, left, two-sided, and all-sided ideal, prefix-, suffix-, factor-, and subword-closed, and -free languages. For all considered pairs of classes, we get the exact state complexity of cut. We show that it is m whenever the first language is a right ideal, and it is \(m+n-1\) or \(m+n-2\) if the first language is prefix-closed or prefix-free. In the other cases, the state complexity of cut is between \(mn-2n-m+4\) and \(mn-n+m\), the latter being the known state complexity of cut on regular languages. All our witnesses are described over a fixed alphabet of size at most three, except for three cases when the witness languages are described over an alphabet of size m or \(m-1\).
0;Nicholas Tran;;Variations of the Separating Words Problem;The separating words problem seeks to determine the asymptotic growth of the minimum number of states of a deterministic finite automaton that accepts x but rejects y, where x and y are given strings. We study three natural variants of this problem which impose additional constraints on the start and/or end states: \(\forall \)-separation requires different end states for every common start state. \(\forall ^2\)-separation requires different end states for every pair of start states. and \(\forall ^201\)-separation requires fixed different end states for every pair of start states.
0;Olga Martynova;Alexander Okhotin;Homomorphisms on Graph-Walking Automata;Graph-walking automata (GWA) analyze an input graph by moving between its nodes, following the edges. This paper investigates the effect of node-replacement graph homomorphisms on recognizability by these automata. The family of graph languages recognized by GWA is closed under inverse homomorphisms. The main result of this paper is that, for n-state automata operating on graphs with k labels of edge end-points, the inverse homomorphic images require GWA with \(kn+O(1)\) states in the worst case. The second result is that already for tree-walking automata, the family they recognize is not closed under injective homomorphisms. here the proof is based on a homomorphic characterization of regular tree languages.
0;Alexander Okhotin;Olga Martynova;Homomorphisms on Graph-Walking Automata;Graph-walking automata (GWA) analyze an input graph by moving between its nodes, following the edges. This paper investigates the effect of node-replacement graph homomorphisms on recognizability by these automata. The family of graph languages recognized by GWA is closed under inverse homomorphisms. The main result of this paper is that, for n-state automata operating on graphs with k labels of edge end-points, the inverse homomorphic images require GWA with \(kn+O(1)\) states in the worst case. The second result is that already for tree-walking automata, the family they recognize is not closed under injective homomorphisms. here the proof is based on a homomorphic characterization of regular tree languages.
0;Oliver A. S. Lyon;Kai Salomaa;Nondeterministic State Complexity of Site-Directed Deletion;Site-directed deletion is a biologically inspired operation that removes a contiguous substring from the host string guided by a template string. The template string must match the prefix and suffix of a substring. When this occurs the middle section of the substring not contained in the prefix or suffix is removed. We consider the nondeterministic state complexity of the site-directed deletion operation. For regular languages recognized by nondeterministic finite automata with N and M states, respectively, we establish a new upper bound of \(2NM + N\) and a new worst case lower bound of 2NM. The upper bound improves a previously established upper bound, and no non-trivial lower bound was previously known for the nondeterministic state complexity of site-directed deletion.
0;Kai Salomaa;Oliver A. S. Lyon;Nondeterministic State Complexity of Site-Directed Deletion;Site-directed deletion is a biologically inspired operation that removes a contiguous substring from the host string guided by a template string. The template string must match the prefix and suffix of a substring. When this occurs the middle section of the substring not contained in the prefix or suffix is removed. We consider the nondeterministic state complexity of the site-directed deletion operation. For regular languages recognized by nondeterministic finite automata with N and M states, respectively, we establish a new upper bound of \(2NM + N\) and a new worst case lower bound of 2NM. The upper bound improves a previously established upper bound, and no non-trivial lower bound was previously known for the nondeterministic state complexity of site-directed deletion.
0;Öykü Yılmaz;Fırat Kıyak, Meriç Üngör, A. C. Cem Say;Energy Complexity of Regular Language Recognition;The erasure of each bit of information by a computing device has an intrinsic energy cost. Although any Turing machine can be rewritten to be thermodynamically reversible without changing the recognized language, finite automata that are restricted to scan their input once in “real-time” fashion can only recognize the members of a proper subset of the class of regular languages in this reversible manner. We use a general quantum finite automaton model to study the thermodynamic cost per step associated with the recognition of different regular languages. We show that zero-error quantum finite automata have no energy cost advantage over their classical deterministic counterparts, and prove an upper bound for the cost that holds for all regular languages. We also demonstrate languages for which “error can be traded for energy”, i.e. whose zero-error recognition is associated with provably bigger energy cost per step when compared to their bounded-error recognition by real-time finite-memory quantum devices.
0;Fırat Kıyak;Öykü Yılmaz, Meriç Üngör, A. C. Cem Say;Energy Complexity of Regular Language Recognition;The erasure of each bit of information by a computing device has an intrinsic energy cost. Although any Turing machine can be rewritten to be thermodynamically reversible without changing the recognized language, finite automata that are restricted to scan their input once in “real-time” fashion can only recognize the members of a proper subset of the class of regular languages in this reversible manner. We use a general quantum finite automaton model to study the thermodynamic cost per step associated with the recognition of different regular languages. We show that zero-error quantum finite automata have no energy cost advantage over their classical deterministic counterparts, and prove an upper bound for the cost that holds for all regular languages. We also demonstrate languages for which “error can be traded for energy”, i.e. whose zero-error recognition is associated with provably bigger energy cost per step when compared to their bounded-error recognition by real-time finite-memory quantum devices.
0;Meriç Üngör;Öykü Yılmaz, Fırat Kıyak, A. C. Cem Say;Energy Complexity of Regular Language Recognition;The erasure of each bit of information by a computing device has an intrinsic energy cost. Although any Turing machine can be rewritten to be thermodynamically reversible without changing the recognized language, finite automata that are restricted to scan their input once in “real-time” fashion can only recognize the members of a proper subset of the class of regular languages in this reversible manner. We use a general quantum finite automaton model to study the thermodynamic cost per step associated with the recognition of different regular languages. We show that zero-error quantum finite automata have no energy cost advantage over their classical deterministic counterparts, and prove an upper bound for the cost that holds for all regular languages. We also demonstrate languages for which “error can be traded for energy”, i.e. whose zero-error recognition is associated with provably bigger energy cost per step when compared to their bounded-error recognition by real-time finite-memory quantum devices.
0;A. C. Cem Say;Öykü Yılmaz, Fırat Kıyak, Meriç Üngör;Energy Complexity of Regular Language Recognition;The erasure of each bit of information by a computing device has an intrinsic energy cost. Although any Turing machine can be rewritten to be thermodynamically reversible without changing the recognized language, finite automata that are restricted to scan their input once in “real-time” fashion can only recognize the members of a proper subset of the class of regular languages in this reversible manner. We use a general quantum finite automaton model to study the thermodynamic cost per step associated with the recognition of different regular languages. We show that zero-error quantum finite automata have no energy cost advantage over their classical deterministic counterparts, and prove an upper bound for the cost that holds for all regular languages. We also demonstrate languages for which “error can be traded for energy”, i.e. whose zero-error recognition is associated with provably bigger energy cost per step when compared to their bounded-error recognition by real-time finite-memory quantum devices.
0;Özdeniz Dolu;Nevzat Ersoy, M. Utkan Gezer, A. C. Cem Say;Real-Time, Constant-Space, Constant-Randomness Verifiers;We study the class of languages that have membership proofs which can be verified by real-time finite-state machines using only a constant number of random bits, regardless of the size of their inputs. Since any further restriction on the verifiers would preclude the verification of nonregular languages, this is the tightest computational budget which allows the checking of externally provided proofs to have meaningful use. We show that all languages that can be recognized by two-head one-way deterministic finite automata have such membership proofs. For any \(k&gt.0\), there exist languages that cannot be recognized by any k-head one-way nondeterministic finite automaton, but that are nonetheless real-time verifiable in this sense. The set of nonpalindromes, which cannot be recognized by any one-way multihead deterministic finite automaton, is also demonstrated to be verifiable within these restrictions.
0;Nevzat Ersoy;Özdeniz Dolu, M. Utkan Gezer, A. C. Cem Say;Real-Time, Constant-Space, Constant-Randomness Verifiers;We study the class of languages that have membership proofs which can be verified by real-time finite-state machines using only a constant number of random bits, regardless of the size of their inputs. Since any further restriction on the verifiers would preclude the verification of nonregular languages, this is the tightest computational budget which allows the checking of externally provided proofs to have meaningful use. We show that all languages that can be recognized by two-head one-way deterministic finite automata have such membership proofs. For any \(k&gt.0\), there exist languages that cannot be recognized by any k-head one-way nondeterministic finite automaton, but that are nonetheless real-time verifiable in this sense. The set of nonpalindromes, which cannot be recognized by any one-way multihead deterministic finite automaton, is also demonstrated to be verifiable within these restrictions.
0;M. Utkan Gezer;Özdeniz Dolu, Nevzat Ersoy, A. C. Cem Say;Real-Time, Constant-Space, Constant-Randomness Verifiers;We study the class of languages that have membership proofs which can be verified by real-time finite-state machines using only a constant number of random bits, regardless of the size of their inputs. Since any further restriction on the verifiers would preclude the verification of nonregular languages, this is the tightest computational budget which allows the checking of externally provided proofs to have meaningful use. We show that all languages that can be recognized by two-head one-way deterministic finite automata have such membership proofs. For any \(k&gt.0\), there exist languages that cannot be recognized by any k-head one-way nondeterministic finite automaton, but that are nonetheless real-time verifiable in this sense. The set of nonpalindromes, which cannot be recognized by any one-way multihead deterministic finite automaton, is also demonstrated to be verifiable within these restrictions.
0;A. C. Cem Say;Özdeniz Dolu, Nevzat Ersoy, M. Utkan Gezer;Real-Time, Constant-Space, Constant-Randomness Verifiers;We study the class of languages that have membership proofs which can be verified by real-time finite-state machines using only a constant number of random bits, regardless of the size of their inputs. Since any further restriction on the verifiers would preclude the verification of nonregular languages, this is the tightest computational budget which allows the checking of externally provided proofs to have meaningful use. We show that all languages that can be recognized by two-head one-way deterministic finite automata have such membership proofs. For any \(k&gt.0\), there exist languages that cannot be recognized by any k-head one-way nondeterministic finite automaton, but that are nonetheless real-time verifiable in this sense. The set of nonpalindromes, which cannot be recognized by any one-way multihead deterministic finite automaton, is also demonstrated to be verifiable within these restrictions.
1;Javier Esparza;;Back to the Future: A Fresh Look at Linear Temporal Logic;This note tells the story of how I came to understand that my work with Křetínský and Sickert on translating LTL into \(\omega \)-automata was deeply connected to a normal form for LTL, obtained 35 years ago by Lichtenstein, Pnueli and Zuck.
1;Jeffrey Shallit;;Say No to Case Analysis: Automating the Drudgery of Case-Based Proofs;I present an argument that long, tedious proofs requiring a human to check many cases should be replaced by an algorithm, so a computer can do the work instead.
1;Stefan Hoffmann;;Regularity Conditions for Iterated Shuffle on Commutative Regular Languages;We identify a subclass of the regular commutative languages that is closed under the iterated shuffle, or shuffle closure. In particular, it is regularity-preserving on this subclass. This subclass contains the commutative group languages and, for every alphabet \(\varSigma \), the class \(\mathbf{Com} ^{+}(\varSigma ^{*})\) given by the ordered variety \(\mathbf{Com} ^+\). Then, we state a simple characterization when the iterated shuffle on finite commutative languages gives a regular language again and state partial results for aperiodic commutative languages. We also show that the aperiodic, or star-free, commutative languages and the commutative group languages are closed under projection.
1;Brink van der Merwe;Jacobie Mouton, Steyn van Litsenborgh, Martin Berglund;Memoized Regular Expressions;We extend non-deterministic finite automata (NFAs) and regular expressions (regexes) by adding memoization to these formalisms. These extensions are aimed at improving the matching time of backtracking regex matchers. Additionally, we discuss how to extend the concept of ambiguity in order to be applicable to memoized extensions of regexes and NFAs. These more general notions of ambiguity can be used to analyze the matching time of backtracking regex matchers enhanced with memoization.
1;Jacobie Mouton;Brink van der Merwe, Steyn van Litsenborgh, Martin Berglund;Memoized Regular Expressions;We extend non-deterministic finite automata (NFAs) and regular expressions (regexes) by adding memoization to these formalisms. These extensions are aimed at improving the matching time of backtracking regex matchers. Additionally, we discuss how to extend the concept of ambiguity in order to be applicable to memoized extensions of regexes and NFAs. These more general notions of ambiguity can be used to analyze the matching time of backtracking regex matchers enhanced with memoization.
1;Steyn van Litsenborgh;Brink van der Merwe, Jacobie Mouton, Martin Berglund;Memoized Regular Expressions;We extend non-deterministic finite automata (NFAs) and regular expressions (regexes) by adding memoization to these formalisms. These extensions are aimed at improving the matching time of backtracking regex matchers. Additionally, we discuss how to extend the concept of ambiguity in order to be applicable to memoized extensions of regexes and NFAs. These more general notions of ambiguity can be used to analyze the matching time of backtracking regex matchers enhanced with memoization.
1;Martin Berglund;Brink van der Merwe, Jacobie Mouton, Steyn van Litsenborgh;Memoized Regular Expressions;We extend non-deterministic finite automata (NFAs) and regular expressions (regexes) by adding memoization to these formalisms. These extensions are aimed at improving the matching time of backtracking regex matchers. Additionally, we discuss how to extend the concept of ambiguity in order to be applicable to memoized extensions of regexes and NFAs. These more general notions of ambiguity can be used to analyze the matching time of backtracking regex matchers enhanced with memoization.
1;Stefan Hoffmann;;The Commutative Closure of Shuffle Languages over Group Languages is Regular;We show that the commutative closure combined with the iterated shuffle is a regularity-preserving operation on group languages. In particular, for commutative group languages, the iterated shuffle is a regularity-preserving operation. We also give bounds for the size of minimal recognizing automata. Then, we use this result to deduce that the commutative closure of any shuffle language over group languages, i.e., a language given by a shuffle expression, i.e., expressions involving shuffle, iterated shuffle, concatenation, Kleene star and union in any order, starting with the group languages, always yields a regular language.
1;Su-Hyeon Kim;Hyeonseung Im, Sang-Ki Ko;Efficient Enumeration of Regular Expressions for Faster Regular Expression Synthesis;We study the problem of synthesizing regular expressions from a set of positive and negative strings. The previous synthesis algorithm proposed by Lee et al. [12] relies on the best-first enumeration of regular expressions. To improve the performance of the enumeration process, we define a new normal form of regular expressions called the concise normal form which allows us to significantly reduce the search space by pruning those not in the normal form while still capturing the whole class of regular languages. We conduct experiments with two benchmark datasets and demonstrate that our synthesis algorithm based on the proposed normal form outperforms the previous algorithm in terms of runtime complexity and scalability.
1;Hyeonseung Im;Su-Hyeon Kim, Sang-Ki Ko;Efficient Enumeration of Regular Expressions for Faster Regular Expression Synthesis;We study the problem of synthesizing regular expressions from a set of positive and negative strings. The previous synthesis algorithm proposed by Lee et al. [12] relies on the best-first enumeration of regular expressions. To improve the performance of the enumeration process, we define a new normal form of regular expressions called the concise normal form which allows us to significantly reduce the search space by pruning those not in the normal form while still capturing the whole class of regular languages. We conduct experiments with two benchmark datasets and demonstrate that our synthesis algorithm based on the proposed normal form outperforms the previous algorithm in terms of runtime complexity and scalability.
1;Sang-Ki Ko;Su-Hyeon Kim, Hyeonseung Im;Efficient Enumeration of Regular Expressions for Faster Regular Expression Synthesis;We study the problem of synthesizing regular expressions from a set of positive and negative strings. The previous synthesis algorithm proposed by Lee et al. [12] relies on the best-first enumeration of regular expressions. To improve the performance of the enumeration process, we define a new normal form of regular expressions called the concise normal form which allows us to significantly reduce the search space by pruning those not in the normal form while still capturing the whole class of regular languages. We conduct experiments with two benchmark datasets and demonstrate that our synthesis algorithm based on the proposed normal form outperforms the previous algorithm in terms of runtime complexity and scalability.
1;Taylor J. Smith;Kai Salomaa;Degrees of Restriction for Two-Dimensional Automata;A three-way (resp., two-way) two-dimensional automaton has a read-only input head that moves in three (resp., two) directions on a finite array of cells labelled by symbols of the input alphabet. Restricting the input head movement of a two-dimensional automaton results in a model that is weaker in terms of recognition power.
1;Kai Salomaa;Taylor J. Smith;Degrees of Restriction for Two-Dimensional Automata;A three-way (resp., two-way) two-dimensional automaton has a read-only input head that moves in three (resp., two) directions on a finite array of cells labelled by symbols of the input alphabet. Restricting the input head movement of a two-dimensional automaton results in a model that is weaker in terms of recognition power.
1;Markus Holzer;Christian Rauch;The Range of State Complexities of Languages Resulting from the Cascade Product—The Unary Case (Extended Abstract);We investigate the state complexity of languages resulting from the cascade product of two minimal deterministic finite automata with n and m states, respectively. More precisely we study the magic number problem of the cascade product operation and show what range of complexities can be produced in case the left automaton is unary, that is, has only a singleton letter alphabet. Here we distinguish the cases when the involved automata are reset automata, permutation automata, permutation-reset automata, or do not have any restriction on their structure. It turns out that the picture on the obtained state complexities of the cascade product is diverse, and for all cases, except where the left automaton is a unary permutation(-reset) or a deterministic finite automaton without structural restrictions, and the right one is a reset automaton or a deterministic finite automaton without structural restrictions, we are able to identify state sizes that cannot be reached—these numbers are called “magic.”
1;Christian Rauch;Markus Holzer;The Range of State Complexities of Languages Resulting from the Cascade Product—The Unary Case (Extended Abstract);We investigate the state complexity of languages resulting from the cascade product of two minimal deterministic finite automata with n and m states, respectively. More precisely we study the magic number problem of the cascade product operation and show what range of complexities can be produced in case the left automaton is unary, that is, has only a singleton letter alphabet. Here we distinguish the cases when the involved automata are reset automata, permutation automata, permutation-reset automata, or do not have any restriction on their structure. It turns out that the picture on the obtained state complexities of the cascade product is diverse, and for all cases, except where the left automaton is a unary permutation(-reset) or a deterministic finite automaton without structural restrictions, and the right one is a reset automaton or a deterministic finite automaton without structural restrictions, we are able to identify state sizes that cannot be reached—these numbers are called “magic.”
1;Cinzia Di Giusto;Laetitia Laversa, Etienne Lozes;Guessing the Buffer Bound for k-Synchronizability;A communicating system is \(k\)-synchronizable if all of the message sequence charts representing the executions can be divided into slices of k sends followed by k receptions. It was previously shown that, for a fixed given k, one could decide whether a communicating system is \(k\)-synchronizable. This result is interesting because the reachability problem can be solved for \(k\)-synchronizable systems. However, the decision procedure assumes that the bound k is fixed. In this paper we improve this result and show that it is possible to decide if such a bound k exists.
1;Laetitia Laversa;Cinzia Di Giusto, Etienne Lozes;Guessing the Buffer Bound for k-Synchronizability;A communicating system is \(k\)-synchronizable if all of the message sequence charts representing the executions can be divided into slices of k sends followed by k receptions. It was previously shown that, for a fixed given k, one could decide whether a communicating system is \(k\)-synchronizable. This result is interesting because the reachability problem can be solved for \(k\)-synchronizable systems. However, the decision procedure assumes that the bound k is fixed. In this paper we improve this result and show that it is possible to decide if such a bound k exists.
1;Etienne Lozes;Cinzia Di Giusto, Laetitia Laversa;Guessing the Buffer Bound for k-Synchronizability;A communicating system is \(k\)-synchronizable if all of the message sequence charts representing the executions can be divided into slices of k sends followed by k receptions. It was previously shown that, for a fixed given k, one could decide whether a communicating system is \(k\)-synchronizable. This result is interesting because the reachability problem can be solved for \(k\)-synchronizable systems. However, the decision procedure assumes that the bound k is fixed. In this paper we improve this result and show that it is possible to decide if such a bound k exists.
1;Stefan Hoffmann;;State Complexity of Permutation and Related Decision Problems on Alphabetical Pattern Constraints;We investigate the state complexity of the permutation operation, or the commutative closure, on Alphabetical Pattern Constraints (APC). This class corresponds to level 3/2 of the Straubing-Thérien hierarchy and includes the finite, the piecewise-testable, or \(\mathcal J\)-trivial, and the \(\mathcal R\)-trivial and \(\mathcal L\)-trivial languages. We give a sharp state complexity bound expressed in terms of the longest strings in the unary projection languages of an associated finite language. This bound is already sharp for the subclass of finite languages. Additionally, for two subclasses, we give sharp bounds expressed in terms of the size of a recognizing input automaton and the size of the alphabet. Lastly, we investigate the inclusion and universality problem on APCs up to permutational equivalence. These two problems are known to be \(\textsf {PSPACE}\)-complete on APCs in general, even for fixed alphabets. However, we show them to be decidable in polynomial time for fixed alphabets if we only want to solve them up to permutational equivalence.
1;Diana Geneva;Georgi Shopov, Stoyan Mihov;Algorithms for Probabilistic and Stochastic Subsequential Failure Transducers;This paper introduces a framework for building probabilistic models with subsequential failure transducers. We first show how various types of subsequential transducers commonly used in natural language processing are represented by probabilistic and conditional probabilistic subsequential failure transducers. Afterwards we introduce efficient algorithms for composition of conditional probabilistic subsequential transducers with probabilistic subsequential failure transducers and weight pushing (canonization) of probabilistic subsequential failure transducers. Those algorithms are applicable to many tasks for representing probabilistic models with subsequential failure transducers. One such task is the construction of the \(HCLG\) weighted transducer used in speech recognition which we describe in detail. At the end, empirical results and comparison between the presented \(HCLG\) failure weighted transducer and the standard \(HCLG\) weighted transducer constructions are shown.
1;Georgi Shopov;Diana Geneva, Stoyan Mihov;Algorithms for Probabilistic and Stochastic Subsequential Failure Transducers;This paper introduces a framework for building probabilistic models with subsequential failure transducers. We first show how various types of subsequential transducers commonly used in natural language processing are represented by probabilistic and conditional probabilistic subsequential failure transducers. Afterwards we introduce efficient algorithms for composition of conditional probabilistic subsequential transducers with probabilistic subsequential failure transducers and weight pushing (canonization) of probabilistic subsequential failure transducers. Those algorithms are applicable to many tasks for representing probabilistic models with subsequential failure transducers. One such task is the construction of the \(HCLG\) weighted transducer used in speech recognition which we describe in detail. At the end, empirical results and comparison between the presented \(HCLG\) failure weighted transducer and the standard \(HCLG\) weighted transducer constructions are shown.
1;Stoyan Mihov;Diana Geneva, Georgi Shopov;Algorithms for Probabilistic and Stochastic Subsequential Failure Transducers;This paper introduces a framework for building probabilistic models with subsequential failure transducers. We first show how various types of subsequential transducers commonly used in natural language processing are represented by probabilistic and conditional probabilistic subsequential failure transducers. Afterwards we introduce efficient algorithms for composition of conditional probabilistic subsequential transducers with probabilistic subsequential failure transducers and weight pushing (canonization) of probabilistic subsequential failure transducers. Those algorithms are applicable to many tasks for representing probabilistic models with subsequential failure transducers. One such task is the construction of the \(HCLG\) weighted transducer used in speech recognition which we describe in detail. At the end, empirical results and comparison between the presented \(HCLG\) failure weighted transducer and the standard \(HCLG\) weighted transducer constructions are shown.
1;Andreas Maletti;Teodora Nasz, Kevin Stier, Markus Ulbricht;Ambiguity Hierarchies for Weighted Tree Automata;Weighted tree automata (WTA) extend classical weighted automata (WA) to the non-linear structure of trees. The expressive power of WA with varying degrees of ambiguity has been extensively studied. Unambiguous, finitely ambiguous, and polynomially ambiguous WA over the tropical (as well as the arctic) semiring strictly increase in expressive power. The recently developed pumping results of Mazowiecki and Riveros (STACS 2018) are lifted to trees in order to achieve the same strict hierarchy for WTA over the tropical (as well as the arctic) semiring.
1;Teodora Nasz;Andreas Maletti, Kevin Stier, Markus Ulbricht;Ambiguity Hierarchies for Weighted Tree Automata;Weighted tree automata (WTA) extend classical weighted automata (WA) to the non-linear structure of trees. The expressive power of WA with varying degrees of ambiguity has been extensively studied. Unambiguous, finitely ambiguous, and polynomially ambiguous WA over the tropical (as well as the arctic) semiring strictly increase in expressive power. The recently developed pumping results of Mazowiecki and Riveros (STACS 2018) are lifted to trees in order to achieve the same strict hierarchy for WTA over the tropical (as well as the arctic) semiring.
1;Kevin Stier;Andreas Maletti, Teodora Nasz, Markus Ulbricht;Ambiguity Hierarchies for Weighted Tree Automata;Weighted tree automata (WTA) extend classical weighted automata (WA) to the non-linear structure of trees. The expressive power of WA with varying degrees of ambiguity has been extensively studied. Unambiguous, finitely ambiguous, and polynomially ambiguous WA over the tropical (as well as the arctic) semiring strictly increase in expressive power. The recently developed pumping results of Mazowiecki and Riveros (STACS 2018) are lifted to trees in order to achieve the same strict hierarchy for WTA over the tropical (as well as the arctic) semiring.
1;Markus Ulbricht;Andreas Maletti, Teodora Nasz, Kevin Stier;Ambiguity Hierarchies for Weighted Tree Automata;Weighted tree automata (WTA) extend classical weighted automata (WA) to the non-linear structure of trees. The expressive power of WA with varying degrees of ambiguity has been extensively studied. Unambiguous, finitely ambiguous, and polynomially ambiguous WA over the tropical (as well as the arctic) semiring strictly increase in expressive power. The recently developed pumping results of Mazowiecki and Riveros (STACS 2018) are lifted to trees in order to achieve the same strict hierarchy for WTA over the tropical (as well as the arctic) semiring.
1;Martin Kutrib;Luca Prigioniero;Boolean Kernels of Context-Free Languages;While the closure of a language family \(\mathscr {L}\) under certain language operations is the least family of languages which contains all members of \(\mathscr {L}\) and is closed under all of the operations, a kernel of \(\mathscr {L}\) is a maximal family of languages which is a sub-family of \(\mathscr {L}\) and is closed under all of the operations. Here we investigate properties of the Boolean kernels of the family of context-free languages. Additionally, languages that are mandatory for each Boolean kernel and languages that are optional for Boolean kernels are studied. That is, we consider the intersection of all Boolean kernels as well as their union. The expressive capacities of these families are addressed leading to a hierarchical structure. Further closure properties are considered. Furthermore, we study descriptional complexity aspects of these families, where languages are represented by context-free grammars with proofs attached. It turns out that the size trade-offs between all families in question and deterministic context-free languages are non-recursive. That is, one can choose an arbitrarily large recursive function f, but the gain in economy of description eventually exceeds f when changing from the latter system to the former.
1;Luca Prigioniero;Martin Kutrib;Boolean Kernels of Context-Free Languages;While the closure of a language family \(\mathscr {L}\) under certain language operations is the least family of languages which contains all members of \(\mathscr {L}\) and is closed under all of the operations, a kernel of \(\mathscr {L}\) is a maximal family of languages which is a sub-family of \(\mathscr {L}\) and is closed under all of the operations. Here we investigate properties of the Boolean kernels of the family of context-free languages. Additionally, languages that are mandatory for each Boolean kernel and languages that are optional for Boolean kernels are studied. That is, we consider the intersection of all Boolean kernels as well as their union. The expressive capacities of these families are addressed leading to a hierarchical structure. Further closure properties are considered. Furthermore, we study descriptional complexity aspects of these families, where languages are represented by context-free grammars with proofs attached. It turns out that the size trade-offs between all families in question and deterministic context-free languages are non-recursive. That is, one can choose an arbitrarily large recursive function f, but the gain in economy of description eventually exceeds f when changing from the latter system to the former.
1;Simone Faro;Stefano Scafiti;Efficient String Matching Based on a Two-Step Simulation of the Suffix Automaton;Automata play a very important role in the design of string matching algorithms as their use has always led to elegant and very efficient solutions in practice. In this paper, we present a new general approach to the exact string matching algorithm based on a non-standard efficient simulation of the suffix automaton of the pattern and give a specific efficient implementation of it. To show the effectiveness of our algorithm, we perform an extensive comparison against the most effective alternatives known in literature in terms of search speed and shift advancements. From our experimental results the new algorithm turns out to be very efficient in practical cases scaling much better when the length of the pattern increases, improving the search speed by nearly 10 times under suitable conditions.
1;Stefano Scafiti;Simone Faro;Efficient String Matching Based on a Two-Step Simulation of the Suffix Automaton;Automata play a very important role in the design of string matching algorithms as their use has always led to elegant and very efficient solutions in practice. In this paper, we present a new general approach to the exact string matching algorithm based on a non-standard efficient simulation of the suffix automaton of the pattern and give a specific efficient implementation of it. To show the effectiveness of our algorithm, we perform an extensive comparison against the most effective alternatives known in literature in terms of search speed and shift advancements. From our experimental results the new algorithm turns out to be very efficient in practical cases scaling much better when the length of the pattern increases, improving the search speed by nearly 10 times under suitable conditions.
1;Guy Arbitman;Shmuel T. Klein, Pierre Peterlongo, Dana Shapira;Approximate Hashing for Bioinformatics;The paper extends ideas from data compression by deduplication to the Bioinformatic field. The specific problems on which we show our approach to be useful are the clustering of a large set of DNA strings and the search for approximate matches of long substrings, both based on the design of what we call an approximate hashing function. The outcome of the new procedure is very similar to the clustering and search results obtained by accurate tools, but in much less time and with less required memory.
1;Shmuel T. Klein;Guy Arbitman, Pierre Peterlongo, Dana Shapira;Approximate Hashing for Bioinformatics;The paper extends ideas from data compression by deduplication to the Bioinformatic field. The specific problems on which we show our approach to be useful are the clustering of a large set of DNA strings and the search for approximate matches of long substrings, both based on the design of what we call an approximate hashing function. The outcome of the new procedure is very similar to the clustering and search results obtained by accurate tools, but in much less time and with less required memory.
1;Pierre Peterlongo;Guy Arbitman, Shmuel T. Klein, Dana Shapira;Approximate Hashing for Bioinformatics;The paper extends ideas from data compression by deduplication to the Bioinformatic field. The specific problems on which we show our approach to be useful are the clustering of a large set of DNA strings and the search for approximate matches of long substrings, both based on the design of what we call an approximate hashing function. The outcome of the new procedure is very similar to the clustering and search results obtained by accurate tools, but in much less time and with less required memory.
1;Dana Shapira;Guy Arbitman, Shmuel T. Klein, Pierre Peterlongo;Approximate Hashing for Bioinformatics;The paper extends ideas from data compression by deduplication to the Bioinformatic field. The specific problems on which we show our approach to be useful are the clustering of a large set of DNA strings and the search for approximate matches of long substrings, both based on the design of what we call an approximate hashing function. The outcome of the new procedure is very similar to the clustering and search results obtained by accurate tools, but in much less time and with less required memory.
2;Sebastian Maneth;;Static Garbage Collection;We present a method that allows to bound the sizes of intermediate trees in a composition of macro tree transducers. Macro tree transducers are a powerful model of tree translation which, for instance, includes all attribute grammars (seen as tree-to-tree translators). The idea of the method is to change a transducer in the composition so that it does not produce output nodes that will be removed (and ignored) by a subsequent transducer in the composition. This can be considered as a form of static garbage collection, where garbage is never produced by any transducer. We then give three applications of this result and show that (1) compositions of macro tree transducers can be computed in linear time with respect to the sum of sizes of input and output trees, (2) finiteness of ranges of compositions of macro tree transducers is decidable, and (3) the macro tree transducer composition hierarchy collapses when restricted to functions of linear size increase.
2;Alexander Okhotin;;Graph-Walking Automata: From Whence They Come, and Whither They are Bound;Graph-walking automata are finite automata walking on graphs given as an input. tree-walking automata and two-way finite automata are their well-known special cases. Graph-walking automata can be regarded both as a model of navigation in an unknown environment, and as a generic computing device, with the graph as the model of its memory. This paper presents the known results on these automata, ranging from their limitations in traversing graphs, studied already in the 1970s, to the recent work on the logical reversibility of their computations.
2;Robert Bakarić;Damir Korenčić, Strahil Ristov;Enumerated Automata Implementation of String Dictionaries;Over the last decade a considerable effort was invested into research on implementing string dictionaries. String dictionary is a data structure that bijectively maps a set of strings to a set of integers, and that is used in various index-based applications. A recent paper [18] can be regarded as a reference work on the subject of string dictionary implementations. Although very comprehensive, [18] does not cover the implementation of a string dictionary with the enumerated deterministic finite automaton, a data structure naturally suited for this purpose. We compare the results for the state-of-the-art compressed enumerated automaton with those presented in [18] on the same collection of data sets, and on the collection of natural language word lists. We show that our string dictionary implementation is a competitive variant for different types of data, especially when dealing with large sets of strings, and when strings have more similarity between them. In particular, our method presents as a prominent solution for storing DNA motifs and words of inflected natural languages. We provide the code used for the experiments.
2;Damir Korenčić;Robert Bakarić, Strahil Ristov;Enumerated Automata Implementation of String Dictionaries;Over the last decade a considerable effort was invested into research on implementing string dictionaries. String dictionary is a data structure that bijectively maps a set of strings to a set of integers, and that is used in various index-based applications. A recent paper [18] can be regarded as a reference work on the subject of string dictionary implementations. Although very comprehensive, [18] does not cover the implementation of a string dictionary with the enumerated deterministic finite automaton, a data structure naturally suited for this purpose. We compare the results for the state-of-the-art compressed enumerated automaton with those presented in [18] on the same collection of data sets, and on the collection of natural language word lists. We show that our string dictionary implementation is a competitive variant for different types of data, especially when dealing with large sets of strings, and when strings have more similarity between them. In particular, our method presents as a prominent solution for storing DNA motifs and words of inflected natural languages. We provide the code used for the experiments.
2;Strahil Ristov;Robert Bakarić, Damir Korenčić;Enumerated Automata Implementation of String Dictionaries;Over the last decade a considerable effort was invested into research on implementing string dictionaries. String dictionary is a data structure that bijectively maps a set of strings to a set of integers, and that is used in various index-based applications. A recent paper [18] can be regarded as a reference work on the subject of string dictionary implementations. Although very comprehensive, [18] does not cover the implementation of a string dictionary with the enumerated deterministic finite automaton, a data structure naturally suited for this purpose. We compare the results for the state-of-the-art compressed enumerated automaton with those presented in [18] on the same collection of data sets, and on the collection of natural language word lists. We show that our string dictionary implementation is a competitive variant for different types of data, especially when dealing with large sets of strings, and when strings have more similarity between them. In particular, our method presents as a prominent solution for storing DNA motifs and words of inflected natural languages. We provide the code used for the experiments.
2;Gilad Baruch;Shmuel T. Klein, Dana Shapira;New Approaches for Context Sensitive Flash Codes;Rewriting codes for flash memory enable the multiple usage of the same storage space, under the constraint that 0-bits can be changed into 1-bits, but not vice versa. Context sensitive rewriting codes extend this idea by incorporating also information gathered from surrounding bits. Several new and better context sensitive rewriting codes based on automata are presented and analyzed. Empirical simulations show a good match with the theoretical results.
2;Shmuel T. Klein;Gilad Baruch, Dana Shapira;New Approaches for Context Sensitive Flash Codes;Rewriting codes for flash memory enable the multiple usage of the same storage space, under the constraint that 0-bits can be changed into 1-bits, but not vice versa. Context sensitive rewriting codes extend this idea by incorporating also information gathered from surrounding bits. Several new and better context sensitive rewriting codes based on automata are presented and analyzed. Empirical simulations show a good match with the theoretical results.
2;Dana Shapira;Gilad Baruch, Shmuel T. Klein;New Approaches for Context Sensitive Flash Codes;Rewriting codes for flash memory enable the multiple usage of the same storage space, under the constraint that 0-bits can be changed into 1-bits, but not vice versa. Context sensitive rewriting codes extend this idea by incorporating also information gathered from surrounding bits. Several new and better context sensitive rewriting codes based on automata are presented and analyzed. Empirical simulations show a good match with the theoretical results.
2;A. Baskar;R. Ramanujam, S. P. Suresh;Dolev-Yao Theory with Associative Blindpair Operators;In the context of modeling cryptographic tools like blind signatures and homomorphic encryption, the Dolev-Yao model is typically extended with an operator over which encryption is distributive. The intruder deduction problem has a non-elementary upper bound when the extended operator is an Abelian group operator. Here we show that the intruder deduction problem is DEXPTIME-complete when we restrict the operator to satisfy only the associative property. We propose an automata-based analysis for the upper bound and use the reachability problem for alternating pushdown systems to show the lower bound.
2;R. Ramanujam;A. Baskar, S. P. Suresh;Dolev-Yao Theory with Associative Blindpair Operators;In the context of modeling cryptographic tools like blind signatures and homomorphic encryption, the Dolev-Yao model is typically extended with an operator over which encryption is distributive. The intruder deduction problem has a non-elementary upper bound when the extended operator is an Abelian group operator. Here we show that the intruder deduction problem is DEXPTIME-complete when we restrict the operator to satisfy only the associative property. We propose an automata-based analysis for the upper bound and use the reachability problem for alternating pushdown systems to show the lower bound.
2;S. P. Suresh;A. Baskar, R. Ramanujam;Dolev-Yao Theory with Associative Blindpair Operators;In the context of modeling cryptographic tools like blind signatures and homomorphic encryption, the Dolev-Yao model is typically extended with an operator over which encryption is distributive. The intruder deduction problem has a non-elementary upper bound when the extended operator is an Abelian group operator. Here we show that the intruder deduction problem is DEXPTIME-complete when we restrict the operator to satisfy only the associative property. We propose an automata-based analysis for the upper bound and use the reachability problem for alternating pushdown systems to show the lower bound.
2;Simon Beier;Markus Holzer;Semi-linear Lattices and Right One-Way Jumping Finite Automata (Extended Abstract);Right one-way jumping automata (ROWJFAs) are an automaton model that was recently introduced for processing the input in a discontinuous way. In [S. Beier, M. Holzer: Properties of right one-way jumping finite automata. In Proc. 20th DCFS, number 10952 in LNCS, 2018] it was shown that the permutation closed languages accepted by ROWJFAs are exactly those with a finite number of positive Myhill-Nerode classes. Here a Myhill-Nerode equivalence class \([w]_L\) of a language L is said to be positive if w belongs to L. Obviously, this notion of positive Myhill-Nerode classes generalizes to sets of vectors of natural numbers. We give a characterization of the linear sets of vectors with a finite number of positive Myhill-Nerode classes, which uses rational cones. Furthermore, we investigate when a set of vectors can be decomposed as a finite union of sets of vectors with a finite number of positive Myhill-Nerode classes. A crucial role is played by lattices, which are special semi-linear sets that are defined as a natural way to extend “the pattern” of a linear set to the whole set of vectors of natural numbers in a given dimension. We show connections of lattices to the Myhill-Nerode relation and to rational cones. Some of these results will be used to give characterization results about ROWJFAs with multiple initial states. For binary alphabets we show connections of these and related automata to counter automata.
2;Markus Holzer;Simon Beier;Semi-linear Lattices and Right One-Way Jumping Finite Automata (Extended Abstract);Right one-way jumping automata (ROWJFAs) are an automaton model that was recently introduced for processing the input in a discontinuous way. In [S. Beier, M. Holzer: Properties of right one-way jumping finite automata. In Proc. 20th DCFS, number 10952 in LNCS, 2018] it was shown that the permutation closed languages accepted by ROWJFAs are exactly those with a finite number of positive Myhill-Nerode classes. Here a Myhill-Nerode equivalence class \([w]_L\) of a language L is said to be positive if w belongs to L. Obviously, this notion of positive Myhill-Nerode classes generalizes to sets of vectors of natural numbers. We give a characterization of the linear sets of vectors with a finite number of positive Myhill-Nerode classes, which uses rational cones. Furthermore, we investigate when a set of vectors can be decomposed as a finite union of sets of vectors with a finite number of positive Myhill-Nerode classes. A crucial role is played by lattices, which are special semi-linear sets that are defined as a natural way to extend “the pattern” of a linear set to the whole set of vectors of natural numbers in a given dimension. We show connections of lattices to the Myhill-Nerode relation and to rational cones. Some of these results will be used to give characterization results about ROWJFAs with multiple initial states. For binary alphabets we show connections of these and related automata to counter automata.
2;Johanna Björklund;Frank Drewes, Giorgio Satta;Z-Automata for Compact and Direct Representation of Unranked Tree Languages;Unranked tree languages are valuable in natural language processing for modelling dependency trees. We introduce a new type of automaton for unranked tree languages, called Z-automaton, that is tailored for this particular application. The Z-automaton offers a compact form of representation, and unlike the closely related notion of stepwise automata, does not require a binary encoding of its input. We establish an arc-factored normal form, and prove the membership problem of Z-automata in normal form to be in \( O \left( mn \right) \), where m is the size of the transition table of the Z-automaton and n is the size of the input tree.
2;Frank Drewes;Johanna Björklund, Giorgio Satta;Z-Automata for Compact and Direct Representation of Unranked Tree Languages;Unranked tree languages are valuable in natural language processing for modelling dependency trees. We introduce a new type of automaton for unranked tree languages, called Z-automaton, that is tailored for this particular application. The Z-automaton offers a compact form of representation, and unlike the closely related notion of stepwise automata, does not require a binary encoding of its input. We establish an arc-factored normal form, and prove the membership problem of Z-automata in normal form to be in \( O \left( mn \right) \), where m is the size of the transition table of the Z-automaton and n is the size of the input tree.
2;Giorgio Satta;Johanna Björklund, Frank Drewes;Z-Automata for Compact and Direct Representation of Unranked Tree Languages;Unranked tree languages are valuable in natural language processing for modelling dependency trees. We introduce a new type of automaton for unranked tree languages, called Z-automaton, that is tailored for this particular application. The Z-automaton offers a compact form of representation, and unlike the closely related notion of stepwise automata, does not require a binary encoding of its input. We establish an arc-factored normal form, and prove the membership problem of Z-automata in normal form to be in \( O \left( mn \right) \), where m is the size of the transition table of the Z-automaton and n is the size of the input tree.
2;Angelo Borsotti;Luca Breveglieri, Stefano Crespi Reghizzi, Angelo Morzenti;A Benchmark Production Tool for Regular Expressions;We describe a new tool, named REgen, that generates regular expressions (RE) to be used as test cases, and that generates also synthetic benchmarks for exercising and measuring the performance of RE-based software libraries and applications. Each group of REs is randomly generated and satisfies a user-specified set of constraints, such as length, nesting depth, operator arity, repetition depth, and syntax tree balancing. In addition to such parameters, other features are chosen by the tool. An RE group may include REs that are ambiguous, or that define the same regular language but differ with respect to their syntactic structure. A benchmark is a collection of RE groups that have a user-specified numerosity and distribution, together with a representative sample of texts for each RE in the collection. We present two generation algorithms for RE groups and for benchmarks. Experimental results are reported for a large benchmark we used to compare the performance of different RE parsing algorithms. The tool REgen and the RE benchmark are publicly available and fill a gap in supporting tools for the development and evaluation of RE applications.
2;Luca Breveglieri;Angelo Borsotti, Stefano Crespi Reghizzi, Angelo Morzenti;A Benchmark Production Tool for Regular Expressions;We describe a new tool, named REgen, that generates regular expressions (RE) to be used as test cases, and that generates also synthetic benchmarks for exercising and measuring the performance of RE-based software libraries and applications. Each group of REs is randomly generated and satisfies a user-specified set of constraints, such as length, nesting depth, operator arity, repetition depth, and syntax tree balancing. In addition to such parameters, other features are chosen by the tool. An RE group may include REs that are ambiguous, or that define the same regular language but differ with respect to their syntactic structure. A benchmark is a collection of RE groups that have a user-specified numerosity and distribution, together with a representative sample of texts for each RE in the collection. We present two generation algorithms for RE groups and for benchmarks. Experimental results are reported for a large benchmark we used to compare the performance of different RE parsing algorithms. The tool REgen and the RE benchmark are publicly available and fill a gap in supporting tools for the development and evaluation of RE applications.
2;Stefano Crespi Reghizzi;Angelo Borsotti, Luca Breveglieri, Angelo Morzenti;A Benchmark Production Tool for Regular Expressions;We describe a new tool, named REgen, that generates regular expressions (RE) to be used as test cases, and that generates also synthetic benchmarks for exercising and measuring the performance of RE-based software libraries and applications. Each group of REs is randomly generated and satisfies a user-specified set of constraints, such as length, nesting depth, operator arity, repetition depth, and syntax tree balancing. In addition to such parameters, other features are chosen by the tool. An RE group may include REs that are ambiguous, or that define the same regular language but differ with respect to their syntactic structure. A benchmark is a collection of RE groups that have a user-specified numerosity and distribution, together with a representative sample of texts for each RE in the collection. We present two generation algorithms for RE groups and for benchmarks. Experimental results are reported for a large benchmark we used to compare the performance of different RE parsing algorithms. The tool REgen and the RE benchmark are publicly available and fill a gap in supporting tools for the development and evaluation of RE applications.
2;Angelo Morzenti;Angelo Borsotti, Luca Breveglieri, Stefano Crespi Reghizzi;A Benchmark Production Tool for Regular Expressions;We describe a new tool, named REgen, that generates regular expressions (RE) to be used as test cases, and that generates also synthetic benchmarks for exercising and measuring the performance of RE-based software libraries and applications. Each group of REs is randomly generated and satisfies a user-specified set of constraints, such as length, nesting depth, operator arity, repetition depth, and syntax tree balancing. In addition to such parameters, other features are chosen by the tool. An RE group may include REs that are ambiguous, or that define the same regular language but differ with respect to their syntactic structure. A benchmark is a collection of RE groups that have a user-specified numerosity and distribution, together with a representative sample of texts for each RE in the collection. We present two generation algorithms for RE groups and for benchmarks. Experimental results are reported for a large benchmark we used to compare the performance of different RE parsing algorithms. The tool REgen and the RE benchmark are publicly available and fill a gap in supporting tools for the development and evaluation of RE applications.
2;Shuhei Denzumi;;New Algorithms for Manipulating Sequence BDDs;Sequence binary decision diagram (SeqBDD) is a data structure to represent and manipulate sets of strings. This is a variant of zero-suppressed binary decision diagram (ZDD) that manipulates combinatorial sets. Nowadays, binary decision diagrams (BDDs) and its family have been recognized as an important data structure to manipulate discrete structures. SeqBDD has some set manipulation operations inherited from ZDD, but the number of the operations is not enough to deal with a wide variety of requests in string processing area. In this paper, we propose 50 new algorithms for manipulating SeqBDDs. We divide the operations into three categories and list up them. We also analyzed the time and space complexities of some new algorithms.
2;Akio Fujiyoshi;Daniel Průša;A Simple Extension to Finite Tree Automata for Defining Sets of Labeled, Connected Graphs;This paper introduces spanning tree automata (ST automata) usable for defining sets of labeled, connected graphs. The automata are simply obtained by extending ordinary top-down finite tree automata for labeled, ordered trees. It is shown that ST automata can define any finite set of labeled, connected graphs, and also some subclasses of infinite sets of graphs that can represent the structure of chemical molecules. Although the membership problem for ST automata is NP-complete, an efficient software was developed which supports a practical use of ST automata in chemoinformatics as well as in other fields.
2;Daniel Průša;Akio Fujiyoshi;A Simple Extension to Finite Tree Automata for Defining Sets of Labeled, Connected Graphs;This paper introduces spanning tree automata (ST automata) usable for defining sets of labeled, connected graphs. The automata are simply obtained by extending ordinary top-down finite tree automata for labeled, ordered trees. It is shown that ST automata can define any finite set of labeled, connected graphs, and also some subclasses of infinite sets of graphs that can represent the structure of chemical molecules. Although the membership problem for ST automata is NP-complete, an efficient software was developed which supports a practical use of ST automata in chemoinformatics as well as in other fields.
2;Zoltán Fülöp;Andreas Maletti;Composition Closure of Linear Weighted Extended Top-Down Tree Transducers;Linear weighted extended top-down tree transducers with regular look-ahead and with weights from a semiring are formal models that are used in syntax-based statistical machine translation. The composition hierarchies of some restricted versions of such weighted tree transducers (also without regular look-ahead) are considered. In particular, combinations of the restrictions of \(\varepsilon \)-freeness (all rules consume input), nondeletion, and strictness (all rules produce output) are considered. The composition hierarchy is shown to be finite for all but one \(\varepsilon \)-free variant of these weighted transducers over any commutative semiring.
2;Andreas Maletti;Zoltán Fülöp;Composition Closure of Linear Weighted Extended Top-Down Tree Transducers;Linear weighted extended top-down tree transducers with regular look-ahead and with weights from a semiring are formal models that are used in syntax-based statistical machine translation. The composition hierarchies of some restricted versions of such weighted tree transducers (also without regular look-ahead) are considered. In particular, combinations of the restrictions of \(\varepsilon \)-freeness (all rules consume input), nondeletion, and strictness (all rules produce output) are considered. The composition hierarchy is shown to be finite for all but one \(\varepsilon \)-free variant of these weighted transducers over any commutative semiring.
2;Yo-Sub Han;Hwee Kim, Yusei Masuda, Shinnosuke Seki;A General Architecture of Oritatami Systems for Simulating Arbitrary Finite Automata;In this paper, we propose an architecture of oritatami systems with which one can simulate an arbitrary nondeterministic finite automaton (NFA) in a unified manner. The oritatami system is known to be Turing-universal but the simulation available so far requires 542 bead types and \(O(t^4 \log ^2 t)\) steps in order to simulate t steps of a Turing machine. The architecture we propose employs only 329 bead types and requires just \(O(t |Q|^4 |\varSigma |^2)\) steps to simulate an NFA with a state set Q working on a word of length t over an alphabet \(\varSigma \).
2;Hwee Kim;Yo-Sub Han, Yusei Masuda, Shinnosuke Seki;A General Architecture of Oritatami Systems for Simulating Arbitrary Finite Automata;In this paper, we propose an architecture of oritatami systems with which one can simulate an arbitrary nondeterministic finite automaton (NFA) in a unified manner. The oritatami system is known to be Turing-universal but the simulation available so far requires 542 bead types and \(O(t^4 \log ^2 t)\) steps in order to simulate t steps of a Turing machine. The architecture we propose employs only 329 bead types and requires just \(O(t |Q|^4 |\varSigma |^2)\) steps to simulate an NFA with a state set Q working on a word of length t over an alphabet \(\varSigma \).
2;Yusei Masuda;Yo-Sub Han, Hwee Kim, Shinnosuke Seki;A General Architecture of Oritatami Systems for Simulating Arbitrary Finite Automata;In this paper, we propose an architecture of oritatami systems with which one can simulate an arbitrary nondeterministic finite automaton (NFA) in a unified manner. The oritatami system is known to be Turing-universal but the simulation available so far requires 542 bead types and \(O(t^4 \log ^2 t)\) steps in order to simulate t steps of a Turing machine. The architecture we propose employs only 329 bead types and requires just \(O(t |Q|^4 |\varSigma |^2)\) steps to simulate an NFA with a state set Q working on a word of length t over an alphabet \(\varSigma \).
2;Shinnosuke Seki;Yo-Sub Han, Hwee Kim, Yusei Masuda;A General Architecture of Oritatami Systems for Simulating Arbitrary Finite Automata;In this paper, we propose an architecture of oritatami systems with which one can simulate an arbitrary nondeterministic finite automaton (NFA) in a unified manner. The oritatami system is known to be Turing-universal but the simulation available so far requires 542 bead types and \(O(t^4 \log ^2 t)\) steps in order to simulate t steps of a Turing machine. The architecture we propose employs only 329 bead types and requires just \(O(t |Q|^4 |\varSigma |^2)\) steps to simulate an NFA with a state set Q working on a word of length t over an alphabet \(\varSigma \).
2;Michal Hospodár;;Descriptional Complexity of Power and Positive Closure on Convex Languages;We study the descriptional complexity of the k-th power and positive closure operations on the classes of prefix-, suffix-, factor-, and subword-free, -closed, and -convex regular languages, and on the classes of right, left, two-sided, and all-sided ideal languages. We show that the upper bound kn on the nondeterministic complexity of the k-th power in the class of regular languages is tight for closed and convex classes, while in the remaining classes, the tight upper bound is \(k(n-1)+1\). Next we show that the upper bound n on the nondeterministic complexity of the positive closure operation in the class of regular languages is tight in all considered classes except for classes of factor-closed and subword-closed languages, where the complexity is one. All our worst-case examples are described over a unary or binary alphabet, except for witnesses for the k-th power on subword-closed and subword-convex languages which are described over a ternary alphabet. Moreover, whenever a binary alphabet is used for describing a worst-case example, it is optimal in the sense that the corresponding upper bounds cannot be met by a language over a unary alphabet. The most interesting result is the description of a binary factor-closed language meeting the upper bound kn for the k-th power. To get this result, we use a method which enables us to avoid tedious descriptions of fooling sets. We also provide some results concerning the deterministic state complexity of these two operations on the classes of free, ideal, and closed languages.
2;Stavros Konstantinidis;Mitja Mastnak, Juraj Šebej;Partitioning a Symmetric Rational Relation into Two Asymmetric Rational Relations;We consider the problem of partitioning effectively a given symmetric (and irreflexive) rational relation R into two asymmetric rational relations. This problem is motivated by a recent method of embedding an R-independent language into one that is maximal R-independent, where the method requires to use an asymmetric partition of R. We solve the problem when R is realized by a zero-avoiding transducer (with some bound k): if the absolute value of the input-output length discrepancy of a computation exceeds k then the length discrepancy of the computation cannot become zero. This class of relations properly contains the recognizable, the left synchronous, and the right synchronous relations. We leave the asymmetric partition problem open when R is not zero-avoiding. We also show examples of total word-orderings for which there is a relation R that cannot be partitioned into two asymmetric rational relations with respect to the given word-orderings.
2;Mitja Mastnak;Stavros Konstantinidis, Juraj Šebej;Partitioning a Symmetric Rational Relation into Two Asymmetric Rational Relations;We consider the problem of partitioning effectively a given symmetric (and irreflexive) rational relation R into two asymmetric rational relations. This problem is motivated by a recent method of embedding an R-independent language into one that is maximal R-independent, where the method requires to use an asymmetric partition of R. We solve the problem when R is realized by a zero-avoiding transducer (with some bound k): if the absolute value of the input-output length discrepancy of a computation exceeds k then the length discrepancy of the computation cannot become zero. This class of relations properly contains the recognizable, the left synchronous, and the right synchronous relations. We leave the asymmetric partition problem open when R is not zero-avoiding. We also show examples of total word-orderings for which there is a relation R that cannot be partitioned into two asymmetric rational relations with respect to the given word-orderings.
2;Juraj Šebej;Stavros Konstantinidis, Mitja Mastnak;Partitioning a Symmetric Rational Relation into Two Asymmetric Rational Relations;We consider the problem of partitioning effectively a given symmetric (and irreflexive) rational relation R into two asymmetric rational relations. This problem is motivated by a recent method of embedding an R-independent language into one that is maximal R-independent, where the method requires to use an asymmetric partition of R. We solve the problem when R is realized by a zero-avoiding transducer (with some bound k): if the absolute value of the input-output length discrepancy of a computation exceeds k then the length discrepancy of the computation cannot become zero. This class of relations properly contains the recognizable, the left synchronous, and the right synchronous relations. We leave the asymmetric partition problem open when R is not zero-avoiding. We also show examples of total word-orderings for which there is a relation R that cannot be partitioned into two asymmetric rational relations with respect to the given word-orderings.
2;Stavros Konstantinidis;Nelma Moreira, João Pires, Rogério Reis;Partial Derivatives of Regular Expressions over Alphabet-Invariant and User-Defined Labels;We are interested in regular expressions that represent word relations in an alphabet-invariant way—for example, the set of all word pairs u, v where v is a prefix of u independently of what the alphabet is. This is the second part of a recent paper on this topic which focused on labelled graphs (transducers and automata) with alphabet-invariant and user-defined labels. In this paper we study derivatives of regular expressions over labels (atomic objects) in some set B. These labels can be any strings as long as the strings represent subsets of a certain monoid. We show that one can define partial derivative labelled graphs of type B expressions, whose transition labels can be elements of another label set X as long as X and B refer to the same monoid. We also show how to use derivatives directly to decide whether a given word pair is in the relation of a regular expression over pairing specs. Set specs and pairing specs are useful label sets allowing one to express languages and relations over large alphabets in a natural and compact way.
2;Nelma Moreira;Stavros Konstantinidis, João Pires, Rogério Reis;Partial Derivatives of Regular Expressions over Alphabet-Invariant and User-Defined Labels;We are interested in regular expressions that represent word relations in an alphabet-invariant way—for example, the set of all word pairs u, v where v is a prefix of u independently of what the alphabet is. This is the second part of a recent paper on this topic which focused on labelled graphs (transducers and automata) with alphabet-invariant and user-defined labels. In this paper we study derivatives of regular expressions over labels (atomic objects) in some set B. These labels can be any strings as long as the strings represent subsets of a certain monoid. We show that one can define partial derivative labelled graphs of type B expressions, whose transition labels can be elements of another label set X as long as X and B refer to the same monoid. We also show how to use derivatives directly to decide whether a given word pair is in the relation of a regular expression over pairing specs. Set specs and pairing specs are useful label sets allowing one to express languages and relations over large alphabets in a natural and compact way.
2;João Pires;Stavros Konstantinidis, Nelma Moreira, Rogério Reis;Partial Derivatives of Regular Expressions over Alphabet-Invariant and User-Defined Labels;We are interested in regular expressions that represent word relations in an alphabet-invariant way—for example, the set of all word pairs u, v where v is a prefix of u independently of what the alphabet is. This is the second part of a recent paper on this topic which focused on labelled graphs (transducers and automata) with alphabet-invariant and user-defined labels. In this paper we study derivatives of regular expressions over labels (atomic objects) in some set B. These labels can be any strings as long as the strings represent subsets of a certain monoid. We show that one can define partial derivative labelled graphs of type B expressions, whose transition labels can be elements of another label set X as long as X and B refer to the same monoid. We also show how to use derivatives directly to decide whether a given word pair is in the relation of a regular expression over pairing specs. Set specs and pairing specs are useful label sets allowing one to express languages and relations over large alphabets in a natural and compact way.
2;Rogério Reis;Stavros Konstantinidis, Nelma Moreira, João Pires;Partial Derivatives of Regular Expressions over Alphabet-Invariant and User-Defined Labels;We are interested in regular expressions that represent word relations in an alphabet-invariant way—for example, the set of all word pairs u, v where v is a prefix of u independently of what the alphabet is. This is the second part of a recent paper on this topic which focused on labelled graphs (transducers and automata) with alphabet-invariant and user-defined labels. In this paper we study derivatives of regular expressions over labels (atomic objects) in some set B. These labels can be any strings as long as the strings represent subsets of a certain monoid. We show that one can define partial derivative labelled graphs of type B expressions, whose transition labels can be elements of another label set X as long as X and B refer to the same monoid. We also show how to use derivatives directly to decide whether a given word pair is in the relation of a regular expression over pairing specs. Set specs and pairing specs are useful label sets allowing one to express languages and relations over large alphabets in a natural and compact way.
2;Martin Kutrib;Andreas Malcher, Matthias Wendlandt;Input-Driven Multi-counter Automata;The model of deterministic input-driven multi-counter automata is introduced and studied. On such devices, the input letters uniquely determine the operations on the underlying data structure that is consisting of multiple counters. We study the computational power of the resulting language families and compare them with known language families inside the Chomsky hierarchy. In addition, it is possible to prove a proper counter hierarchy depending on the alphabet size. This means that any input alphabet induces an upper bound which depends on the alphabet size only, such that \(k+1\) counters are more powerful than k counters as long as k is less than this bound. The hierarchy interestingly collapses at the level of the bound. Furthermore, we investigate the closure properties of the language families. Finally, the undecidability of the emptiness problem is derived for input-driven two-counter automata.
2;Andreas Malcher;Martin Kutrib, Matthias Wendlandt;Input-Driven Multi-counter Automata;The model of deterministic input-driven multi-counter automata is introduced and studied. On such devices, the input letters uniquely determine the operations on the underlying data structure that is consisting of multiple counters. We study the computational power of the resulting language families and compare them with known language families inside the Chomsky hierarchy. In addition, it is possible to prove a proper counter hierarchy depending on the alphabet size. This means that any input alphabet induces an upper bound which depends on the alphabet size only, such that \(k+1\) counters are more powerful than k counters as long as k is less than this bound. The hierarchy interestingly collapses at the level of the bound. Furthermore, we investigate the closure properties of the language families. Finally, the undecidability of the emptiness problem is derived for input-driven two-counter automata.
2;Matthias Wendlandt;Martin Kutrib, Andreas Malcher;Input-Driven Multi-counter Automata;The model of deterministic input-driven multi-counter automata is introduced and studied. On such devices, the input letters uniquely determine the operations on the underlying data structure that is consisting of multiple counters. We study the computational power of the resulting language families and compare them with known language families inside the Chomsky hierarchy. In addition, it is possible to prove a proper counter hierarchy depending on the alphabet size. This means that any input alphabet induces an upper bound which depends on the alphabet size only, such that \(k+1\) counters are more powerful than k counters as long as k is less than this bound. The hierarchy interestingly collapses at the level of the bound. Furthermore, we investigate the closure properties of the language families. Finally, the undecidability of the emptiness problem is derived for input-driven two-counter automata.
2;František Mráz;Daniel Průša, Michael Wehar;Two-Dimensional Pattern Matching Against Basic Picture Languages;Given a two-dimensional array of symbols and a picture language over a finite alphabet, we study the problem of finding rectangular subarrays of the array that belong to the picture language. We formulate four particular problems – finding maximum, minimum, any or all match(es) – and describe algorithms solving them for basic classes of picture languages, including local picture languages and picture languages accepted by deterministic on-line tessellation automata or deterministic four-way finite automata. We also prove that the matching problems cannot be solved for the class of local picture languages in linear time unless the problem of triangle finding is solvable in quadratic time. This shows there is a fundamental difference in the pattern matching complexity regarding the one-dimensional and two-dimensional setting.
2;Daniel Průša;František Mráz, Michael Wehar;Two-Dimensional Pattern Matching Against Basic Picture Languages;Given a two-dimensional array of symbols and a picture language over a finite alphabet, we study the problem of finding rectangular subarrays of the array that belong to the picture language. We formulate four particular problems – finding maximum, minimum, any or all match(es) – and describe algorithms solving them for basic classes of picture languages, including local picture languages and picture languages accepted by deterministic on-line tessellation automata or deterministic four-way finite automata. We also prove that the matching problems cannot be solved for the class of local picture languages in linear time unless the problem of triangle finding is solvable in quadratic time. This shows there is a fundamental difference in the pattern matching complexity regarding the one-dimensional and two-dimensional setting.
2;Michael Wehar;František Mráz, Daniel Průša;Two-Dimensional Pattern Matching Against Basic Picture Languages;Given a two-dimensional array of symbols and a picture language over a finite alphabet, we study the problem of finding rectangular subarrays of the array that belong to the picture language. We formulate four particular problems – finding maximum, minimum, any or all match(es) – and describe algorithms solving them for basic classes of picture languages, including local picture languages and picture languages accepted by deterministic on-line tessellation automata or deterministic four-way finite automata. We also prove that the matching problems cannot be solved for the class of local picture languages in linear time unless the problem of triangle finding is solvable in quadratic time. This shows there is a fundamental difference in the pattern matching complexity regarding the one-dimensional and two-dimensional setting.
3;Anne Condon;;On Design and Analysis of Chemical Reaction Network Algorithms;The fields of DNA computing, molecular programming and DNA nanotechnology offer exciting new possibilities for organizing and manipulating matter at the nanoscale, and prompt us to think about computation in creative new ways. Molecules reacting in a test tube change state, and counts of molecules can in principle be used to simulate counter machines, all in a highly distributed, asynchronous and stochastic manner. In this talk I’ll give some background on models of molecular programming, focusing on Stochastic Chemical Reaction Networks, and describe some beautiful results and open problems pertaining to this model of computing.
3;Stavros Konstantinidis;Nelma Moreira, Rogério Reis, Joshua Young;Regular Expressions and Transducers over Alphabet-Invariant and User-Defined Labels;We are interested in regular expressions and transducers that represent word relations in an alphabet-invariant way—for example, the set of all word pairs u, v where v is a prefix of u independently of what the alphabet is. Current software systems of formal language objects do not have a mechanism to define such objects. We define transducers in which transition labels involve what we call set specifications, some of which are alphabet invariant. In fact, we consider automata-type objects, called labelled graphs, where each transition label can be any string, as long as that string represents a subset of a certain monoid. Then, the behaviour of the labelled graph is a subset of that monoid. We do the same for regular expressions. We obtain extensions of known algorithmic constructions on ordinary regular expressions and transducers, including partial derivative based methods, at the broad level of labelled graphs such that the computational efficiency of the extended constructions is not sacrificed. Then, for regular expressions with set specs we obtain a direct partial derivative method for membership. For transducers with set specs we obtain further algorithms that can be applied to questions about independent regular languages, in particular the witness version of the property satisfaction question.
3;Nelma Moreira;Stavros Konstantinidis, Rogério Reis, Joshua Young;Regular Expressions and Transducers over Alphabet-Invariant and User-Defined Labels;We are interested in regular expressions and transducers that represent word relations in an alphabet-invariant way—for example, the set of all word pairs u, v where v is a prefix of u independently of what the alphabet is. Current software systems of formal language objects do not have a mechanism to define such objects. We define transducers in which transition labels involve what we call set specifications, some of which are alphabet invariant. In fact, we consider automata-type objects, called labelled graphs, where each transition label can be any string, as long as that string represents a subset of a certain monoid. Then, the behaviour of the labelled graph is a subset of that monoid. We do the same for regular expressions. We obtain extensions of known algorithmic constructions on ordinary regular expressions and transducers, including partial derivative based methods, at the broad level of labelled graphs such that the computational efficiency of the extended constructions is not sacrificed. Then, for regular expressions with set specs we obtain a direct partial derivative method for membership. For transducers with set specs we obtain further algorithms that can be applied to questions about independent regular languages, in particular the witness version of the property satisfaction question.
3;Rogério Reis;Stavros Konstantinidis, Nelma Moreira, Joshua Young;Regular Expressions and Transducers over Alphabet-Invariant and User-Defined Labels;We are interested in regular expressions and transducers that represent word relations in an alphabet-invariant way—for example, the set of all word pairs u, v where v is a prefix of u independently of what the alphabet is. Current software systems of formal language objects do not have a mechanism to define such objects. We define transducers in which transition labels involve what we call set specifications, some of which are alphabet invariant. In fact, we consider automata-type objects, called labelled graphs, where each transition label can be any string, as long as that string represents a subset of a certain monoid. Then, the behaviour of the labelled graph is a subset of that monoid. We do the same for regular expressions. We obtain extensions of known algorithmic constructions on ordinary regular expressions and transducers, including partial derivative based methods, at the broad level of labelled graphs such that the computational efficiency of the extended constructions is not sacrificed. Then, for regular expressions with set specs we obtain a direct partial derivative method for membership. For transducers with set specs we obtain further algorithms that can be applied to questions about independent regular languages, in particular the witness version of the property satisfaction question.
3;Joshua Young;Stavros Konstantinidis, Nelma Moreira, Rogério Reis;Regular Expressions and Transducers over Alphabet-Invariant and User-Defined Labels;We are interested in regular expressions and transducers that represent word relations in an alphabet-invariant way—for example, the set of all word pairs u, v where v is a prefix of u independently of what the alphabet is. Current software systems of formal language objects do not have a mechanism to define such objects. We define transducers in which transition labels involve what we call set specifications, some of which are alphabet invariant. In fact, we consider automata-type objects, called labelled graphs, where each transition label can be any string, as long as that string represents a subset of a certain monoid. Then, the behaviour of the labelled graph is a subset of that monoid. We do the same for regular expressions. We obtain extensions of known algorithmic constructions on ordinary regular expressions and transducers, including partial derivative based methods, at the broad level of labelled graphs such that the computational efficiency of the extended constructions is not sacrificed. Then, for regular expressions with set specs we obtain a direct partial derivative method for membership. For transducers with set specs we obtain further algorithms that can be applied to questions about independent regular languages, in particular the witness version of the property satisfaction question.
3;Martin Kutrib;Andreas Malcher, Matthias Wendlandt;Boosting Pushdown and Queue Machines by Preprocessing;Motivated by preprocessing devices occurring for example in the context of syntactic parsers or HTML sanitization, we study pairs of finite state transducers and deterministic machines such as pushdown automata or queue automata as language accepting devices, where the original input is translated by a finite state transducer to an input of the deterministic machine which eventually accepts or rejects the preprocessed input. As deterministic machines we study input-driven machines as well as reversible machines equipped with a pushdown store or a queue store. It turns out that the preprocessing boosts on the one hand the computational power of the machines in all four cases, but on the other hand preserves and adds some positive closure properties as well as decidable problems. Thus, the preprocessing extends the computational power moderately by retaining most of the nice properties of the original machine.
3;Andreas Malcher;Martin Kutrib, Matthias Wendlandt;Boosting Pushdown and Queue Machines by Preprocessing;Motivated by preprocessing devices occurring for example in the context of syntactic parsers or HTML sanitization, we study pairs of finite state transducers and deterministic machines such as pushdown automata or queue automata as language accepting devices, where the original input is translated by a finite state transducer to an input of the deterministic machine which eventually accepts or rejects the preprocessed input. As deterministic machines we study input-driven machines as well as reversible machines equipped with a pushdown store or a queue store. It turns out that the preprocessing boosts on the one hand the computational power of the machines in all four cases, but on the other hand preserves and adds some positive closure properties as well as decidable problems. Thus, the preprocessing extends the computational power moderately by retaining most of the nice properties of the original machine.
3;Matthias Wendlandt;Martin Kutrib, Andreas Malcher;Boosting Pushdown and Queue Machines by Preprocessing;Motivated by preprocessing devices occurring for example in the context of syntactic parsers or HTML sanitization, we study pairs of finite state transducers and deterministic machines such as pushdown automata or queue automata as language accepting devices, where the original input is translated by a finite state transducer to an input of the deterministic machine which eventually accepts or rejects the preprocessed input. As deterministic machines we study input-driven machines as well as reversible machines equipped with a pushdown store or a queue store. It turns out that the preprocessing boosts on the one hand the computational power of the machines in all four cases, but on the other hand preserves and adds some positive closure properties as well as decidable problems. Thus, the preprocessing extends the computational power moderately by retaining most of the nice properties of the original machine.
3;Sylvain Lombardy;Jacques Sakarovitch;The Validity of Weighted Automata;This invited talk presents the work conducted on the problems that arise when dealing with weighted automata containing \(\varepsilon \)-transitions: how to define the behaviour of such automata in which the presence of \(\varepsilon \)-circuits results in infinite summations, and second how to eliminate the \(\varepsilon \)-transitions in an automaton whose behaviour has been recognised to be well-defined. The origin of this work is the implementation, in the Awali platform [19], of an \(\varepsilon \)-transition removal algorithm for automata with weight in \(\mathbb {Q}\) or \(\mathbb {R}\), a case that had never been treated before in the rich literature on the subject of \(\varepsilon \)-transition removal algorithms (cf. [16] for a survey). The results of this work have been published in [14].
3;Jacques Sakarovitch;Sylvain Lombardy;The Validity of Weighted Automata;This invited talk presents the work conducted on the problems that arise when dealing with weighted automata containing \(\varepsilon \)-transitions: how to define the behaviour of such automata in which the presence of \(\varepsilon \)-circuits results in infinite summations, and second how to eliminate the \(\varepsilon \)-transitions in an automaton whose behaviour has been recognised to be well-defined. The origin of this work is the implementation, in the Awali platform [19], of an \(\varepsilon \)-transition removal algorithm for automata with weight in \(\mathbb {Q}\) or \(\mathbb {R}\), a case that had never been treated before in the rich literature on the subject of \(\varepsilon \)-transition removal algorithms (cf. [16] for a survey). The results of this work have been published in [14].
3;Cyril Allauzen;Michael D. Riley;Algorithms for Weighted Finite Automata with Failure Transitions;In this paper we extend several weighted finite automata (WFA) algorithms to automata with failure transitions (\(\varphi \)-WFAs). Failure transitions, which are taken only when no immediate match is possible at a given state, are used to compactly represent automata and have many applications. Efficient algorithms to intersect two \(\varphi \)-WFAs, to remove failure transitions, to trim, and to compute (over \(\mathbb {R}_+\)) the shortest distance in a \(\varphi \)-WFA are presented.
3;Michael D. Riley;Cyril Allauzen;Algorithms for Weighted Finite Automata with Failure Transitions;In this paper we extend several weighted finite automata (WFA) algorithms to automata with failure transitions (\(\varphi \)-WFAs). Failure transitions, which are taken only when no immediate match is possible at a given state, are used to compactly represent automata and have many applications. Efficient algorithms to intersect two \(\varphi \)-WFAs, to remove failure transitions, to trim, and to compute (over \(\mathbb {R}_+\)) the shortest distance in a \(\varphi \)-WFA are presented.
3;Samira Attou;Ludovic Mignot, Djelloul Ziadi;The Bottom-Up Position Tree Automaton and Its Compact Version;The conversion of a given regular tree expression into a tree automaton has been widely studied. However, classical interpretations are based upon a Top-Down interpretation of tree automata. In this paper, we propose a new construction based on Gluskov’s one using a Bottom-Up interpretation. One of the main goals of this technique is to consider as a next step the links with deterministic recognizers, consideration that cannot be performed with classical Top-Down approaches. Furthermore, we exhibit a method to factorize transitions of tree automata and show that this technique is particularly interesting for the Glushkov constructions, by considering natural factorizations due to the structure of regular expression.
3;Ludovic Mignot;Samira Attou, Djelloul Ziadi;The Bottom-Up Position Tree Automaton and Its Compact Version;The conversion of a given regular tree expression into a tree automaton has been widely studied. However, classical interpretations are based upon a Top-Down interpretation of tree automata. In this paper, we propose a new construction based on Gluskov’s one using a Bottom-Up interpretation. One of the main goals of this technique is to consider as a next step the links with deterministic recognizers, consideration that cannot be performed with classical Top-Down approaches. Furthermore, we exhibit a method to factorize transitions of tree automata and show that this technique is particularly interesting for the Glushkov constructions, by considering natural factorizations due to the structure of regular expression.
3;Djelloul Ziadi;Samira Attou, Ludovic Mignot;The Bottom-Up Position Tree Automaton and Its Compact Version;The conversion of a given regular tree expression into a tree automaton has been widely studied. However, classical interpretations are based upon a Top-Down interpretation of tree automata. In this paper, we propose a new construction based on Gluskov’s one using a Bottom-Up interpretation. One of the main goals of this technique is to consider as a next step the links with deterministic recognizers, consideration that cannot be performed with classical Top-Down approaches. Furthermore, we exhibit a method to factorize transitions of tree automata and show that this technique is particularly interesting for the Glushkov constructions, by considering natural factorizations due to the structure of regular expression.
3;Laurent Bartholdi;Thibault Godin, Ines Klimann, Matthieu Picantin;A New Hierarchy for Automaton Semigroups;We define a new strict and computable hierarchy for the family of automaton semigroups, which reflects the various asymptotic behaviors of the state-activity growth. This hierarchy extends that given by Sidki for automaton groups, and also gives new insights into the latter. Its exponential part coincides with a notion of entropy for some associated automata.
3;Thibault Godin;Laurent Bartholdi, Ines Klimann, Matthieu Picantin;A New Hierarchy for Automaton Semigroups;We define a new strict and computable hierarchy for the family of automaton semigroups, which reflects the various asymptotic behaviors of the state-activity growth. This hierarchy extends that given by Sidki for automaton groups, and also gives new insights into the latter. Its exponential part coincides with a notion of entropy for some associated automata.
3;Ines Klimann;Laurent Bartholdi, Thibault Godin, Matthieu Picantin;A New Hierarchy for Automaton Semigroups;We define a new strict and computable hierarchy for the family of automaton semigroups, which reflects the various asymptotic behaviors of the state-activity growth. This hierarchy extends that given by Sidki for automaton groups, and also gives new insights into the latter. Its exponential part coincides with a notion of entropy for some associated automata.
3;Matthieu Picantin;Laurent Bartholdi, Thibault Godin, Ines Klimann;A New Hierarchy for Automaton Semigroups;We define a new strict and computable hierarchy for the family of automaton semigroups, which reflects the various asymptotic behaviors of the state-activity growth. This hierarchy extends that given by Sidki for automaton groups, and also gives new insights into the latter. Its exponential part coincides with a notion of entropy for some associated automata.
3;Mikhail V. Berlinkov;Cyril Nicaud;Synchronizing Random Almost-Group Automata;In this paper we address the question of synchronizing random automata in the critical settings of almost-group automata. Group automata are automata where all letters act as permutations on the set of states, and they are not synchronizing (unless they have one state). In almost-group automata, one of the letters acts as a permutation on \(n-1\) states, and the others as permutations. We prove that this small change is enough for automata to become synchronizing with high probability. More precisely, we establish that the probability that a strongly connected almost-group automaton is not synchronizing is \(\frac{2^{k-1}-1}{n^{2(k-1)}}(1+o(1))\), for a k-letter alphabet.
3;Cyril Nicaud;Mikhail V. Berlinkov;Synchronizing Random Almost-Group Automata;In this paper we address the question of synchronizing random automata in the critical settings of almost-group automata. Group automata are automata where all letters act as permutations on the set of states, and they are not synchronizing (unless they have one state). In almost-group automata, one of the letters acts as a permutation on \(n-1\) states, and the others as permutations. We prove that this small change is enough for automata to become synchronizing with high probability. More precisely, we establish that the probability that a strongly connected almost-group automaton is not synchronizing is \(\frac{2^{k-1}-1}{n^{2(k-1)}}(1+o(1))\), for a k-letter alphabet.
3;Johanna Björklund;Frank Drewes, Anna Jonsson;A Comparison of Two N-Best Extraction Methods for Weighted Tree Automata;We conduct a comparative study of two state-of-the-art algorithms for extracting the N best trees from a weighted tree automaton (wta). The algorithms are Best Trees, which uses a priority queue to structure the search space, and Filtered Runs, which is based on an algorithm by Huang and Chiang that extracts N best runs, implemented as part of the Tiburon wta toolkit. The experiments are run on four data sets, each consisting of a sequence of wtas of increasing sizes. Our conclusion is that Best Trees can be recommended when the input wtas exhibit a high or unpredictable degree of nondeterminism, whereas Filtered Runs is the better option when the input wtas are large but essentially deterministic.
3;Frank Drewes;Johanna Björklund, Anna Jonsson;A Comparison of Two N-Best Extraction Methods for Weighted Tree Automata;We conduct a comparative study of two state-of-the-art algorithms for extracting the N best trees from a weighted tree automaton (wta). The algorithms are Best Trees, which uses a priority queue to structure the search space, and Filtered Runs, which is based on an algorithm by Huang and Chiang that extracts N best runs, implemented as part of the Tiburon wta toolkit. The experiments are run on four data sets, each consisting of a sequence of wtas of increasing sizes. Our conclusion is that Best Trees can be recommended when the input wtas exhibit a high or unpredictable degree of nondeterminism, whereas Filtered Runs is the better option when the input wtas are large but essentially deterministic.
3;Anna Jonsson;Johanna Björklund, Frank Drewes;A Comparison of Two N-Best Extraction Methods for Weighted Tree Automata;We conduct a comparative study of two state-of-the-art algorithms for extracting the N best trees from a weighted tree automaton (wta). The algorithms are Best Trees, which uses a priority queue to structure the search space, and Filtered Runs, which is based on an algorithm by Huang and Chiang that extracts N best runs, implemented as part of the Tiburon wta toolkit. The experiments are run on four data sets, each consisting of a sequence of wtas of increasing sizes. Our conclusion is that Best Trees can be recommended when the input wtas exhibit a high or unpredictable degree of nondeterminism, whereas Filtered Runs is the better option when the input wtas are large but essentially deterministic.
3;Janusz A. Brzozowski;Lila Kari, Bai Li, Marek Szykuła;State Complexity of Overlap Assembly;The state complexity of a regular language \(L_m\) is the number m of states in a minimal deterministic finite automaton (DFA) accepting \(L_m\). The state complexity of a regularity-preserving binary operation on regular languages is defined as the maximal state complexity of the result of the operation where the two operands range over all languages of state complexities \(\le m\) and \(\le n\), respectively. We find a tight upper bound on the state complexity of the binary operation overlap assembly on regular languages. This operation was introduced by Csuhaj-Varjú, Petre, and Vaszil to model the process of self-assembly of two linear DNA strands into a longer DNA strand, provided that their ends “overlap”. We prove that the state complexity of the overlap assembly of languages \(L_m\) and \(L_n\), where \(m\ge 2\) and \(n\ge 1\), is at most \(2 (m-1) 3^{n-1} + 2^n\). Moreover, for \(m \ge 2\) and \(n \ge 3\) there exist languages \(L_m\) and \(L_n\) over an alphabet of size n whose overlap assembly meets the upper bound and this bound cannot be met with smaller alphabets.
3;Lila Kari;Janusz A. Brzozowski, Bai Li, Marek Szykuła;State Complexity of Overlap Assembly;The state complexity of a regular language \(L_m\) is the number m of states in a minimal deterministic finite automaton (DFA) accepting \(L_m\). The state complexity of a regularity-preserving binary operation on regular languages is defined as the maximal state complexity of the result of the operation where the two operands range over all languages of state complexities \(\le m\) and \(\le n\), respectively. We find a tight upper bound on the state complexity of the binary operation overlap assembly on regular languages. This operation was introduced by Csuhaj-Varjú, Petre, and Vaszil to model the process of self-assembly of two linear DNA strands into a longer DNA strand, provided that their ends “overlap”. We prove that the state complexity of the overlap assembly of languages \(L_m\) and \(L_n\), where \(m\ge 2\) and \(n\ge 1\), is at most \(2 (m-1) 3^{n-1} + 2^n\). Moreover, for \(m \ge 2\) and \(n \ge 3\) there exist languages \(L_m\) and \(L_n\) over an alphabet of size n whose overlap assembly meets the upper bound and this bound cannot be met with smaller alphabets.
3;Bai Li;Janusz A. Brzozowski, Lila Kari, Marek Szykuła;State Complexity of Overlap Assembly;The state complexity of a regular language \(L_m\) is the number m of states in a minimal deterministic finite automaton (DFA) accepting \(L_m\). The state complexity of a regularity-preserving binary operation on regular languages is defined as the maximal state complexity of the result of the operation where the two operands range over all languages of state complexities \(\le m\) and \(\le n\), respectively. We find a tight upper bound on the state complexity of the binary operation overlap assembly on regular languages. This operation was introduced by Csuhaj-Varjú, Petre, and Vaszil to model the process of self-assembly of two linear DNA strands into a longer DNA strand, provided that their ends “overlap”. We prove that the state complexity of the overlap assembly of languages \(L_m\) and \(L_n\), where \(m\ge 2\) and \(n\ge 1\), is at most \(2 (m-1) 3^{n-1} + 2^n\). Moreover, for \(m \ge 2\) and \(n \ge 3\) there exist languages \(L_m\) and \(L_n\) over an alphabet of size n whose overlap assembly meets the upper bound and this bound cannot be met with smaller alphabets.
3;Marek Szykuła;Janusz A. Brzozowski, Lila Kari, Bai Li;State Complexity of Overlap Assembly;The state complexity of a regular language \(L_m\) is the number m of states in a minimal deterministic finite automaton (DFA) accepting \(L_m\). The state complexity of a regularity-preserving binary operation on regular languages is defined as the maximal state complexity of the result of the operation where the two operands range over all languages of state complexities \(\le m\) and \(\le n\), respectively. We find a tight upper bound on the state complexity of the binary operation overlap assembly on regular languages. This operation was introduced by Csuhaj-Varjú, Petre, and Vaszil to model the process of self-assembly of two linear DNA strands into a longer DNA strand, provided that their ends “overlap”. We prove that the state complexity of the overlap assembly of languages \(L_m\) and \(L_n\), where \(m\ge 2\) and \(n\ge 1\), is at most \(2 (m-1) 3^{n-1} + 2^n\). Moreover, for \(m \ge 2\) and \(n \ge 3\) there exist languages \(L_m\) and \(L_n\) over an alphabet of size n whose overlap assembly meets the upper bound and this bound cannot be met with smaller alphabets.
3;Marco Cognetta;Yo-Sub Han;Online Stochastic Pattern Matching;The pattern matching problem is to find all occurrences of a given pattern in an input text. In particular, we consider the case when the pattern is a stochastic regular language where each pattern string has its own probability. Our problem is to find all matching patterns—(start, end) indices in the text—whose probability is larger than a given threshold probability. A pattern matching procedure is frequently used on streaming data in several applications, and often it is very challenging to find the start index of a matching in streaming data. We design an efficient algorithm for the stochastic pattern matching problem over streaming data based on the transformation of the pattern PFA into a weighted automaton and a constant bound on the number of backtracks required to find a start index while reading the streaming input. We also employ heuristics that enable us to reduce the number of backtracks, which improves the practical runtime of our algorithm. We establish the tight theoretical runtime of the proposed algorithm and experimentally demonstrate its practical performance. Finally, we show a possible application of our algorithm to another stochastic pattern matching problem where we search for the maximum probability substring of a text that is a superstring of a specified string.
3;Yo-Sub Han;Marco Cognetta;Online Stochastic Pattern Matching;The pattern matching problem is to find all occurrences of a given pattern in an input text. In particular, we consider the case when the pattern is a stochastic regular language where each pattern string has its own probability. Our problem is to find all matching patterns—(start, end) indices in the text—whose probability is larger than a given threshold probability. A pattern matching procedure is frequently used on streaming data in several applications, and often it is very challenging to find the start index of a matching in streaming data. We design an efficient algorithm for the stochastic pattern matching problem over streaming data based on the transformation of the pattern PFA into a weighted automaton and a constant bound on the number of backtracks required to find a start index while reading the streaming input. We also employ heuristics that enable us to reduce the number of backtracks, which improves the practical runtime of our algorithm. We establish the tight theoretical runtime of the proposed algorithm and experimentally demonstrate its practical performance. Finally, we show a possible application of our algorithm to another stochastic pattern matching problem where we search for the maximum probability substring of a text that is a superstring of a specified string.
3;Sylvie Davies;;State Complexity of Reversals of Deterministic Finite Automata with Output;We investigate the worst-case state complexity of reversals of deterministic finite automata with output (DFAOs). In these automata, each state is assigned some output value, rather than simply being labelled final or non-final. This directly generalizes the well-studied problem of determining the worst-case state complexity of reversals of ordinary deterministic finite automata. If a DFAO has n states and k possible output values, there is a known upper bound of \(k^n\) for the state complexity of reversal. We show this bound can be reached with a ternary input alphabet. We conjecture it cannot be reached with a binary input alphabet except when \(k = 2\), and give a lower bound for the case \(3 \le k &lt. n\). We prove that the state complexity of reversal depends solely on the transition monoid of the DFAO and the mapping that assigns output values to states.
3;Justin DeBenedetto;David Chiang;Algorithms and Training for Weighted Multiset Automata and Regular Expressions;Multiset automata are a class of automata for which the symbols can be read in any order and obtain the same result. We investigate weighted multiset automata and show how to construct them from weighted regular expressions. We present training methods to learn the weights for weighted regular expressions and for general multiset automata from data. Finally, we examine situations in which inside weights can be computed more efficiently.
3;David Chiang;Justin DeBenedetto;Algorithms and Training for Weighted Multiset Automata and Regular Expressions;Multiset automata are a class of automata for which the symbols can be read in any order and obtain the same result. We investigate weighted multiset automata and show how to construct them from weighted regular expressions. We present training methods to learn the weights for weighted regular expressions and for general multiset automata from data. Finally, we examine situations in which inside weights can be computed more efficiently.
3;Antonio Di Stasio;Aniello Murano, Moshe Y. Vardi;Solving Parity Games: Explicit vs Symbolic;In this paper we provide a broad investigation of the symbolic approach for solving Parity Games. Specifically, we implement in a fresh tool, called , four symbolic algorithms to solve Parity Games and compare their performances to the corresponding explicit versions for different classes of games. By means of benchmarks, we show that for random games, even for constrained random games, explicit algorithms actually perform better than symbolic algorithms. The situation changes, however, for structured games, where symbolic algorithms seem to have the advantage. This suggests that when evaluating algorithms for parity-game solving, it would be useful to have real benchmarks and not only random benchmarks, as the common practice has been.
3;Aniello Murano;Antonio Di Stasio, Moshe Y. Vardi;Solving Parity Games: Explicit vs Symbolic;In this paper we provide a broad investigation of the symbolic approach for solving Parity Games. Specifically, we implement in a fresh tool, called , four symbolic algorithms to solve Parity Games and compare their performances to the corresponding explicit versions for different classes of games. By means of benchmarks, we show that for random games, even for constrained random games, explicit algorithms actually perform better than symbolic algorithms. The situation changes, however, for structured games, where symbolic algorithms seem to have the advantage. This suggests that when evaluating algorithms for parity-game solving, it would be useful to have real benchmarks and not only random benchmarks, as the common practice has been.
3;Moshe Y. Vardi;Antonio Di Stasio, Aniello Murano;Solving Parity Games: Explicit vs Symbolic;In this paper we provide a broad investigation of the symbolic approach for solving Parity Games. Specifically, we implement in a fresh tool, called , four symbolic algorithms to solve Parity Games and compare their performances to the corresponding explicit versions for different classes of games. By means of benchmarks, we show that for random games, even for constrained random games, explicit algorithms actually perform better than symbolic algorithms. The situation changes, however, for structured games, where symbolic algorithms seem to have the advantage. This suggests that when evaluating algorithms for parity-game solving, it would be useful to have real benchmarks and not only random benchmarks, as the common practice has been.
3;Stefan Gerdjikov;;Generalised Twinning Property;In this paper we consider the problem of sequentialisation of rational functions \(f:\varSigma ^*\rightarrow \mathcal{M}\). We introduce a class of monoids that includes infinitary groups, free monoids, tropical monoids and is closed under Cartesian Product. For this class of monoids we provide a sequentialisation construction for transducers and appropriately generalise the notion of Twinning Property. We provide a construction to test the Twinning Property for transducers over the considered class of monoids and prove that it is a necessary and sufficient condition for the sequentialisation construction to terminate.
3;Bruno Guillon;Giovanni Pighizzini, Luca Prigioniero;Non-self-embedding Grammars, Constant-Height Pushdown Automata, and Limited Automata;Non-self-embedding grammars are a restriction of context-free grammars which does not allow to describe recursive structures and, hence, which characterizes only the class of regular languages. A double exponential gap in size from non-self-embedding grammars to deterministic finite automata is known. The same size gap is also known from constant-height pushdown automata and 1-limited automata to deterministic finite automata. Constant-height pushdown automata and 1-limited automata are compared with non-self-embedding grammars. It is proved that non-self-embedding grammars and constant-height pushdown automata are polynomially related in size. Furthermore, a polynomial size simulation by 1-limited automata is presented. However, the converse transformation is proved to cost exponential.
3;Giovanni Pighizzini;Bruno Guillon, Luca Prigioniero;Non-self-embedding Grammars, Constant-Height Pushdown Automata, and Limited Automata;Non-self-embedding grammars are a restriction of context-free grammars which does not allow to describe recursive structures and, hence, which characterizes only the class of regular languages. A double exponential gap in size from non-self-embedding grammars to deterministic finite automata is known. The same size gap is also known from constant-height pushdown automata and 1-limited automata to deterministic finite automata. Constant-height pushdown automata and 1-limited automata are compared with non-self-embedding grammars. It is proved that non-self-embedding grammars and constant-height pushdown automata are polynomially related in size. Furthermore, a polynomial size simulation by 1-limited automata is presented. However, the converse transformation is proved to cost exponential.
3;Luca Prigioniero;Bruno Guillon, Giovanni Pighizzini;Non-self-embedding Grammars, Constant-Height Pushdown Automata, and Limited Automata;Non-self-embedding grammars are a restriction of context-free grammars which does not allow to describe recursive structures and, hence, which characterizes only the class of regular languages. A double exponential gap in size from non-self-embedding grammars to deterministic finite automata is known. The same size gap is also known from constant-height pushdown automata and 1-limited automata to deterministic finite automata. Constant-height pushdown automata and 1-limited automata are compared with non-self-embedding grammars. It is proved that non-self-embedding grammars and constant-height pushdown automata are polynomially related in size. Furthermore, a polynomial size simulation by 1-limited automata is presented. However, the converse transformation is proved to cost exponential.
3;Michal Hospodár;Markus Holzer;The Ranges of Accepting State Complexities of Languages Resulting From Some Operations;We examine the accepting state complexity, i.e., the minimal number of accepting states of deterministic finite automata (DFAs) for languages resulting from unary and binary operations on languages with accepting state complexity given as a parameter. This is continuation of the work of [J. Dassow: On the number of accepting states of finite automata, J. Autom., Lang. Comb., 21, 2016]. We solve most of the open problems mentioned thereof. In particular, we consider the operations of intersection, symmetric difference, right and left quotients, reversal, and permutation (on finite languages), where we obtain precise ranges of the accepting state complexities.
3;Markus Holzer;Michal Hospodár;The Ranges of Accepting State Complexities of Languages Resulting From Some Operations;We examine the accepting state complexity, i.e., the minimal number of accepting states of deterministic finite automata (DFAs) for languages resulting from unary and binary operations on languages with accepting state complexity given as a parameter. This is continuation of the work of [J. Dassow: On the number of accepting states of finite automata, J. Autom., Lang. Comb., 21, 2016]. We solve most of the open problems mentioned thereof. In particular, we consider the operations of intersection, symmetric difference, right and left quotients, reversal, and permutation (on finite languages), where we obtain precise ranges of the accepting state complexities.
3;Oscar H. Ibarra;Ian McQuillan;Semilinearity of Families of Languages;Techniques are developed for creating new and general language families of only semilinear languages, and for showing families only contain semilinear languages. It is shown that for language families \(\mathcal{L}\) that are semilinear full trios, the smallest full AFL containing the languages obtained by intersecting languages in \(\mathcal{L}\) with languages in \(\mathsf{NCM}\) (where \(\mathsf{NCM}\) is the family of languages accepted by \(\textsf {NFA}\)s augmented with reversal-bounded counters), is also semilinear. If these closure properties are effective, this also immediately implies decidability of membership, emptiness, and infiniteness for these general families. From the general techniques, new grammar systems are given that are extensions of well-known families of semilinear full trios, whereby it is implied that these extensions must only describe semilinear languages. This also implies positive decidability properties for the new systems. Some characterizations of the new families are also given.
3;Ian McQuillan;Oscar H. Ibarra;Semilinearity of Families of Languages;Techniques are developed for creating new and general language families of only semilinear languages, and for showing families only contain semilinear languages. It is shown that for language families \(\mathcal{L}\) that are semilinear full trios, the smallest full AFL containing the languages obtained by intersecting languages in \(\mathcal{L}\) with languages in \(\mathsf{NCM}\) (where \(\mathsf{NCM}\) is the family of languages accepted by \(\textsf {NFA}\)s augmented with reversal-bounded counters), is also semilinear. If these closure properties are effective, this also immediately implies decidability of membership, emptiness, and infiniteness for these general families. From the general techniques, new grammar systems are given that are extensions of well-known families of semilinear full trios, whereby it is implied that these extensions must only describe semilinear languages. This also implies positive decidability properties for the new systems. Some characterizations of the new families are also given.
3;Jozef Jirásek;Galina Jirásková;The Exact Complexity of Star-Complement-Star;We show that the state complexity of the star-complement-star operation is given by \(\frac{3}{2}f(n\,-\,1) \,+\, 2 f(n\,-\,2) \,+\, 2n \,-\,5\), where \(f(2)=2\) and \(f(n) = \sum _{i=1}^{n-2}{n\atopwithdelims ()i} f (n\,-\,i) \,+\,2\). The function f(n) counts the number of distinct resistances possible for n arbitrary resistors each connected in series or parallel with previous ones, or the number of labeled threshold graphs on n vertices, and \(f(n)\sim n!(1-\ln 2)/(\ln 2)^{n+1} =2^{n \log n - 0.91 n + o(n)}\). Our witness language is defined over a quaternary alphabet, and we strongly conjecture that the size of the alphabet cannot be decreased.
3;Galina Jirásková;Jozef Jirásek;The Exact Complexity of Star-Complement-Star;We show that the state complexity of the star-complement-star operation is given by \(\frac{3}{2}f(n\,-\,1) \,+\, 2 f(n\,-\,2) \,+\, 2n \,-\,5\), where \(f(2)=2\) and \(f(n) = \sum _{i=1}^{n-2}{n\atopwithdelims ()i} f (n\,-\,i) \,+\,2\). The function f(n) counts the number of distinct resistances possible for n arbitrary resistors each connected in series or parallel with previous ones, or the number of labeled threshold graphs on n vertices, and \(f(n)\sim n!(1-\ln 2)/(\ln 2)^{n+1} =2^{n \log n - 0.91 n + o(n)}\). Our witness language is defined over a quaternary alphabet, and we strongly conjecture that the size of the alphabet cannot be decreased.
4;Luca Aceto;Antonis Achilleos, Adrian Francalanza, Anna Ingólfsdóttir, Sævar Örn Kjartansson;On the Complexity of Determinizing Monitors;We examine the determinization of monitors. We demonstrate that every monitor is equivalent to a deterministic one, which is at most doubly exponential in size with respect to the original monitor. When monitors are described as CCS-like processes, this doubly-exponential bound is optimal. When (deterministic) monitors are described as finite automata (as their LTS), then they can be exponentially more succinct than their CCS process form.
4;Antonis Achilleos;Luca Aceto, Adrian Francalanza, Anna Ingólfsdóttir, Sævar Örn Kjartansson;On the Complexity of Determinizing Monitors;We examine the determinization of monitors. We demonstrate that every monitor is equivalent to a deterministic one, which is at most doubly exponential in size with respect to the original monitor. When monitors are described as CCS-like processes, this doubly-exponential bound is optimal. When (deterministic) monitors are described as finite automata (as their LTS), then they can be exponentially more succinct than their CCS process form.
4;Adrian Francalanza;Luca Aceto, Antonis Achilleos, Anna Ingólfsdóttir, Sævar Örn Kjartansson;On the Complexity of Determinizing Monitors;We examine the determinization of monitors. We demonstrate that every monitor is equivalent to a deterministic one, which is at most doubly exponential in size with respect to the original monitor. When monitors are described as CCS-like processes, this doubly-exponential bound is optimal. When (deterministic) monitors are described as finite automata (as their LTS), then they can be exponentially more succinct than their CCS process form.
4;Anna Ingólfsdóttir;Luca Aceto, Antonis Achilleos, Adrian Francalanza, Sævar Örn Kjartansson;On the Complexity of Determinizing Monitors;We examine the determinization of monitors. We demonstrate that every monitor is equivalent to a deterministic one, which is at most doubly exponential in size with respect to the original monitor. When monitors are described as CCS-like processes, this doubly-exponential bound is optimal. When (deterministic) monitors are described as finite automata (as their LTS), then they can be exponentially more succinct than their CCS process form.
4;Sævar Örn Kjartansson;Luca Aceto, Antonis Achilleos, Adrian Francalanza, Anna Ingólfsdóttir;On the Complexity of Determinizing Monitors;We examine the determinization of monitors. We demonstrate that every monitor is equivalent to a deterministic one, which is at most doubly exponential in size with respect to the original monitor. When monitors are described as CCS-like processes, this doubly-exponential bound is optimal. When (deterministic) monitors are described as finite automata (as their LTS), then they can be exponentially more succinct than their CCS process form.
4;Martin Berglund;Brink van der Merwe, Bruce Watson, Nicolaas Weideman;On the Semantics of Atomic Subgroups in Practical Regular Expressions;Most regular expression matching engines have operators and features to enhance the succinctness of classical regular expressions, such as interval quantifiers and regular lookahead. In addition, matching engines in for example Perl, Java, Ruby and .NET, also provide operators, such as atomic operators, that constrain the backtracking behavior of the engine. The most common use is to prevent needless backtracking, but the operators will often also change the language accepted. As such it is essential to develop a theoretical sound basis for the matching semantics of regular expressions with atomic operators. We here establish that atomic operators preserve regularity, but are exponentially more succinct for some languages. Further we investigate the state complexity of deterministic and non-deterministic finite automata accepting the language corresponding to a regular expression with atomic operators, and show that emptiness testing is PSPACE-complete.
4;Brink van der Merwe;Martin Berglund, Bruce Watson, Nicolaas Weideman;On the Semantics of Atomic Subgroups in Practical Regular Expressions;Most regular expression matching engines have operators and features to enhance the succinctness of classical regular expressions, such as interval quantifiers and regular lookahead. In addition, matching engines in for example Perl, Java, Ruby and .NET, also provide operators, such as atomic operators, that constrain the backtracking behavior of the engine. The most common use is to prevent needless backtracking, but the operators will often also change the language accepted. As such it is essential to develop a theoretical sound basis for the matching semantics of regular expressions with atomic operators. We here establish that atomic operators preserve regularity, but are exponentially more succinct for some languages. Further we investigate the state complexity of deterministic and non-deterministic finite automata accepting the language corresponding to a regular expression with atomic operators, and show that emptiness testing is PSPACE-complete.
4;Bruce Watson;Martin Berglund, Brink van der Merwe, Nicolaas Weideman;On the Semantics of Atomic Subgroups in Practical Regular Expressions;Most regular expression matching engines have operators and features to enhance the succinctness of classical regular expressions, such as interval quantifiers and regular lookahead. In addition, matching engines in for example Perl, Java, Ruby and .NET, also provide operators, such as atomic operators, that constrain the backtracking behavior of the engine. The most common use is to prevent needless backtracking, but the operators will often also change the language accepted. As such it is essential to develop a theoretical sound basis for the matching semantics of regular expressions with atomic operators. We here establish that atomic operators preserve regularity, but are exponentially more succinct for some languages. Further we investigate the state complexity of deterministic and non-deterministic finite automata accepting the language corresponding to a regular expression with atomic operators, and show that emptiness testing is PSPACE-complete.
4;Nicolaas Weideman;Martin Berglund, Brink van der Merwe, Bruce Watson;On the Semantics of Atomic Subgroups in Practical Regular Expressions;Most regular expression matching engines have operators and features to enhance the succinctness of classical regular expressions, such as interval quantifiers and regular lookahead. In addition, matching engines in for example Perl, Java, Ruby and .NET, also provide operators, such as atomic operators, that constrain the backtracking behavior of the engine. The most common use is to prevent needless backtracking, but the operators will often also change the language accepted. As such it is essential to develop a theoretical sound basis for the matching semantics of regular expressions with atomic operators. We here establish that atomic operators preserve regularity, but are exponentially more succinct for some languages. Further we investigate the state complexity of deterministic and non-deterministic finite automata accepting the language corresponding to a regular expression with atomic operators, and show that emptiness testing is PSPACE-complete.
4;Henrik Björklund;Johanna Björklund, Petter Ericson;On the Regularity and Learnability of Ordered DAG Languages;Order-Preserving DAG Grammars (OPDGs) is a subclass of Hyper-Edge Replacement Grammars that can be parsed in polynomial time. Their associated class of languages is known as Ordered DAG Languages, and the graphs they generate are characterised by being acyclic, rooted, and having a natural order on their nodes. OPDGs are useful in natural-language processing to model abstract meaning representations. We state and prove a Myhill-Nerode theorem for ordered DAG languages, and translate it into a MAT-learning algorithm for the same class. The algorithm infers a minimal OPDG G for the target language in time polynomial in G and the samples provided by the MAT oracle.
4;Johanna Björklund;Henrik Björklund, Petter Ericson;On the Regularity and Learnability of Ordered DAG Languages;Order-Preserving DAG Grammars (OPDGs) is a subclass of Hyper-Edge Replacement Grammars that can be parsed in polynomial time. Their associated class of languages is known as Ordered DAG Languages, and the graphs they generate are characterised by being acyclic, rooted, and having a natural order on their nodes. OPDGs are useful in natural-language processing to model abstract meaning representations. We state and prove a Myhill-Nerode theorem for ordered DAG languages, and translate it into a MAT-learning algorithm for the same class. The algorithm infers a minimal OPDG G for the target language in time polynomial in G and the samples provided by the MAT oracle.
4;Petter Ericson;Henrik Björklund, Johanna Björklund;On the Regularity and Learnability of Ordered DAG Languages;Order-Preserving DAG Grammars (OPDGs) is a subclass of Hyper-Edge Replacement Grammars that can be parsed in polynomial time. Their associated class of languages is known as Ordered DAG Languages, and the graphs they generate are characterised by being acyclic, rooted, and having a natural order on their nodes. OPDGs are useful in natural-language processing to model abstract meaning representations. We state and prove a Myhill-Nerode theorem for ordered DAG languages, and translate it into a MAT-learning algorithm for the same class. The algorithm infers a minimal OPDG G for the target language in time polynomial in G and the samples provided by the MAT oracle.
4;Henning Bordihn;Markus Holzer;On the Number of Active States in Deterministic and Nondeterministic Finite Automata;We introduce a new measure of descriptional complexity on finite automata, called the number of active states. Roughly speaking, the number of active states of an automaton A on input w counts the number of different states visited during the most economic computation of the automaton A for the word w. This concept generalizes to finite automata and regular languages in a straightforward way. We show that the number of active states of both finite automata and regular languages is computable, even with respect to nondeterministic finite automata. We further compare the number of active states to related measures for regular languages. In particular, we show incomparability to the radius of regular languages and that the difference between the number of active states and the total number of states needed in finite automata for a regular language can be of exponential order.
4;Markus Holzer;Henning Bordihn;On the Number of Active States in Deterministic and Nondeterministic Finite Automata;We introduce a new measure of descriptional complexity on finite automata, called the number of active states. Roughly speaking, the number of active states of an automaton A on input w counts the number of different states visited during the most economic computation of the automaton A for the word w. This concept generalizes to finite automata and regular languages in a straightforward way. We show that the number of active states of both finite automata and regular languages is computable, even with respect to nondeterministic finite automata. We further compare the number of active states to related measures for regular languages. In particular, we show incomparability to the radius of regular languages and that the difference between the number of active states and the total number of states needed in finite automata for a regular language can be of exponential order.
4;Janusz A. Brzozowski;Corwin Sinnamon;Complexity of Proper Prefix-Convex Regular Languages;A language L over an alphabet \(\varSigma \) is prefix-convex if, for any words \(x,y,z\in \varSigma ^*\), whenever x and xyz are in L, then so is xy. Prefix-convex languages include right-ideal, prefix-closed, and prefix-free languages, which were studied elsewhere. Here we concentrate on prefix-convex languages that do not belong to any one of these classes. we call such languages proper. We exhibit most complex proper prefix-convex languages, which meet the bounds for the size of the syntactic semigroup, reversal, complexity of atoms, star, product, and Boolean operations.
4;Corwin Sinnamon;Janusz A. Brzozowski;Complexity of Proper Prefix-Convex Regular Languages;A language L over an alphabet \(\varSigma \) is prefix-convex if, for any words \(x,y,z\in \varSigma ^*\), whenever x and xyz are in L, then so is xy. Prefix-convex languages include right-ideal, prefix-closed, and prefix-free languages, which were studied elsewhere. Here we concentrate on prefix-convex languages that do not belong to any one of these classes. we call such languages proper. We exhibit most complex proper prefix-convex languages, which meet the bounds for the size of the syntactic semigroup, reversal, complexity of atoms, star, product, and Boolean operations.
4;Claudia Cauli;Nir Piterman;Equivalence of Probabilistic $$\mu $$ -Calculus and p-Automata;An important characteristic of Kozen’s \(\mu \)-calculus is its strong connection with parity alternating tree automata. Here, we show that the probabilistic \(\mu \)-calculus \(\mu ^p\)-calculus and p-automata (parity alternating Markov chain automata) have an equally strong connection. Namely, for every \(\mu ^p\)-calculus formula we can construct a p-automaton that accepts exactly those Markov chains that satisfy the formula. For every p-automaton we can construct a \(\mu ^p\)-calculus formula satisfied in exactly those Markov chains that are accepted by the automaton. The translation in one direction relies on a normal form of the calculus and in the other direction on the usage of vectorial \(\mu ^p\)-calculus. The proofs use the game semantics of \(\mu ^p\)-calculus and automata to show that our translations are correct.
4;Nir Piterman;Claudia Cauli;Equivalence of Probabilistic $$\mu $$ -Calculus and p-Automata;An important characteristic of Kozen’s \(\mu \)-calculus is its strong connection with parity alternating tree automata. Here, we show that the probabilistic \(\mu \)-calculus \(\mu ^p\)-calculus and p-automata (parity alternating Markov chain automata) have an equally strong connection. Namely, for every \(\mu ^p\)-calculus formula we can construct a p-automaton that accepts exactly those Markov chains that satisfy the formula. For every p-automaton we can construct a \(\mu ^p\)-calculus formula satisfied in exactly those Markov chains that are accepted by the automaton. The translation in one direction relies on a normal form of the calculus and in the other direction on the usage of vectorial \(\mu ^p\)-calculus. The proofs use the game semantics of \(\mu ^p\)-calculus and automata to show that our translations are correct.
4;Robert Ferens;Marek Szykuła;Complexity of Bifix-Free Regular Languages;We study descriptive complexity properties of the class of regular bifix-free languages, which is the intersection of prefix-free and suffix-free regular languages. We show that there exist universal bifix-free languages that meet all the bounds for the state complexity of basic operations (Boolean operations, product, star, and reversal). This is in contrast with suffix-free languages, where it is known that there does not exist such languages. Then we present a stream of bifix-free languages that is most complex in terms of all basic operations, syntactic complexity, and the number of atoms and their complexities, which requires a superexponential alphabet. We also complete the previous results by characterizing state complexity of product, star, and reversal, and establishing tight upper bounds for atom complexities of bifix-free languages. Moreover, we consider the problem of the minimal size of an alphabet required to meet the bounds, and the problem of attainable values of state complexities (magic numbers).
4;Marek Szykuła;Robert Ferens;Complexity of Bifix-Free Regular Languages;We study descriptive complexity properties of the class of regular bifix-free languages, which is the intersection of prefix-free and suffix-free regular languages. We show that there exist universal bifix-free languages that meet all the bounds for the state complexity of basic operations (Boolean operations, product, star, and reversal). This is in contrast with suffix-free languages, where it is known that there does not exist such languages. Then we present a stream of bifix-free languages that is most complex in terms of all basic operations, syntactic complexity, and the number of atoms and their complexities, which requires a superexponential alphabet. We also complete the previous results by characterizing state complexity of product, star, and reversal, and establishing tight upper bounds for atom complexities of bifix-free languages. Moreover, we consider the problem of the minimal size of an alphabet required to meet the bounds, and the problem of attainable values of state complexities (magic numbers).
4;Henning Fernau;Lakshmanan Kuppusamy, Indhumathi Raman;Computational Completeness of Path-Structured Graph-Controlled Insertion-Deletion Systems;A graph-controlled insertion-deletion (GCID) system is a regulated extension of an insertion-deletion system. It has several components and each component contains some insertion-deletion rules. These components are the vertices of a directed control graph. A rule is applied to a string in a component and the resultant string is moved to the target component specified in the rule, describing the arcs of the control graph. We investigate which combinations of size parameters (the maximum number of components, the maximal length of the insertion string, the maximal length of the left context for insertion, the maximal length of the right context for insertion. a similar three restrictions with respect to deletion) are sufficient to maintain the computational completeness of such restricted systems with the additional restriction that the control graph is a path, thus, these results also hold for ins-del P systems.
4;Lakshmanan Kuppusamy;Henning Fernau, Indhumathi Raman;Computational Completeness of Path-Structured Graph-Controlled Insertion-Deletion Systems;A graph-controlled insertion-deletion (GCID) system is a regulated extension of an insertion-deletion system. It has several components and each component contains some insertion-deletion rules. These components are the vertices of a directed control graph. A rule is applied to a string in a component and the resultant string is moved to the target component specified in the rule, describing the arcs of the control graph. We investigate which combinations of size parameters (the maximum number of components, the maximal length of the insertion string, the maximal length of the left context for insertion, the maximal length of the right context for insertion. a similar three restrictions with respect to deletion) are sufficient to maintain the computational completeness of such restricted systems with the additional restriction that the control graph is a path, thus, these results also hold for ins-del P systems.
4;Indhumathi Raman;Henning Fernau, Lakshmanan Kuppusamy;Computational Completeness of Path-Structured Graph-Controlled Insertion-Deletion Systems;A graph-controlled insertion-deletion (GCID) system is a regulated extension of an insertion-deletion system. It has several components and each component contains some insertion-deletion rules. These components are the vertices of a directed control graph. A rule is applied to a string in a component and the resultant string is moved to the target component specified in the rule, describing the arcs of the control graph. We investigate which combinations of size parameters (the maximum number of components, the maximal length of the insertion string, the maximal length of the left context for insertion, the maximal length of the right context for insertion. a similar three restrictions with respect to deletion) are sufficient to maintain the computational completeness of such restricted systems with the additional restriction that the control graph is a path, thus, these results also hold for ins-del P systems.
4;Nathanaël Fijalkow;Hugo Gimbert, Edon Kelmendi, Denis Kuperberg;Stamina: Stabilisation Monoids in Automata Theory;We present Stamina, a tool solving three algorithmic problems in automata theory. First, compute the star height of a regular language, i.e. the minimal number of nested Kleene stars needed for expressing the language with a complement-free regular expression. Second, decide limitedness for regular cost functions. Third, decide whether a probabilistic leaktight automaton has value 1, i.e. whether a probabilistic leaktight automaton accepts words with probability arbitrarily close to 1.
4;Hugo Gimbert;Nathanaël Fijalkow, Edon Kelmendi, Denis Kuperberg;Stamina: Stabilisation Monoids in Automata Theory;We present Stamina, a tool solving three algorithmic problems in automata theory. First, compute the star height of a regular language, i.e. the minimal number of nested Kleene stars needed for expressing the language with a complement-free regular expression. Second, decide limitedness for regular cost functions. Third, decide whether a probabilistic leaktight automaton has value 1, i.e. whether a probabilistic leaktight automaton accepts words with probability arbitrarily close to 1.
4;Edon Kelmendi;Nathanaël Fijalkow, Hugo Gimbert, Denis Kuperberg;Stamina: Stabilisation Monoids in Automata Theory;We present Stamina, a tool solving three algorithmic problems in automata theory. First, compute the star height of a regular language, i.e. the minimal number of nested Kleene stars needed for expressing the language with a complement-free regular expression. Second, decide limitedness for regular cost functions. Third, decide whether a probabilistic leaktight automaton has value 1, i.e. whether a probabilistic leaktight automaton accepts words with probability arbitrarily close to 1.
4;Denis Kuperberg;Nathanaël Fijalkow, Hugo Gimbert, Edon Kelmendi;Stamina: Stabilisation Monoids in Automata Theory;We present Stamina, a tool solving three algorithmic problems in automata theory. First, compute the star height of a regular language, i.e. the minimal number of nested Kleene stars needed for expressing the language with a complement-free regular expression. Second, decide limitedness for regular cost functions. Third, decide whether a probabilistic leaktight automaton has value 1, i.e. whether a probabilistic leaktight automaton accepts words with probability arbitrarily close to 1.
4;Stefan Gerdjikov;Stoyan Mihov, Klaus U. Schulz;A Simple Method for Building Bimachines from Functional Finite-State Transducers;The standard construction of a bimachine from a functional transducer involves a preparation step for converting the transducer into an unambiguous transducer (A transducer is unambiguous if there exists at most one successful path for each label.). The conversion involves a specialized determinization. We introduce a new construction principle where the transducer is directly translated into a bimachine. For any input word accepted by the transducer the bimachine exactly imitates one successful path of the transducer. For some classes of transducers the new construction can build a bimachine with an exponentially lower number of states compared to the standard construction. We first present a simple and generic variant of the construction. A second specialized version leads to better complexity bounds in terms of the size of the bimachine.
4;Stoyan Mihov;Stefan Gerdjikov, Klaus U. Schulz;A Simple Method for Building Bimachines from Functional Finite-State Transducers;The standard construction of a bimachine from a functional transducer involves a preparation step for converting the transducer into an unambiguous transducer (A transducer is unambiguous if there exists at most one successful path for each label.). The conversion involves a specialized determinization. We introduce a new construction principle where the transducer is directly translated into a bimachine. For any input word accepted by the transducer the bimachine exactly imitates one successful path of the transducer. For some classes of transducers the new construction can build a bimachine with an exponentially lower number of states compared to the standard construction. We first present a simple and generic variant of the construction. A second specialized version leads to better complexity bounds in terms of the size of the bimachine.
4;Klaus U. Schulz;Stefan Gerdjikov, Stoyan Mihov;A Simple Method for Building Bimachines from Functional Finite-State Transducers;The standard construction of a bimachine from a functional transducer involves a preparation step for converting the transducer into an unambiguous transducer (A transducer is unambiguous if there exists at most one successful path for each label.). The conversion involves a specialized determinization. We introduce a new construction principle where the transducer is directly translated into a bimachine. For any input word accepted by the transducer the bimachine exactly imitates one successful path of the transducer. For some classes of transducers the new construction can build a bimachine with an exponentially lower number of states compared to the standard construction. We first present a simple and generic variant of the construction. A second specialized version leads to better complexity bounds in terms of the size of the bimachine.
4;Yo-Sub Han;Sang-Ki Ko;Alignment Distance of Regular Tree Languages;We consider the tree alignment distance problem between a tree and a regular tree language. The tree alignment distance is an alternative of the tree edit-distance, in which we construct an optimal alignment between two trees and compute its cost instead of directly computing the minimum cost of tree edits. The alignment distance is crucial for understanding the structural similarity between trees.
4;Sang-Ki Ko;Yo-Sub Han;Alignment Distance of Regular Tree Languages;We consider the tree alignment distance problem between a tree and a regular tree language. The tree alignment distance is an alternative of the tree edit-distance, in which we construct an optimal alignment between two trees and compute its cost instead of directly computing the minimum cost of tree edits. The alignment distance is crucial for understanding the structural similarity between trees.
4;Michal Hospodár;Galina Jirásková, Peter Mlynárčik;Nondeterministic Complexity of Operations on Free and Convex Languages;We study the nondeterministic state complexity of basic regular operations on the classes of prefix-, suffix-, factor-, and subword-free and -convex regular languages. For the operations of intersection, union, concatenation, square, star, reversal, and complementation, we get the tight upper bounds for all considered classes except for complementation on factor- and subword-convex languages. Most of our witnesses are described over optimal alphabets. The most interesting result is the describing of a proper suffix-convex language over a five-letter alphabet meeting the upper bound \(2^n\) for complementation.
4;Galina Jirásková;Michal Hospodár, Peter Mlynárčik;Nondeterministic Complexity of Operations on Free and Convex Languages;We study the nondeterministic state complexity of basic regular operations on the classes of prefix-, suffix-, factor-, and subword-free and -convex regular languages. For the operations of intersection, union, concatenation, square, star, reversal, and complementation, we get the tight upper bounds for all considered classes except for complementation on factor- and subword-convex languages. Most of our witnesses are described over optimal alphabets. The most interesting result is the describing of a proper suffix-convex language over a five-letter alphabet meeting the upper bound \(2^n\) for complementation.
4;Peter Mlynárčik;Michal Hospodár, Galina Jirásková;Nondeterministic Complexity of Operations on Free and Convex Languages;We study the nondeterministic state complexity of basic regular operations on the classes of prefix-, suffix-, factor-, and subword-free and -convex regular languages. For the operations of intersection, union, concatenation, square, star, reversal, and complementation, we get the tight upper bounds for all considered classes except for complementation on factor- and subword-convex languages. Most of our witnesses are described over optimal alphabets. The most interesting result is the describing of a proper suffix-convex language over a five-letter alphabet meeting the upper bound \(2^n\) for complementation.
4;Martin Kutrib;Andreas Malcher, Matthias Wendlandt;Transducing Reversibly with Finite State Machines;Finite state machines are investigated towards their ability to reversibly compute transductions, that is, to transform inputs into outputs in a reversible way. This means that the transducers are backward deterministic and hence are able to uniquely step the computation back and forth. The families of transductions computed are classified with regard to three types of length-preserving transductions as well as to the property of working reversibly. It is possible to settle all inclusion relations between the families of transductions. Finally, the standard closure properties are investigated and the non-closure under almost all operations can be shown.
4;Andreas Malcher;Martin Kutrib, Matthias Wendlandt;Transducing Reversibly with Finite State Machines;Finite state machines are investigated towards their ability to reversibly compute transductions, that is, to transform inputs into outputs in a reversible way. This means that the transducers are backward deterministic and hence are able to uniquely step the computation back and forth. The families of transductions computed are classified with regard to three types of length-preserving transductions as well as to the property of working reversibly. It is possible to settle all inclusion relations between the families of transductions. Finally, the standard closure properties are investigated and the non-closure under almost all operations can be shown.
4;Matthias Wendlandt;Martin Kutrib, Andreas Malcher;Transducing Reversibly with Finite State Machines;Finite state machines are investigated towards their ability to reversibly compute transductions, that is, to transform inputs into outputs in a reversible way. This means that the transducers are backward deterministic and hence are able to uniquely step the computation back and forth. The families of transductions computed are classified with regard to three types of length-preserving transductions as well as to the property of working reversibly. It is possible to settle all inclusion relations between the families of transductions. Finally, the standard closure properties are investigated and the non-closure under almost all operations can be shown.
4;Louis-Marie Dando;Sylvain Lombardy;From Hadamard Expressions to Weighted Rotating Automata and Back;This paper deals with the conversion of expressions denoting Hadamard series into weighted rotating automata. We prove that any algorithm converting rational series into one-way weighted automata can be extended to provide an algorithm which achieves our goal. We apply this to define the derivation and the follow automata of a Hadamard expression. Our method is also used to extend algorithms which perform the inverse conversion, up to some adjustment in order to fulfill some constraints.
4;Sylvain Lombardy;Louis-Marie Dando;From Hadamard Expressions to Weighted Rotating Automata and Back;This paper deals with the conversion of expressions denoting Hadamard series into weighted rotating automata. We prove that any algorithm converting rational series into one-way weighted automata can be extended to provide an algorithm which achieves our goal. We apply this to define the derivation and the follow automata of a Hadamard expression. Our method is also used to extend algorithms which perform the inverse conversion, up to some adjustment in order to fulfill some constraints.
4;Paolo Massazza;;On the Conjecture $$\mathcal {L}_{\mathsf {DFCM}}\subsetneq \mathsf {RCM}$$;We prove that the class of the languages recognized by one-way deterministic 1-reversal bounded 1-counter machines is contained in \(\mathsf {RCM}\), a class of languages that has been recently introduced and that admits interesting properties. This is the first step to prove the conjecture \(\mathcal {L}_{\mathsf {DFCM}}\subsetneq \mathsf {RCM}\), which says that for any fixed integer k all the languages recognized by one-way deterministic 1-reversal bounded k-counter machines are in \(\mathsf {RCM}\). We recall that this conjecture implies that the generating function of a language in \(\mathcal {L}_{\mathsf {DFCM}}\) is holonomic.
4;Andrew Ryzhikov;;Synchronization Problems in Automata Without Non-trivial Cycles;We study the computational complexity of various problems related to synchronization of weakly acyclic automata, a subclass of widely studied aperiodic automata. We provide upper and lower bounds on the length of a shortest word synchronizing a weakly acyclic automaton or, more generally, a subset of its states, and show that the problem of approximating this length is hard. We also show inapproximability of the problem of computing the rank of a subset of states in a binary weakly acyclic automaton and prove that several problems related to recognizing a synchronizing subset of states in such automata are NP-complete.
4;Marek Szykuła;John Wittnebel;Syntactic Complexity of Bifix-Free Languages;We study the properties of syntactic monoids of bifix-free regular languages. In particular, we solve an open problem concerning syntactic complexity: We prove that the cardinality of the syntactic semigroup of a bifix-free language with state complexity n is at most \((n-1)^{n-3}+(n-2)^{n-3}+(n-3)2^{n-3}\) for \(n \geqslant 6\). The main proof uses a large construction with the method of injective function. Since this bound is known to be reachable, and the values for \(n \leqslant 5\) are known, this completely settles the problem. We also prove that \((n-2)^{n-3} + (n-3)2^{n-3} - 1\) is the minimal size of the alphabet required to meet the bound for \(n \geqslant 6\). Finally, we show that the largest transition semigroups of minimal DFAs which recognize bifix-free languages are unique up to renaming the states.
4;John Wittnebel;Marek Szykuła;Syntactic Complexity of Bifix-Free Languages;We study the properties of syntactic monoids of bifix-free regular languages. In particular, we solve an open problem concerning syntactic complexity: We prove that the cardinality of the syntactic semigroup of a bifix-free language with state complexity n is at most \((n-1)^{n-3}+(n-2)^{n-3}+(n-3)2^{n-3}\) for \(n \geqslant 6\). The main proof uses a large construction with the method of injective function. Since this bound is known to be reachable, and the values for \(n \leqslant 5\) are known, this completely settles the problem. We also prove that \((n-2)^{n-3} + (n-3)2^{n-3} - 1\) is the minimal size of the alphabet required to meet the bound for \(n \geqslant 6\). Finally, we show that the largest transition semigroups of minimal DFAs which recognize bifix-free languages are unique up to renaming the states.
5;Bakhadyr Khoussainov;Jiamou Liu;Decision Problems for Finite Automata over Infinite Algebraic Structures;We introduce the concept of finite automata over algebraic structures. We address the classical emptiness problem and its various refinements in our setting. In particular, we prove several decidability and undecidability results. We also explain the way our automata model connects with the existential first order theory of algebraic structures.
5;Jiamou Liu;Bakhadyr Khoussainov;Decision Problems for Finite Automata over Infinite Algebraic Structures;We introduce the concept of finite automata over algebraic structures. We address the classical emptiness problem and its various refinements in our setting. In particular, we prove several decidability and undecidability results. We also explain the way our automata model connects with the existential first order theory of algebraic structures.
5;Holger Bock Axelsen;Markus Holzer, Martin Kutrib;The Degree of Irreversibility in Deterministic Finite Automata;Recently, Holzer et al. gave a method to decide whether the language accepted by a given deterministic finite automaton (DFA) can also be accepted by some reversible deterministic finite automaton (REV-DFA), and eventually proved NL-completeness. Here, we show that the corresponding problem for nondeterministic finite state automata (NFA) is PSPACE-complete. The recent DFA method essentially works by minimizing the DFA and inspecting it for a forbidden pattern. We here study the degree of irreversibility for a regular language, the minimal number of such forbidden patterns necessary in any DFA accepting the language, and show that the degree induces a strict infinite hierarchy of languages. We examine how the degree of irreversibility behaves under the usual language operations union, intersection, complement, concatenation, and Kleene star, showing tight bounds (some asymptotically) on the degree.
5;Markus Holzer;Holger Bock Axelsen, Martin Kutrib;The Degree of Irreversibility in Deterministic Finite Automata;Recently, Holzer et al. gave a method to decide whether the language accepted by a given deterministic finite automaton (DFA) can also be accepted by some reversible deterministic finite automaton (REV-DFA), and eventually proved NL-completeness. Here, we show that the corresponding problem for nondeterministic finite state automata (NFA) is PSPACE-complete. The recent DFA method essentially works by minimizing the DFA and inspecting it for a forbidden pattern. We here study the degree of irreversibility for a regular language, the minimal number of such forbidden patterns necessary in any DFA accepting the language, and show that the degree induces a strict infinite hierarchy of languages. We examine how the degree of irreversibility behaves under the usual language operations union, intersection, complement, concatenation, and Kleene star, showing tight bounds (some asymptotically) on the degree.
5;Martin Kutrib;Holger Bock Axelsen, Markus Holzer;The Degree of Irreversibility in Deterministic Finite Automata;Recently, Holzer et al. gave a method to decide whether the language accepted by a given deterministic finite automaton (DFA) can also be accepted by some reversible deterministic finite automaton (REV-DFA), and eventually proved NL-completeness. Here, we show that the corresponding problem for nondeterministic finite state automata (NFA) is PSPACE-complete. The recent DFA method essentially works by minimizing the DFA and inspecting it for a forbidden pattern. We here study the degree of irreversibility for a regular language, the minimal number of such forbidden patterns necessary in any DFA accepting the language, and show that the degree induces a strict infinite hierarchy of languages. We examine how the degree of irreversibility behaves under the usual language operations union, intersection, complement, concatenation, and Kleene star, showing tight bounds (some asymptotically) on the degree.
5;Suna Bensch;Johanna Björklund, Martin Kutrib;Deterministic Stack Transducers;We introduce and investigate stack transducers, which are one-way stack automata with an output tape. A one-way stack automaton is a classical pushdown automaton with the additional ability to move the stack head inside the stack without altering the contents. For stack transducers, we distinguish between a digging and a non-digging mode. In digging mode, the stack transducer can write on the output tape when its stack head is inside the stack, whereas in non-digging mode, the stack transducer is only allowed to emit symbols when its stack head is at the top of the stack. These stack transducers have a motivation from natural language interface applications, as they capture long-distance dependencies in syntactic, semantic, and discourse structures. We study the computational capacity for deterministic digging and non-digging stack transducers, as well as for their non-erasing and checking versions. We finally show that even for the strongest variant of stack transducers the stack languages are regular.
5;Johanna Björklund;Suna Bensch, Martin Kutrib;Deterministic Stack Transducers;We introduce and investigate stack transducers, which are one-way stack automata with an output tape. A one-way stack automaton is a classical pushdown automaton with the additional ability to move the stack head inside the stack without altering the contents. For stack transducers, we distinguish between a digging and a non-digging mode. In digging mode, the stack transducer can write on the output tape when its stack head is inside the stack, whereas in non-digging mode, the stack transducer is only allowed to emit symbols when its stack head is at the top of the stack. These stack transducers have a motivation from natural language interface applications, as they capture long-distance dependencies in syntactic, semantic, and discourse structures. We study the computational capacity for deterministic digging and non-digging stack transducers, as well as for their non-erasing and checking versions. We finally show that even for the strongest variant of stack transducers the stack languages are regular.
5;Martin Kutrib;Suna Bensch, Johanna Björklund;Deterministic Stack Transducers;We introduce and investigate stack transducers, which are one-way stack automata with an output tape. A one-way stack automaton is a classical pushdown automaton with the additional ability to move the stack head inside the stack without altering the contents. For stack transducers, we distinguish between a digging and a non-digging mode. In digging mode, the stack transducer can write on the output tape when its stack head is inside the stack, whereas in non-digging mode, the stack transducer is only allowed to emit symbols when its stack head is at the top of the stack. These stack transducers have a motivation from natural language interface applications, as they capture long-distance dependencies in syntactic, semantic, and discourse structures. We study the computational capacity for deterministic digging and non-digging stack transducers, as well as for their non-erasing and checking versions. We finally show that even for the strongest variant of stack transducers the stack languages are regular.
5;Jorge Calvo-Zaragoza;Colin de la Higuera, Jose Oncina;Computing the Expected Edit Distance from a String to a PFA;In a number of fields one is to compare a witness string with a distribution. One possibility is to compute the probability of the string for that distribution. Another, giving a more global view, is to compute the expected edit distance from a string randomly drawn to the witness string. This number is often used to measure the performance of a prediction, the goal then being to return the median string, or the string with smallest expected distance.
5;Colin de la Higuera;Jorge Calvo-Zaragoza, Jose Oncina;Computing the Expected Edit Distance from a String to a PFA;In a number of fields one is to compare a witness string with a distribution. One possibility is to compute the probability of the string for that distribution. Another, giving a more global view, is to compute the expected edit distance from a string randomly drawn to the witness string. This number is often used to measure the performance of a prediction, the goal then being to return the median string, or the string with smallest expected distance.
5;Jose Oncina;Jorge Calvo-Zaragoza, Colin de la Higuera;Computing the Expected Edit Distance from a String to a PFA;In a number of fields one is to compare a witness string with a distribution. One possibility is to compute the probability of the string for that distribution. Another, giving a more global view, is to compute the expected edit distance from a string randomly drawn to the witness string. This number is often used to measure the performance of a prediction, the goal then being to return the median string, or the string with smallest expected distance.
5;Akim Demaille;;Derived-Term Automata of Multitape Rational Expressions;We introduce (weighted) rational expressions to denote series over Cartesian products of monoids. To this end, we propose the operator \(\mathbin {|}\) to build multitape expressions such as \((a^+\mathbin {|}x + b^+\mathbin {|}y)^*\). We define expansions, which generalize the concept of derivative of a rational expression, but relieved from the need of a free monoid. We propose an algorithm based on expansions to build multitape automata from multitape expressions.
5;Antonio Di Stasio;Aniello Murano, Giuseppe Perelli, Moshe Y. Vardi;Solving Parity Games Using an Automata-Based Algorithm;Parity games are abstract infinite-round games that take an important role in formal verification. In the basic setting, these games are two-player, turn-based, and played under perfect information on directed graphs, whose nodes are labeled with priorities. The winner of a play is determined according to the parities (even or odd) of the minimal priority occurring infinitely often in that play. The problem of finding a winning strategy in parity games is known to be in UPTime \(\cap \) CoUPTime and deciding whether a polynomial time solution exists is a long-standing open question. In the last two decades, a variety of algorithms have been proposed. Many of them have been also implemented in a platform named PGSolver. This has enabled an empirical evaluation of these algorithms and a better understanding of their relative merits.
5;Aniello Murano;Antonio Di Stasio, Giuseppe Perelli, Moshe Y. Vardi;Solving Parity Games Using an Automata-Based Algorithm;Parity games are abstract infinite-round games that take an important role in formal verification. In the basic setting, these games are two-player, turn-based, and played under perfect information on directed graphs, whose nodes are labeled with priorities. The winner of a play is determined according to the parities (even or odd) of the minimal priority occurring infinitely often in that play. The problem of finding a winning strategy in parity games is known to be in UPTime \(\cap \) CoUPTime and deciding whether a polynomial time solution exists is a long-standing open question. In the last two decades, a variety of algorithms have been proposed. Many of them have been also implemented in a platform named PGSolver. This has enabled an empirical evaluation of these algorithms and a better understanding of their relative merits.
5;Giuseppe Perelli;Antonio Di Stasio, Aniello Murano, Moshe Y. Vardi;Solving Parity Games Using an Automata-Based Algorithm;Parity games are abstract infinite-round games that take an important role in formal verification. In the basic setting, these games are two-player, turn-based, and played under perfect information on directed graphs, whose nodes are labeled with priorities. The winner of a play is determined according to the parities (even or odd) of the minimal priority occurring infinitely often in that play. The problem of finding a winning strategy in parity games is known to be in UPTime \(\cap \) CoUPTime and deciding whether a polynomial time solution exists is a long-standing open question. In the last two decades, a variety of algorithms have been proposed. Many of them have been also implemented in a platform named PGSolver. This has enabled an empirical evaluation of these algorithms and a better understanding of their relative merits.
5;Moshe Y. Vardi;Antonio Di Stasio, Aniello Murano, Giuseppe Perelli;Solving Parity Games Using an Automata-Based Algorithm;Parity games are abstract infinite-round games that take an important role in formal verification. In the basic setting, these games are two-player, turn-based, and played under perfect information on directed graphs, whose nodes are labeled with priorities. The winner of a play is determined according to the parities (even or odd) of the minimal priority occurring infinitely often in that play. The problem of finding a winning strategy in parity games is known to be in UPTime \(\cap \) CoUPTime and deciding whether a polynomial time solution exists is a long-standing open question. In the last two decades, a variety of algorithms have been proposed. Many of them have been also implemented in a platform named PGSolver. This has enabled an empirical evaluation of these algorithms and a better understanding of their relative merits.
5;Zoltán Ésik;;Ternary Equational Languages;We present a general method for solving fixed point equations involving pseudo-complementation over complete ternary algebras satisfying some infinite distributivity conditions as generalized truth values, and finitely decomposable algebras as data domains. When the algebra of data domains is a word or a tree algebra, fixed point equations may be interpreted as grammars and we obtain wide classes of (fuzzy) languages and tree languages.
5;Henning Fernau;Andreas Krebs;Problems on Finite Automata and the Exponential Time Hypothesis;We study several classical decision problems on finite automata under the (Strong) Exponential Time Hypothesis. We focus on three types of problems: universality, equivalence, and emptiness of intersection. All these problems are known to be CoNP-hard for nondeterministic finite automata, even when restricted to unary input alphabets. A different type of problems on finite automata relates to aperiodicity and to synchronizing words. We also consider finite automata that work on commutative alphabets and those working on two-dimensional words.
5;Andreas Krebs;Henning Fernau;Problems on Finite Automata and the Exponential Time Hypothesis;We study several classical decision problems on finite automata under the (Strong) Exponential Time Hypothesis. We focus on three types of problems: universality, equivalence, and emptiness of intersection. All these problems are known to be CoNP-hard for nondeterministic finite automata, even when restricted to unary input alphabets. A different type of problems on finite automata relates to aperiodicity and to synchronizing words. We also consider finite automata that work on commutative alphabets and those working on two-dimensional words.
5;Akio Fujiyoshi;;A Practical Algorithm for the Uniform Membership Problem of Labeled Multidigraphs of Tree-Width 2 for Spanning Tree Automata;This paper presents a practical algorithm for the uniform membership problem of labeled multidigraphs of tree-width at most 2 for spanning tree automata. Though it has been shown that the membership problem is solvable in linear time for graphs of bounded tree-width, the algorithm obtained in the previous study is unusable in practice because of a big hidden constant.
5;Robert Glück;;A Practical Simulation Result for Two-Way Pushdown Automata;The simulation of two-way deterministic and nondeterministic pushdown automata is revisited. A uniform algorithm presented herein decides on a random-access machine in linear time resp. cubic time whether a given pushdown automaton accepts a word, while the actual run of the automaton may take exponential time. The algorithm is practical since it only explores reachable configurations, simulates a class of quasi-deterministic decision problems in linear time even if the pushdown automaton is nondeterministic, and iterates over a simple work list. This is an improvement over previous simulation algorithms.
5;Michal Hospodár;Galina Jirásková, Peter Mlynárčik;Nondeterministic Complexity of Operations on Closed and Ideal Languages;We study the nondeterministic state complexity of basic regular operations on the classes of prefix-, suffix-, factor-, and subword-closed regular languages and on the classes of right, left, two-sided, and all-sided ideal regular languages. For the operations of union, intersection, complementation, concatenation, square, star, and reversal, we get the tight upper bounds for all considered classes.
5;Galina Jirásková;Michal Hospodár, Peter Mlynárčik;Nondeterministic Complexity of Operations on Closed and Ideal Languages;We study the nondeterministic state complexity of basic regular operations on the classes of prefix-, suffix-, factor-, and subword-closed regular languages and on the classes of right, left, two-sided, and all-sided ideal regular languages. For the operations of union, intersection, complementation, concatenation, square, star, and reversal, we get the tight upper bounds for all considered classes.
5;Peter Mlynárčik;Michal Hospodár, Galina Jirásková;Nondeterministic Complexity of Operations on Closed and Ideal Languages;We study the nondeterministic state complexity of basic regular operations on the classes of prefix-, suffix-, factor-, and subword-closed regular languages and on the classes of right, left, two-sided, and all-sided ideal regular languages. For the operations of union, intersection, complementation, concatenation, square, star, and reversal, we get the tight upper bounds for all considered classes.
5;Oscar H. Ibarra;Ian McQuillan;On Bounded Semilinear Languages, Counter Machines, and Finite-Index ET0L;We show that for every trio \(\mathcal{L}\) containing only semilinear languages, all bounded languages in \(\mathcal{L}\) can be accepted by one-way nondeterministic reversal-bounded multicounter machines (\(\textsf {NCM}\)), and in fact, even by the deterministic versions of these machines \((\textsf {DCM})\). This implies that for every semilinear trio (where these properties are effective), it is possible to decide containment, equivalence, and disjointness concerning its bounded languages. We also provide a relatively simple condition for when the bounded languages in a semilinear trio coincide exactly with those accepted by \(\textsf {DCM}\) machines. This is applied to finite-index \(\textsf {ET0L}\) systems, where we show that the bounded languages generated by these systems are exactly the bounded languages accepted by \(\textsf {DCM}\). We also define, compare, and characterize several other types of languages that are both bounded and semilinear.
5;Ian McQuillan;Oscar H. Ibarra;On Bounded Semilinear Languages, Counter Machines, and Finite-Index ET0L;We show that for every trio \(\mathcal{L}\) containing only semilinear languages, all bounded languages in \(\mathcal{L}\) can be accepted by one-way nondeterministic reversal-bounded multicounter machines (\(\textsf {NCM}\)), and in fact, even by the deterministic versions of these machines \((\textsf {DCM})\). This implies that for every semilinear trio (where these properties are effective), it is possible to decide containment, equivalence, and disjointness concerning its bounded languages. We also provide a relatively simple condition for when the bounded languages in a semilinear trio coincide exactly with those accepted by \(\textsf {DCM}\) machines. This is applied to finite-index \(\textsf {ET0L}\) systems, where we show that the bounded languages generated by these systems are exactly the bounded languages accepted by \(\textsf {DCM}\). We also define, compare, and characterize several other types of languages that are both bounded and semilinear.
5;Jozef Jirásek Jr.;Juraj Šebej;Kuratowski Algebras Generated by Prefix-Free Languages;We study Kuratowski algebras generated by prefix-free languages under the operations of star and complement. Our results are as follows. Five of 12 possible algebras cannot be generated by any prefix-free language. Two algebras are generated only by trivial prefix-free languages, the empty set and the language \(\{\varepsilon \}\). Each of the remaining five algebras can be generated, for every \(n\ge 4\), by a regular prefix-free language of state complexity n, which meets the upper bounds on the state complexities of all the languages in the resulting algebra.
5;Juraj Šebej;Jozef Jirásek Jr.;Kuratowski Algebras Generated by Prefix-Free Languages;We study Kuratowski algebras generated by prefix-free languages under the operations of star and complement. Our results are as follows. Five of 12 possible algebras cannot be generated by any prefix-free language. Two algebras are generated only by trivial prefix-free languages, the empty set and the language \(\{\varepsilon \}\). Each of the remaining five algebras can be generated, for every \(n\ge 4\), by a regular prefix-free language of state complexity n, which meets the upper bounds on the state complexities of all the languages in the resulting algebra.
5;Christos A. Kapoutsis;Lamana Mulaffer;A Logical Characterization of Small 2NFAs;Let 2N be the class of families of problems solvable by families of two-way nondeterministic finite automata of polynomial size. We characterize 2N in terms of families of formulas of transitive-closure logic. These formulas apply the transitive-closure operator on a quantifier-free disjunctive normal form of first-order logic with successor and constants, where (i) apart from two special variables, all others are equated to constants in every clause, and (ii) no clause simultaneously relates these two special variables and refers to fixed input cells. We prove that automata with polynomially many states are as powerful as formulas with polynomially many clauses and polynomially large constants. This can be seen as a refinement of Immerman’s theorem that nondeterministic logarithmic space matches positive transitive-closure logic (NL = FO+pos TC).
5;Lamana Mulaffer;Christos A. Kapoutsis;A Logical Characterization of Small 2NFAs;Let 2N be the class of families of problems solvable by families of two-way nondeterministic finite automata of polynomial size. We characterize 2N in terms of families of formulas of transitive-closure logic. These formulas apply the transitive-closure operator on a quantifier-free disjunctive normal form of first-order logic with successor and constants, where (i) apart from two special variables, all others are equated to constants in every clause, and (ii) no clause simultaneously relates these two special variables and refers to fixed input cells. We prove that automata with polynomially many states are as powerful as formulas with polynomially many clauses and polynomially large constants. This can be seen as a refinement of Immerman’s theorem that nondeterministic logarithmic space matches positive transitive-closure logic (NL = FO+pos TC).
5;Andrzej Kisielewicz;Jakub Kowalski, Marek Szykuła;Experiments with Synchronizing Automata;We have improved an algorithm generating synchronizing automata with a large length of the shortest reset words. This has been done by refining some known results concerning bounds on the reset length. Our improvements make possible to consider a number of conjectures and open questions concerning synchronizing automata, checking them for automata with a small number of states and discussing the results. In particular, we have verified the Černý conjecture for all binary automata with at most 12 states, and all ternary automata with at most 8 states.
5;Jakub Kowalski;Andrzej Kisielewicz, Marek Szykuła;Experiments with Synchronizing Automata;We have improved an algorithm generating synchronizing automata with a large length of the shortest reset words. This has been done by refining some known results concerning bounds on the reset length. Our improvements make possible to consider a number of conjectures and open questions concerning synchronizing automata, checking them for automata with a small number of states and discussing the results. In particular, we have verified the Černý conjecture for all binary automata with at most 12 states, and all ternary automata with at most 8 states.
5;Marek Szykuła;Andrzej Kisielewicz, Jakub Kowalski;Experiments with Synchronizing Automata;We have improved an algorithm generating synchronizing automata with a large length of the shortest reset words. This has been done by refining some known results concerning bounds on the reset length. Our improvements make possible to consider a number of conjectures and open questions concerning synchronizing automata, checking them for automata with a small number of states and discussing the results. In particular, we have verified the Černý conjecture for all binary automata with at most 12 states, and all ternary automata with at most 8 states.
5;Stavros Konstantinidis;Casey Meijer, Nelma Moreira, Rogério Reis;Implementation of Code Properties via Transducers;The FAdo system is a symbolic manipulator of formal language objects, implemented in Python. In this work, we extend its capabilities by implementing methods to manipulate transducers and we go one level higher than existing formal language systems and implement methods to manipulate objects representing classes of independent languages (widely known as code properties). Our methods allow users to define their own code properties and combine them between themselves or with fixed properties such as prefix codes, suffix codes, error detecting codes, etc. The satisfaction and maximality decision questions are solvable for any of the definable properties. The new online system LaSer allows one to query about a code property and obtain the answer in a batch mode. Our work is founded on independence theory as well as the theory of rational relations and transducers, and contributes with improved algorithms on these objects.
5;Casey Meijer;Stavros Konstantinidis, Nelma Moreira, Rogério Reis;Implementation of Code Properties via Transducers;The FAdo system is a symbolic manipulator of formal language objects, implemented in Python. In this work, we extend its capabilities by implementing methods to manipulate transducers and we go one level higher than existing formal language systems and implement methods to manipulate objects representing classes of independent languages (widely known as code properties). Our methods allow users to define their own code properties and combine them between themselves or with fixed properties such as prefix codes, suffix codes, error detecting codes, etc. The satisfaction and maximality decision questions are solvable for any of the definable properties. The new online system LaSer allows one to query about a code property and obtain the answer in a batch mode. Our work is founded on independence theory as well as the theory of rational relations and transducers, and contributes with improved algorithms on these objects.
5;Nelma Moreira;Stavros Konstantinidis, Casey Meijer, Rogério Reis;Implementation of Code Properties via Transducers;The FAdo system is a symbolic manipulator of formal language objects, implemented in Python. In this work, we extend its capabilities by implementing methods to manipulate transducers and we go one level higher than existing formal language systems and implement methods to manipulate objects representing classes of independent languages (widely known as code properties). Our methods allow users to define their own code properties and combine them between themselves or with fixed properties such as prefix codes, suffix codes, error detecting codes, etc. The satisfaction and maximality decision questions are solvable for any of the definable properties. The new online system LaSer allows one to query about a code property and obtain the answer in a batch mode. Our work is founded on independence theory as well as the theory of rational relations and transducers, and contributes with improved algorithms on these objects.
5;Rogério Reis;Stavros Konstantinidis, Casey Meijer, Nelma Moreira;Implementation of Code Properties via Transducers;The FAdo system is a symbolic manipulator of formal language objects, implemented in Python. In this work, we extend its capabilities by implementing methods to manipulate transducers and we go one level higher than existing formal language systems and implement methods to manipulate objects representing classes of independent languages (widely known as code properties). Our methods allow users to define their own code properties and combine them between themselves or with fixed properties such as prefix codes, suffix codes, error detecting codes, etc. The satisfaction and maximality decision questions are solvable for any of the definable properties. The new online system LaSer allows one to query about a code property and obtain the answer in a batch mode. Our work is founded on independence theory as well as the theory of rational relations and transducers, and contributes with improved algorithms on these objects.
5;Emil Lerner;;On Synchronizing Automata and Uniform Distribution;Let \(m &gt. 1, [m] = \{0, 1, \ldots , m-1\}\), \([m]^\infty \) be a set of all one-side infinite sequences with elements from [m]. Consider a function \(g: [m]^\infty \rightarrow [m]^\infty \) which is a bijection defined by a deterministic finite transducer (DFT) whose input/output alphabets are [m]. Denote the prefix of length n of an infinite word w by \(w \bmod m^n\). A function \(f: [m]^\infty \rightarrow [m]^\infty \) is said to be compatible if from \(w_1 \bmod m^n = w_2 \bmod m^n\) it follows \(f(w_1) \bmod m^n= f(w_2) \bmod m^n\). It is known that all functions defined by DFT are compatible. A function f is said to be a uniformly distributed function over \([m]^\infty \) if the set \(\left\{ \frac{\overline{f(z) \bmod m^n}}{m^n}:z \in [m]^n \right\} \) is uniformly distributed as \(n \rightarrow \infty \) (here \(\overline{f(z) \bmod m^n}\) stands for the number whose base-m expansion is first n symbols of f(z)). We prove a necessary and sufficient condition for composite function \(f \odot g\) to be uniformly distributed for any uniformly distributed compatible function \(f:[m]^\infty \rightarrow [m]^\infty \). The condition is based on a generalization of the notion of synchronizing automaton.
6;Benedikt Bollig;;Automata and Logics for Concurrent Systems: Five Models in Five Pages;We survey various automata models of concurrent systems and their connection with monadic second-order logic: finite automata, class memory automata, nested-word automata, asynchronous automata, and message-passing automata.
6;Bruce W. Watson;;Hardware Implementations of Finite Automata and Regular Expressions;This extended abstract sketches some of the most recent advances in hardware implementations (and surrounding issues) of finite automata and regular expressions.
6;Abhijin Adiga;Chris J. Kuhlman, Madhav V. Marathe, S. S. Ravi, Daniel J. Rosenkrantz, Richard E. Stearns;Complexity of Inferring Local Transition Functions of Discrete Dynamical Systems;We consider the problem of inferring the local transition functions of discrete dynamical systems from observed behavior. Our focus is on synchronous systems whose local transition functions are threshold functions. We assume that the topology of the system is known and that the goal is to infer a threshold value for each node so that the system produces the observed behavior. We show that some of these inference problems are efficiently solvable while others are NP-complete, even when the underlying graph of the dynamical system is a simple path. We also identify a fixed parameter tractable problem in this context.
6;Chris J. Kuhlman;Abhijin Adiga, Madhav V. Marathe, S. S. Ravi, Daniel J. Rosenkrantz, Richard E. Stearns;Complexity of Inferring Local Transition Functions of Discrete Dynamical Systems;We consider the problem of inferring the local transition functions of discrete dynamical systems from observed behavior. Our focus is on synchronous systems whose local transition functions are threshold functions. We assume that the topology of the system is known and that the goal is to infer a threshold value for each node so that the system produces the observed behavior. We show that some of these inference problems are efficiently solvable while others are NP-complete, even when the underlying graph of the dynamical system is a simple path. We also identify a fixed parameter tractable problem in this context.
6;Madhav V. Marathe;Abhijin Adiga, Chris J. Kuhlman, S. S. Ravi, Daniel J. Rosenkrantz, Richard E. Stearns;Complexity of Inferring Local Transition Functions of Discrete Dynamical Systems;We consider the problem of inferring the local transition functions of discrete dynamical systems from observed behavior. Our focus is on synchronous systems whose local transition functions are threshold functions. We assume that the topology of the system is known and that the goal is to infer a threshold value for each node so that the system produces the observed behavior. We show that some of these inference problems are efficiently solvable while others are NP-complete, even when the underlying graph of the dynamical system is a simple path. We also identify a fixed parameter tractable problem in this context.
6;S. S. Ravi;Abhijin Adiga, Chris J. Kuhlman, Madhav V. Marathe, Daniel J. Rosenkrantz, Richard E. Stearns;Complexity of Inferring Local Transition Functions of Discrete Dynamical Systems;We consider the problem of inferring the local transition functions of discrete dynamical systems from observed behavior. Our focus is on synchronous systems whose local transition functions are threshold functions. We assume that the topology of the system is known and that the goal is to infer a threshold value for each node so that the system produces the observed behavior. We show that some of these inference problems are efficiently solvable while others are NP-complete, even when the underlying graph of the dynamical system is a simple path. We also identify a fixed parameter tractable problem in this context.
6;Daniel J. Rosenkrantz;Abhijin Adiga, Chris J. Kuhlman, Madhav V. Marathe, S. S. Ravi, Richard E. Stearns;Complexity of Inferring Local Transition Functions of Discrete Dynamical Systems;We consider the problem of inferring the local transition functions of discrete dynamical systems from observed behavior. Our focus is on synchronous systems whose local transition functions are threshold functions. We assume that the topology of the system is known and that the goal is to infer a threshold value for each node so that the system produces the observed behavior. We show that some of these inference problems are efficiently solvable while others are NP-complete, even when the underlying graph of the dynamical system is a simple path. We also identify a fixed parameter tractable problem in this context.
6;Richard E. Stearns;Abhijin Adiga, Chris J. Kuhlman, Madhav V. Marathe, S. S. Ravi, Daniel J. Rosenkrantz;Complexity of Inferring Local Transition Functions of Discrete Dynamical Systems;We consider the problem of inferring the local transition functions of discrete dynamical systems from observed behavior. Our focus is on synchronous systems whose local transition functions are threshold functions. We assume that the topology of the system is known and that the goal is to infer a threshold value for each node so that the system produces the observed behavior. We show that some of these inference problems are efficiently solvable while others are NP-complete, even when the underlying graph of the dynamical system is a simple path. We also identify a fixed parameter tractable problem in this context.
6;Angelo Borsotti;Luca Breveglieri, Stefano Crespi Reghizzi, Angelo Morzenti;From Ambiguous Regular Expressions to Deterministic Parsing Automata;This new parser generator for ambiguous regular expressions (RE) formally extends the Berry-Sethi (BS) algorithm into a finite-state device that specifies the syntax tree(s). We extend the local testability property of the marked RE’s from terminal strings to linearized syntax trees. The generator supports disambiguation, i.e., selecting a preferred tree in case of ambiguity. The selection is parametric with respect to the Greedy or POSIX criterion. The parser is proved correct and has linear-time complexity. The generator is available as an interactive SW tool (on GitHub - see http://github.com/breveglieri/ebs/README).
6;Luca Breveglieri;Angelo Borsotti, Stefano Crespi Reghizzi, Angelo Morzenti;From Ambiguous Regular Expressions to Deterministic Parsing Automata;This new parser generator for ambiguous regular expressions (RE) formally extends the Berry-Sethi (BS) algorithm into a finite-state device that specifies the syntax tree(s). We extend the local testability property of the marked RE’s from terminal strings to linearized syntax trees. The generator supports disambiguation, i.e., selecting a preferred tree in case of ambiguity. The selection is parametric with respect to the Greedy or POSIX criterion. The parser is proved correct and has linear-time complexity. The generator is available as an interactive SW tool (on GitHub - see http://github.com/breveglieri/ebs/README).
6;Stefano Crespi Reghizzi;Angelo Borsotti, Luca Breveglieri, Angelo Morzenti;From Ambiguous Regular Expressions to Deterministic Parsing Automata;This new parser generator for ambiguous regular expressions (RE) formally extends the Berry-Sethi (BS) algorithm into a finite-state device that specifies the syntax tree(s). We extend the local testability property of the marked RE’s from terminal strings to linearized syntax trees. The generator supports disambiguation, i.e., selecting a preferred tree in case of ambiguity. The selection is parametric with respect to the Greedy or POSIX criterion. The parser is proved correct and has linear-time complexity. The generator is available as an interactive SW tool (on GitHub - see http://github.com/breveglieri/ebs/README).
6;Angelo Morzenti;Angelo Borsotti, Luca Breveglieri, Stefano Crespi Reghizzi;From Ambiguous Regular Expressions to Deterministic Parsing Automata;This new parser generator for ambiguous regular expressions (RE) formally extends the Berry-Sethi (BS) algorithm into a finite-state device that specifies the syntax tree(s). We extend the local testability property of the marked RE’s from terminal strings to linearized syntax trees. The generator supports disambiguation, i.e., selecting a preferred tree in case of ambiguity. The selection is parametric with respect to the Greedy or POSIX criterion. The parser is proved correct and has linear-time complexity. The generator is available as an interactive SW tool (on GitHub - see http://github.com/breveglieri/ebs/README).
6;Sabine Broda;Sílvia Cavadas, Miguel Ferreira, Nelma Moreira;Deciding Synchronous Kleene Algebra with Derivatives;Synchronous Kleene algebra (SKA) is a decidable framework that combines Kleene algebra (KA) with a synchrony model of concurrency. Elements of SKA can be seen as processes taking place within a fixed discrete time frame and that, at each time step, may execute one or more basic actions or then come to a halt. The synchronous Kleene algebra with tests (SKAT) combines SKA with a Boolean algebra. Both algebras were introduced by Prisacariu, who proved the decidability of the equational theory, through a Kleene theorem based on the classical Thompson \(\varepsilon \)-NFA construction. Using the notion of partial derivatives, we present a new decision procedure for equivalence between SKA terms. The results are extended for SKAT considering automata with transitions labeled by Boolean expressions instead of atoms. This work continous previous research done for KA and KAT, where derivative based methods were used in feasible algorithms for testing terms equivalence.
6;Sílvia Cavadas;Sabine Broda, Miguel Ferreira, Nelma Moreira;Deciding Synchronous Kleene Algebra with Derivatives;Synchronous Kleene algebra (SKA) is a decidable framework that combines Kleene algebra (KA) with a synchrony model of concurrency. Elements of SKA can be seen as processes taking place within a fixed discrete time frame and that, at each time step, may execute one or more basic actions or then come to a halt. The synchronous Kleene algebra with tests (SKAT) combines SKA with a Boolean algebra. Both algebras were introduced by Prisacariu, who proved the decidability of the equational theory, through a Kleene theorem based on the classical Thompson \(\varepsilon \)-NFA construction. Using the notion of partial derivatives, we present a new decision procedure for equivalence between SKA terms. The results are extended for SKAT considering automata with transitions labeled by Boolean expressions instead of atoms. This work continous previous research done for KA and KAT, where derivative based methods were used in feasible algorithms for testing terms equivalence.
6;Miguel Ferreira;Sabine Broda, Sílvia Cavadas, Nelma Moreira;Deciding Synchronous Kleene Algebra with Derivatives;Synchronous Kleene algebra (SKA) is a decidable framework that combines Kleene algebra (KA) with a synchrony model of concurrency. Elements of SKA can be seen as processes taking place within a fixed discrete time frame and that, at each time step, may execute one or more basic actions or then come to a halt. The synchronous Kleene algebra with tests (SKAT) combines SKA with a Boolean algebra. Both algebras were introduced by Prisacariu, who proved the decidability of the equational theory, through a Kleene theorem based on the classical Thompson \(\varepsilon \)-NFA construction. Using the notion of partial derivatives, we present a new decision procedure for equivalence between SKA terms. The results are extended for SKAT considering automata with transitions labeled by Boolean expressions instead of atoms. This work continous previous research done for KA and KAT, where derivative based methods were used in feasible algorithms for testing terms equivalence.
6;Nelma Moreira;Sabine Broda, Sílvia Cavadas, Miguel Ferreira;Deciding Synchronous Kleene Algebra with Derivatives;Synchronous Kleene algebra (SKA) is a decidable framework that combines Kleene algebra (KA) with a synchrony model of concurrency. Elements of SKA can be seen as processes taking place within a fixed discrete time frame and that, at each time step, may execute one or more basic actions or then come to a halt. The synchronous Kleene algebra with tests (SKAT) combines SKA with a Boolean algebra. Both algebras were introduced by Prisacariu, who proved the decidability of the equational theory, through a Kleene theorem based on the classical Thompson \(\varepsilon \)-NFA construction. Using the notion of partial derivatives, we present a new decision procedure for equivalence between SKA terms. The results are extended for SKAT considering automata with transitions labeled by Boolean expressions instead of atoms. This work continous previous research done for KA and KAT, where derivative based methods were used in feasible algorithms for testing terms equivalence.
6;Pascal Caron;Ludovic Mignot, Clément Miklarz;On the Hierarchy of Block Deterministic Languages;A regular language is k-block deterministic if it is specified by a k-block deterministic regular expression. This subclass of regular languages has been introduced by Giammarresi et al. as a possible extension of one-unambiguous regular languages defined and characterized by Brüggemann-Klein and Wood. We first show that each k-block deterministic regular language is the alphabetic image of some one-unambiguous regular language. Moreover, we show that the conversion from a minimal DFA of a k-block deterministic regular language to a k-block deterministic automaton not only requires state elimination, and that the proof given by Han and Wood of a proper hierarchy in k-block deterministic languages based on this result is erroneous. Despite these results, we show by giving a parameterized family that there is a proper hierarchy in k-block deterministic regular languages.
6;Ludovic Mignot;Pascal Caron, Clément Miklarz;On the Hierarchy of Block Deterministic Languages;A regular language is k-block deterministic if it is specified by a k-block deterministic regular expression. This subclass of regular languages has been introduced by Giammarresi et al. as a possible extension of one-unambiguous regular languages defined and characterized by Brüggemann-Klein and Wood. We first show that each k-block deterministic regular language is the alphabetic image of some one-unambiguous regular language. Moreover, we show that the conversion from a minimal DFA of a k-block deterministic regular language to a k-block deterministic automaton not only requires state elimination, and that the proof given by Han and Wood of a proper hierarchy in k-block deterministic languages based on this result is erroneous. Despite these results, we show by giving a parameterized family that there is a proper hierarchy in k-block deterministic regular languages.
6;Clément Miklarz;Pascal Caron, Ludovic Mignot;On the Hierarchy of Block Deterministic Languages;A regular language is k-block deterministic if it is specified by a k-block deterministic regular expression. This subclass of regular languages has been introduced by Giammarresi et al. as a possible extension of one-unambiguous regular languages defined and characterized by Brüggemann-Klein and Wood. We first show that each k-block deterministic regular language is the alphabetic image of some one-unambiguous regular language. Moreover, we show that the conversion from a minimal DFA of a k-block deterministic regular language to a k-block deterministic automaton not only requires state elimination, and that the proof given by Han and Wood of a proper hierarchy in k-block deterministic languages based on this result is erroneous. Despite these results, we show by giving a parameterized family that there is a proper hierarchy in k-block deterministic regular languages.
6;Zhe Dang;Dmitry Dementyev, Thomas R. Fischer, William J. Hutton III;Security of Numerical Sensors in Automata;Numerical sensors are numerical functions applied on memory contents. We study the computability of the mutual information rate between two sensors in various forms of automata, including nondeterministic pushdown automata augmented with reversal-bounded counters as well as discrete timed automata. The computed mutual information rate can be used to determine whether it is the case that there is essentially no information flow between a low sensor and a high sensor and hence could provide a way to quantitatively and algorithmically analyze some covert channels.
6;Dmitry Dementyev;Zhe Dang, Thomas R. Fischer, William J. Hutton III;Security of Numerical Sensors in Automata;Numerical sensors are numerical functions applied on memory contents. We study the computability of the mutual information rate between two sensors in various forms of automata, including nondeterministic pushdown automata augmented with reversal-bounded counters as well as discrete timed automata. The computed mutual information rate can be used to determine whether it is the case that there is essentially no information flow between a low sensor and a high sensor and hence could provide a way to quantitatively and algorithmically analyze some covert channels.
6;Thomas R. Fischer;Zhe Dang, Dmitry Dementyev, William J. Hutton III;Security of Numerical Sensors in Automata;Numerical sensors are numerical functions applied on memory contents. We study the computability of the mutual information rate between two sensors in various forms of automata, including nondeterministic pushdown automata augmented with reversal-bounded counters as well as discrete timed automata. The computed mutual information rate can be used to determine whether it is the case that there is essentially no information flow between a low sensor and a high sensor and hence could provide a way to quantitatively and algorithmically analyze some covert channels.
6;William J. Hutton III;Zhe Dang, Dmitry Dementyev, Thomas R. Fischer;Security of Numerical Sensors in Automata;Numerical sensors are numerical functions applied on memory contents. We study the computability of the mutual information rate between two sensors in various forms of automata, including nondeterministic pushdown automata augmented with reversal-bounded counters as well as discrete timed automata. The computed mutual information rate can be used to determine whether it is the case that there is essentially no information flow between a low sensor and a high sensor and hence could provide a way to quantitatively and algorithmically analyze some covert channels.
6;Henning Fernau;Meenakshi Paramasivan, Markus L. Schmid;Jumping Finite Automata: Characterizations and Complexity;We characterize the class of languages described by jumping finite automata (i. e., finite automata, for which the input head after reading (and consuming) a symbol, can jump to an arbitrary position of the remaining input) in terms of special shuffle expressions. We can characterize some interesting subclasses of this language class. The complexity of parsing these languages is also investigated.
6;Meenakshi Paramasivan;Henning Fernau, Markus L. Schmid;Jumping Finite Automata: Characterizations and Complexity;We characterize the class of languages described by jumping finite automata (i. e., finite automata, for which the input head after reading (and consuming) a symbol, can jump to an arbitrary position of the remaining input) in terms of special shuffle expressions. We can characterize some interesting subclasses of this language class. The complexity of parsing these languages is also investigated.
6;Markus L. Schmid;Henning Fernau, Meenakshi Paramasivan;Jumping Finite Automata: Characterizations and Complexity;We characterize the class of languages described by jumping finite automata (i. e., finite automata, for which the input head after reading (and consuming) a symbol, can jump to an arbitrary position of the remaining input) in terms of special shuffle expressions. We can characterize some interesting subclasses of this language class. The complexity of parsing these languages is also investigated.
6;Emanuele Giaquinta;;Run-Length Encoded Nondeterministic KMP and Suffix Automata;We present a novel bit-parallel representation, based on the run-length encoding, of the nondeterministic KMP and suffix automata for a string P with at least two distinct symbols. Our encoding requires \(O((\sigma + m)\lceil \rho / w\rceil )\) space and allows one to simulate the automata on a string in time \(O(\lceil \rho / w\rceil )\) per transition, where \(\sigma \) is the alphabet size, m is the length of P, \(\rho \) is the length of the run-length encoding of P and w is the machine word size in bits. The input string can be given in either unencoded or run-length encoded form. Finally, we present practical variants of the Shift-And and BNDM algorithms based on this encoding.
6;Hermann Gruber;Markus Holzer, Sebastian Jakobi;More on Deterministic and Nondeterministic Finite Cover Automata;Finite languages are an important sub-regular language family, which were intensively studied during the last two decades in particular from a descriptional complexity perspective. An important contribution to the theory of finite languages are the deterministic and the recently introduced nondeterministic finite cover automata (DFCAs and NFCAs, respectively) as an alternative representation of finite languages by ordinary finite automata. We compare these two types of cover automata from a descriptional complexity point of view, showing that these devices have a lot in common with ordinary finite automata. In particular, we study how to adapt lower bound techniques for nondeterministic finite automata to NFCAs such as, e.g., the biclique edge cover technique, solving an open problem from the literature. Moreover, the trade-off of conversions between DFCAs and NFCAs as well as between finite cover automata and ordinary finite automata are investigated. Finally, we present some results on the average size of finite cover automata.
6;Markus Holzer;Hermann Gruber, Sebastian Jakobi;More on Deterministic and Nondeterministic Finite Cover Automata;Finite languages are an important sub-regular language family, which were intensively studied during the last two decades in particular from a descriptional complexity perspective. An important contribution to the theory of finite languages are the deterministic and the recently introduced nondeterministic finite cover automata (DFCAs and NFCAs, respectively) as an alternative representation of finite languages by ordinary finite automata. We compare these two types of cover automata from a descriptional complexity point of view, showing that these devices have a lot in common with ordinary finite automata. In particular, we study how to adapt lower bound techniques for nondeterministic finite automata to NFCAs such as, e.g., the biclique edge cover technique, solving an open problem from the literature. Moreover, the trade-off of conversions between DFCAs and NFCAs as well as between finite cover automata and ordinary finite automata are investigated. Finally, we present some results on the average size of finite cover automata.
6;Sebastian Jakobi;Hermann Gruber, Markus Holzer;More on Deterministic and Nondeterministic Finite Cover Automata;Finite languages are an important sub-regular language family, which were intensively studied during the last two decades in particular from a descriptional complexity perspective. An important contribution to the theory of finite languages are the deterministic and the recently introduced nondeterministic finite cover automata (DFCAs and NFCAs, respectively) as an alternative representation of finite languages by ordinary finite automata. We compare these two types of cover automata from a descriptional complexity point of view, showing that these devices have a lot in common with ordinary finite automata. In particular, we study how to adapt lower bound techniques for nondeterministic finite automata to NFCAs such as, e.g., the biclique edge cover technique, solving an open problem from the literature. Moreover, the trade-off of conversions between DFCAs and NFCAs as well as between finite cover automata and ordinary finite automata are investigated. Finally, we present some results on the average size of finite cover automata.
6;Vladimir V. Gusev;Marek Szykuła;On the Number of Synchronizing Colorings of Digraphs;We deal with k-out-regular directed multigraphs with loops (called simply digraphs). The edges of such a digraph can be colored by elements of some fixed k-element set in such a way that outgoing edges of every vertex have different colors. Such a coloring corresponds naturally to an automaton. The road coloring theorem states that every primitive digraph has a synchronizing coloring.
6;Marek Szykuła;Vladimir V. Gusev;On the Number of Synchronizing Colorings of Digraphs;We deal with k-out-regular directed multigraphs with loops (called simply digraphs). The edges of such a digraph can be colored by elements of some fixed k-element set in such a way that outgoing edges of every vertex have different colors. Such a coloring corresponds naturally to an automaton. The road coloring theorem states that every primitive digraph has a synchronizing coloring.
6;Pierre-Cyrille Héam;Jean-Luc Joly;On the Uniform Random Generation of Non Deterministic Automata Up to Isomorphism;In this paper we address the problem of the uniform random generation of non deterministic automata (NFA) up to isomorphism. First, we show how to use a Monte-Carlo approach to uniformly sample a NFA. Secondly, we show how to use the Metropolis-Hastings Algorithm to uniformly generate NFAs up to isomorphism. Using labeling techniques, we show that in practice it is possible to move into the modified Markov Chain efficiently, allowing the random generation of NFAs up to isomorphism with dozens of states. This general approach is also applied to several interesting subclasses of NFAs (up to isomorphism), such as NFAs having a unique initial states and a bounded output degree. Finally, we prove that for these interesting subclasses of NFAs, moving into the Metropolis Markov chain can be done in polynomial time. Promising experimental results constitute a practical contribution.
6;Jean-Luc Joly;Pierre-Cyrille Héam;On the Uniform Random Generation of Non Deterministic Automata Up to Isomorphism;In this paper we address the problem of the uniform random generation of non deterministic automata (NFA) up to isomorphism. First, we show how to use a Monte-Carlo approach to uniformly sample a NFA. Secondly, we show how to use the Metropolis-Hastings Algorithm to uniformly generate NFAs up to isomorphism. Using labeling techniques, we show that in practice it is possible to move into the modified Markov Chain efficiently, allowing the random generation of NFAs up to isomorphism with dozens of states. This general approach is also applied to several interesting subclasses of NFAs (up to isomorphism), such as NFAs having a unique initial states and a bounded output degree. Finally, we prove that for these interesting subclasses of NFAs, moving into the Metropolis Markov chain can be done in polynomial time. Promising experimental results constitute a practical contribution.
6;Pierre-Cyrille Héam;Jean-Luc Joly;Random Generation and Enumeration of Accessible Deterministic Real-Time Pushdown Automata;This paper presents a general framework for the uniform random generation of deterministic real-time accessible pushdown automata. A polynomial time algorithm to randomly generate a pushdown automaton having a fixed stack operations total size is proposed. The influence of the accepting condition (empty stack, final state) on the reachability of the generated automata is investigated.
6;Jean-Luc Joly;Pierre-Cyrille Héam;Random Generation and Enumeration of Accessible Deterministic Real-Time Pushdown Automata;This paper presents a general framework for the uniform random generation of deterministic real-time accessible pushdown automata. A polynomial time algorithm to randomly generate a pushdown automaton having a fixed stack operations total size is proposed. The influence of the accepting condition (empty stack, final state) on the reachability of the generated automata is investigated.
6;Stefan Hoffmann;Ludwig Staiger;Subword Metrics for Infinite Words;The space of one-sided infinite words plays a crucial rôle in several parts of Theoretical Computer Science. Usually, it is convenient to regard this space as a metric space, the Cantor-space. It turned out that for several purposes topologies other than the one of the Cantor-space are useful, e.g. for studying fragments of first-order logic over infinite words or for a topological characterisation of random infinite words.
6;Ludwig Staiger;Stefan Hoffmann;Subword Metrics for Infinite Words;The space of one-sided infinite words plays a crucial rôle in several parts of Theoretical Computer Science. Usually, it is convenient to regard this space as a metric space, the Cantor-space. It turned out that for several purposes topologies other than the one of the Cantor-space are useful, e.g. for studying fragments of first-order logic over infinite words or for a topological characterisation of random infinite words.
6;Mans Hulden;;From Two-Way to One-Way Finite Automata—Three Regular Expression-Based Methods;We describe three regular expression-based methods to characterize as a regular language the language defined by a two-way automaton. The construction methods yield relatively simple techniques to directly construct one-way automata that simulate the behavior of two-way automata. The approaches also offer conceptually uncomplicated alternative equivalence proofs of two-way automata and one-way automata, particularly in the deterministic case.
6;Natalia Kushik;Nina Yevtushenko;Describing Homing and Distinguishing Sequences for Nondeterministic Finite State Machines via Synchronizing Automata;There is a long standing problem of the study of homing and distinguishing sequences for deterministic and nondeterministic Finite State Machines (FSMs) which are widely used in many applications. A homing sequence allows establishing the state of the given FSM after applying the sequence while a distinguishing sequence allows learning the state of the given FSM before the sequence is applied. On the other hand, other sequences, namely, synchronizing sequences, have been thoroughly studied for finite automata. For a synchronizing automaton, there is a state such that a synchronizing sequence takes the automaton from any state to this state. There are many papers reported on such automata as well as on the complexity of synchronizing sequences. In this paper, given a complete nondeterministic FSM, we propose a method for deriving a corresponding finite automaton such that the set of all homing (or distinguishing) sequences coincides with the set of all synchronizing sequences of the derived automaton.
6;Nina Yevtushenko;Natalia Kushik;Describing Homing and Distinguishing Sequences for Nondeterministic Finite State Machines via Synchronizing Automata;There is a long standing problem of the study of homing and distinguishing sequences for deterministic and nondeterministic Finite State Machines (FSMs) which are widely used in many applications. A homing sequence allows establishing the state of the given FSM after applying the sequence while a distinguishing sequence allows learning the state of the given FSM before the sequence is applied. On the other hand, other sequences, namely, synchronizing sequences, have been thoroughly studied for finite automata. For a synchronizing automaton, there is a state such that a synchronizing sequence takes the automaton from any state to this state. There are many papers reported on such automata as well as on the complexity of synchronizing sequences. In this paper, given a complete nondeterministic FSM, we propose a method for deriving a corresponding finite automaton such that the set of all homing (or distinguishing) sequences coincides with the set of all synchronizing sequences of the derived automaton.
6;Martin Kutrib;Matthias Wendlandt;Expressive Capacity of Concatenation Freeness;The expressive capacity of regular expressions without concatenation, but with complementation and a finite set of words as literals is studied. In particular, a characterization of unary concatenation-free languages by the Boolean closure of certain sets of languages is shown. The characterization is then used to derive regular languages that are not concatenation free. Closure properties of the family of concatenation-free languages are derived. Furthermore, the position of the family in the subregular hierarchy is considered and settled for the unary case. In particular, there are concatenation-free languages that do not belong to all of the families in the hierarchy. Moreover, except for comets, all of the families in the subregular hierarchy considered are strictly included in the family of concatenation-free languages.
6;Matthias Wendlandt;Martin Kutrib;Expressive Capacity of Concatenation Freeness;The expressive capacity of regular expressions without concatenation, but with complementation and a finite set of words as literals is studied. In particular, a characterization of unary concatenation-free languages by the Boolean closure of certain sets of languages is shown. The characterization is then used to derive regular languages that are not concatenation free. Closure properties of the family of concatenation-free languages are derived. Furthermore, the position of the family in the subregular hierarchy is considered and settled for the unary case. In particular, there are concatenation-free languages that do not belong to all of the families in the hierarchy. Moreover, except for comets, all of the families in the subregular hierarchy considered are strictly included in the family of concatenation-free languages.
7;Javier Esparza;Michael Luttenberger, Maximilian Schlund;FPsolve: A Generic Solver for Fixpoint Equations over Semirings;We introduce FPsolve, an implementation of generic algorithms for solving fixpoint equations over semirings. We first illustrate the interest of generic solvers by means of a scenario. We then succinctly describe some of the algorithms implemented in the tool, and provide some implementation details.
7;Michael Luttenberger;Javier Esparza, Maximilian Schlund;FPsolve: A Generic Solver for Fixpoint Equations over Semirings;We introduce FPsolve, an implementation of generic algorithms for solving fixpoint equations over semirings. We first illustrate the interest of generic solvers by means of a scenario. We then succinctly describe some of the algorithms implemented in the tool, and provide some implementation details.
7;Maximilian Schlund;Javier Esparza, Michael Luttenberger;FPsolve: A Generic Solver for Fixpoint Equations over Semirings;We introduce FPsolve, an implementation of generic algorithms for solving fixpoint equations over semirings. We first illustrate the interest of generic solvers by means of a scenario. We then succinctly describe some of the algorithms implemented in the tool, and provide some implementation details.
7;Friedrich Otto;;Restarting Automata for Picture Languages: A Survey on Recent Developments;Much work has been done to obtain classes of picture languages that would correspond to the classes of the Chomsky hierarchy for string languages, and finally the class REC of recognizable picture languages has been agreed on as the class that corresponds to the ‘regular string languages.’ This class has several nice characterizations in terms of regular expressions, tiling automata, and on-line tesselation automata, and it has nice closure properties, but it also has two main drawbacks: all its characterizations are highly nondeterministic in nature, and it contains languages that are NP-complete. Consequentially, various deterministic subclasses of REC have been defined. Mainly, however, these definitions are quite complex, and it is not clear which of the resulting classes should be considered as ‘the’ class of deterministic recognizable picture languages. Here we present some recent developments obtained in a research project that aims at finding a deterministic model of a two-dimensional automaton that has the following desirable properties:
7;Giovanni Pighizzini;;Investigations on Automata and Languages over a Unary Alphabet;The investigation of automata and languages defined over a one letter alphabet shows interesting differences with respect to the case of alphabets with at least two letters. Probably, the oldest example emphasizing one of these differences is the collapse of the classes of regular and context-free languages in the unary case (Ginsburg and Rice, 1962). Many differences have been proved concerning the state costs of the simulations between different variants of unary finite state automata (Chrobak, 1986, Mereghetti and Pighizzini, 2001). We present an overview of those results. Because important connections with fundamental questions in space complexity, we give emphasis to unary two-way automata. Furthermore, we discuss unary versions of other computational models, as one-way and two-way pushdown automata, even extended with auxiliary workspace, and multi-head automata.
7;Georgios Ch. Sirakoulis;;Cellular Automata for Crowd Dynamics;Cellular Automata (CA) as bio-inspired parallel computational models of self-reproducing organisms can capture the essential features of systems where global behavior arises from the collective effect of simple components which interact locally. In this aspect, CAs have been considered as a fine candidate to model pedestrian behavior and crowd dynamics in a fine manner. In specific, for crowd modeling, the CA models show evidence of a macroscopic nature with microscopic extensions, i.e. they provide adequate details in the description of human behavior and interaction, whilst they retain the computational cost at low levels. In this paper several CA models for crowd evacuation taking into consideration different modeling principles, like potential fields techniques, obstacle avoidance, follow-the-leader principles, grouping theory, etc. will be presented in an attempt to accomplish efficient crowd evacuation simulation. Moreover, an integrated system based on CAs that operates as an anticipative crowd management tool in cases of medium density crowd evacuation for indoor and outdoor environments is also shown, and its results different real world cases and different environments prove its efficiency. Finally, robot guided evacuation with the help of CAs is also presented. Quite recently, an evacuation system was proposed, based on an accurate CA model capable of assessing the human behavior during emergency situations takes advantage of the simulation output to provide sufficient information to a mobile robotic guide, which in turn guides people towards a less congestive exit at a time.
7;Ivone Amorim;António Machiavelo, Rogério Reis;Counting Equivalent Linear Finite Transducers Using a Canonical Form;The notion of linear finite transducer (LFT) plays a crucial role in a family of cryptosystems introduced in the 80’s and 90’s. However, as far as we know, no study was ever conducted to count and enumerate these transducers, which is essential to verify if the size of the key space, of the aforementioned systems, is large enough to prevent an exhaustive search attack. In this paper, we determine the cardinal of the equivalence classes on the set of the LFTs with a given size. This result is sufficient to get an approximate value, by random sampling, for the number of non-equivalent injective LFTs, and subsequently for the size of the key space. We introduce a notion of canonical LFT, give a method to verify if two LFTs are equivalent, and prove that every LFT has exactly one equivalent canonical LFT. We then show how this canonical LFT allows us to calculate the size of each equivalence class on the set of the LFTs with the same number of states.
7;António Machiavelo;Ivone Amorim, Rogério Reis;Counting Equivalent Linear Finite Transducers Using a Canonical Form;The notion of linear finite transducer (LFT) plays a crucial role in a family of cryptosystems introduced in the 80’s and 90’s. However, as far as we know, no study was ever conducted to count and enumerate these transducers, which is essential to verify if the size of the key space, of the aforementioned systems, is large enough to prevent an exhaustive search attack. In this paper, we determine the cardinal of the equivalence classes on the set of the LFTs with a given size. This result is sufficient to get an approximate value, by random sampling, for the number of non-equivalent injective LFTs, and subsequently for the size of the key space. We introduce a notion of canonical LFT, give a method to verify if two LFTs are equivalent, and prove that every LFT has exactly one equivalent canonical LFT. We then show how this canonical LFT allows us to calculate the size of each equivalence class on the set of the LFTs with the same number of states.
7;Rogério Reis;Ivone Amorim, António Machiavelo;Counting Equivalent Linear Finite Transducers Using a Canonical Form;The notion of linear finite transducer (LFT) plays a crucial role in a family of cryptosystems introduced in the 80’s and 90’s. However, as far as we know, no study was ever conducted to count and enumerate these transducers, which is essential to verify if the size of the key space, of the aforementioned systems, is large enough to prevent an exhaustive search attack. In this paper, we determine the cardinal of the equivalence classes on the set of the LFTs with a given size. This result is sufficient to get an approximate value, by random sampling, for the number of non-equivalent injective LFTs, and subsequently for the size of the key space. We introduce a notion of canonical LFT, give a method to verify if two LFTs are equivalent, and prove that every LFT has exactly one equivalent canonical LFT. We then show how this canonical LFT allows us to calculate the size of each equivalence class on the set of the LFTs with the same number of states.
7;Maria Paola Bianchi;Carlo Mereghetti, Beatrice Palano;On the Power of One-Way Automata with Quantum and Classical States;We consider the model of one-way automata with quantum and classical states (qcfas) introduced in [23]. We show, by a direct approach, that qcfas with isolated cut-point accept regular languages only, thus characterizing their computational power. Moreover, we give a size lower bound for qcfas accepting regular languages, and we explicitly build qcfas accepting the word quotients and inverse homomorphic images of languages accepted by given qcfas with isolated cut-point, maintaining the same cut-point, isolation, and polynomially increasing the size.
7;Carlo Mereghetti;Maria Paola Bianchi, Beatrice Palano;On the Power of One-Way Automata with Quantum and Classical States;We consider the model of one-way automata with quantum and classical states (qcfas) introduced in [23]. We show, by a direct approach, that qcfas with isolated cut-point accept regular languages only, thus characterizing their computational power. Moreover, we give a size lower bound for qcfas accepting regular languages, and we explicitly build qcfas accepting the word quotients and inverse homomorphic images of languages accepted by given qcfas with isolated cut-point, maintaining the same cut-point, isolation, and polynomially increasing the size.
7;Beatrice Palano;Maria Paola Bianchi, Carlo Mereghetti;On the Power of One-Way Automata with Quantum and Classical States;We consider the model of one-way automata with quantum and classical states (qcfas) introduced in [23]. We show, by a direct approach, that qcfas with isolated cut-point accept regular languages only, thus characterizing their computational power. Moreover, we give a size lower bound for qcfas accepting regular languages, and we explicitly build qcfas accepting the word quotients and inverse homomorphic images of languages accepted by given qcfas with isolated cut-point, maintaining the same cut-point, isolation, and polynomially increasing the size.
7;Franziska Biegler;Ian McQuillan;On Comparing Deterministic Finite Automata and the Shuffle of Words;We continue the study of the shuffle of individual words, and the problem of decomposing a finite automaton into the shuffle on words. There is a known polynomial time algorithm to decide whether the shuffle of two words is a subset of the language accepted by a deterministic finite automaton [5]. In this paper, we consider the converse problem of determining whether or not the language accepted by a deterministic finite automaton is a subset of the shuffle of two words. We provide a polynomial time algorithm to decide whether the language accepted by a deterministic finite automaton is a subset of the shuffle of two words, for the special case when the skeletons of the two words are of fixed length. Therefore, for this special case, we can decide equality in polynomial time as well. However, we then show that this problem is coNP-Complete in general, as conjectured in [2].
7;Ian McQuillan;Franziska Biegler;On Comparing Deterministic Finite Automata and the Shuffle of Words;We continue the study of the shuffle of individual words, and the problem of decomposing a finite automaton into the shuffle on words. There is a known polynomial time algorithm to decide whether the shuffle of two words is a subset of the language accepted by a deterministic finite automaton [5]. In this paper, we consider the converse problem of determining whether or not the language accepted by a deterministic finite automaton is a subset of the shuffle of two words. We provide a polynomial time algorithm to decide whether the language accepted by a deterministic finite automaton is a subset of the shuffle of two words, for the special case when the skeletons of the two words are of fixed length. Therefore, for this special case, we can decide equality in polynomial time as well. However, we then show that this problem is coNP-Complete in general, as conjectured in [2].
7;Francine Blanchet-Sadri;Kira Goldner, Aidan Shackleton;Minimal Partial Languages and Automata;Partial words are sequences of characters from an alphabet in which some positions may be marked with a “hole” symbol, ⋄. We can create a ⋄-substitution mapping this symbol to a subset of the alphabet, so that applying such a substitution to a partial word results in a set of full words (ones without holes). This setup allows us to compress regular languages into smaller partial languages. Deterministic finite automata for such partial languages, referred to as ⋄-DFAs, employ a limited non-determinism that can allow them to have lower state complexity than the minimal DFAs for the corresponding full languages. Our paper focuses on algorithms for the construction of minimal partial languages, associated with some ⋄-substitution, as well as approximation algorithms for the construction of minimal ⋄-DFAs.
7;Kira Goldner;Francine Blanchet-Sadri, Aidan Shackleton;Minimal Partial Languages and Automata;Partial words are sequences of characters from an alphabet in which some positions may be marked with a “hole” symbol, ⋄. We can create a ⋄-substitution mapping this symbol to a subset of the alphabet, so that applying such a substitution to a partial word results in a set of full words (ones without holes). This setup allows us to compress regular languages into smaller partial languages. Deterministic finite automata for such partial languages, referred to as ⋄-DFAs, employ a limited non-determinism that can allow them to have lower state complexity than the minimal DFAs for the corresponding full languages. Our paper focuses on algorithms for the construction of minimal partial languages, associated with some ⋄-substitution, as well as approximation algorithms for the construction of minimal ⋄-DFAs.
7;Aidan Shackleton;Francine Blanchet-Sadri, Kira Goldner;Minimal Partial Languages and Automata;Partial words are sequences of characters from an alphabet in which some positions may be marked with a “hole” symbol, ⋄. We can create a ⋄-substitution mapping this symbol to a subset of the alphabet, so that applying such a substitution to a partial word results in a set of full words (ones without holes). This setup allows us to compress regular languages into smaller partial languages. Deterministic finite automata for such partial languages, referred to as ⋄-DFAs, employ a limited non-determinism that can allow them to have lower state complexity than the minimal DFAs for the corresponding full languages. Our paper focuses on algorithms for the construction of minimal partial languages, associated with some ⋄-substitution, as well as approximation algorithms for the construction of minimal ⋄-DFAs.
7;Janusz Brzozowski;Marek Szykuła;Large Aperiodic Semigroups;We search for the largest syntactic semigroup of a star-free language having n left quotients. equivalently, we look for the largest transition semigroup of an aperiodic finite automaton with n states.
7;Marek Szykuła;Janusz Brzozowski;Large Aperiodic Semigroups;We search for the largest syntactic semigroup of a star-free language having n left quotients. equivalently, we look for the largest transition semigroup of an aperiodic finite automaton with n states.
7;Kristína Čevorová;Galina Jirásková, Ivana Krajňáková;On the Square of Regular Languages;We show that the upper bound (n − k)·2n + k·2n − 1 on the state complexity of the square of a regular language recognized by an n-state deterministic finite automaton with k final states is tight in the ternary case for every k with 1 ≤ k ≤ n − 2. Using this result, we are able to define a language that is hard for the square operation on languages accepted by alternating finite automata. In the unary case, the known upper bound for square is 2n − 1, and we prove that each value in the range from 1 to 2n − 1 may be attained by the state complexity of the square of a unary language with state complexity n whenever n ≥ 5.
7;Galina Jirásková;Kristína Čevorová, Ivana Krajňáková;On the Square of Regular Languages;We show that the upper bound (n − k)·2n + k·2n − 1 on the state complexity of the square of a regular language recognized by an n-state deterministic finite automaton with k final states is tight in the ternary case for every k with 1 ≤ k ≤ n − 2. Using this result, we are able to define a language that is hard for the square operation on languages accepted by alternating finite automata. In the unary case, the known upper bound for square is 2n − 1, and we prove that each value in the range from 1 to 2n − 1 may be attained by the state complexity of the square of a unary language with state complexity n whenever n ≥ 5.
7;Ivana Krajňáková;Kristína Čevorová, Galina Jirásková;On the Square of Regular Languages;We show that the upper bound (n − k)·2n + k·2n − 1 on the state complexity of the square of a regular language recognized by an n-state deterministic finite automaton with k final states is tight in the ternary case for every k with 1 ≤ k ≤ n − 2. Using this result, we are able to define a language that is hard for the square operation on languages accepted by alternating finite automata. In the unary case, the known upper bound for square is 2n − 1, and we prove that each value in the range from 1 to 2n − 1 may be attained by the state complexity of the square of a unary language with state complexity n whenever n ≥ 5.
7;Marzio De Biasi;Abuzer Yakaryılmaz;Unary Languages Recognized by Two-Way One-Counter Automata;A two-way deterministic finite state automaton with one counter (2D1CA) is a fundamental computational model that has been examined in many different aspects since sixties, but we know little about its power in the case of unary languages. Up to our knowledge, the only known unary nonregular languages recognized by 2D1CAs are those formed by strings having exponential length, where the exponents form some trivial unary regular language. In this paper, we present some non-trivial subsets of these languages. By using the input head as a second counter, we present simulations of two-way deterministic finite automata with linearly bounded counters and linear–space Turing machines. We also show how a fixed-size quantum register can help to simplify some of these languages. Finally, we compare unary 2D1CAs with two–counter machines and provide some insights about the limits of their computational power.
7;Abuzer Yakaryılmaz;Marzio De Biasi;Unary Languages Recognized by Two-Way One-Counter Automata;A two-way deterministic finite state automaton with one counter (2D1CA) is a fundamental computational model that has been examined in many different aspects since sixties, but we know little about its power in the case of unary languages. Up to our knowledge, the only known unary nonregular languages recognized by 2D1CAs are those formed by strings having exponential length, where the exponents form some trivial unary regular language. In this paper, we present some non-trivial subsets of these languages. By using the input head as a second counter, we present simulations of two-way deterministic finite automata with linearly bounded counters and linear–space Turing machines. We also show how a fixed-size quantum register can help to simplify some of these languages. Finally, we compare unary 2D1CAs with two–counter machines and provide some insights about the limits of their computational power.
7;Akim Demaille;Alexandre Duret-Lutz, Sylvain Lombardy, Luca Saiu, Jacques Sakarovitch;A Type System for Weighted Automata and Rational Expressions;We present a type system for automata and rational expressions, expressive enough to encompass weighted automata and transducers in a single coherent formalism. The system allows to express useful properties about the applicability of operations including binary heterogeneous functions over automata.
7;Alexandre Duret-Lutz;Akim Demaille, Sylvain Lombardy, Luca Saiu, Jacques Sakarovitch;A Type System for Weighted Automata and Rational Expressions;We present a type system for automata and rational expressions, expressive enough to encompass weighted automata and transducers in a single coherent formalism. The system allows to express useful properties about the applicability of operations including binary heterogeneous functions over automata.
7;Sylvain Lombardy;Akim Demaille, Alexandre Duret-Lutz, Luca Saiu, Jacques Sakarovitch;A Type System for Weighted Automata and Rational Expressions;We present a type system for automata and rational expressions, expressive enough to encompass weighted automata and transducers in a single coherent formalism. The system allows to express useful properties about the applicability of operations including binary heterogeneous functions over automata.
7;Luca Saiu;Akim Demaille, Alexandre Duret-Lutz, Sylvain Lombardy, Jacques Sakarovitch;A Type System for Weighted Automata and Rational Expressions;We present a type system for automata and rational expressions, expressive enough to encompass weighted automata and transducers in a single coherent formalism. The system allows to express useful properties about the applicability of operations including binary heterogeneous functions over automata.
7;Jacques Sakarovitch;Akim Demaille, Alexandre Duret-Lutz, Sylvain Lombardy, Luca Saiu;A Type System for Weighted Automata and Rational Expressions;We present a type system for automata and rational expressions, expressive enough to encompass weighted automata and transducers in a single coherent formalism. The system allows to express useful properties about the applicability of operations including binary heterogeneous functions over automata.
7;Marius Dumitran;Javier Gil, Florin Manea, Victor Mitrana;Bounded Prefix-Suffix Duplication;We consider a restricted variant of the prefix-suffix duplication operation, called bounded prefix-suffix duplication. It consists in the iterative duplication of a prefix or suffix, whose length is bounded by a constant, of a given word. We give a sufficient condition for the closure under bounded prefix-suffix duplication of a class of languages. Consequently, the class of regular languages is closed under bounded prefix-suffix duplication. furthermore, we propose an algorithm deciding whether a regular language is a finite k-prefix-suffix duplication language. An efficient algorithm solving the membership problem for the k-prefix-suffix duplication of a language is also presented. Finally, we define the k-prefix-suffix duplication distance between two words, extend it to languages and show how it can be computed for regular languages.
7;Javier Gil;Marius Dumitran, Florin Manea, Victor Mitrana;Bounded Prefix-Suffix Duplication;We consider a restricted variant of the prefix-suffix duplication operation, called bounded prefix-suffix duplication. It consists in the iterative duplication of a prefix or suffix, whose length is bounded by a constant, of a given word. We give a sufficient condition for the closure under bounded prefix-suffix duplication of a class of languages. Consequently, the class of regular languages is closed under bounded prefix-suffix duplication. furthermore, we propose an algorithm deciding whether a regular language is a finite k-prefix-suffix duplication language. An efficient algorithm solving the membership problem for the k-prefix-suffix duplication of a language is also presented. Finally, we define the k-prefix-suffix duplication distance between two words, extend it to languages and show how it can be computed for regular languages.
7;Florin Manea;Marius Dumitran, Javier Gil, Victor Mitrana;Bounded Prefix-Suffix Duplication;We consider a restricted variant of the prefix-suffix duplication operation, called bounded prefix-suffix duplication. It consists in the iterative duplication of a prefix or suffix, whose length is bounded by a constant, of a given word. We give a sufficient condition for the closure under bounded prefix-suffix duplication of a class of languages. Consequently, the class of regular languages is closed under bounded prefix-suffix duplication. furthermore, we propose an algorithm deciding whether a regular language is a finite k-prefix-suffix duplication language. An efficient algorithm solving the membership problem for the k-prefix-suffix duplication of a language is also presented. Finally, we define the k-prefix-suffix duplication distance between two words, extend it to languages and show how it can be computed for regular languages.
7;Victor Mitrana;Marius Dumitran, Javier Gil, Florin Manea;Bounded Prefix-Suffix Duplication;We consider a restricted variant of the prefix-suffix duplication operation, called bounded prefix-suffix duplication. It consists in the iterative duplication of a prefix or suffix, whose length is bounded by a constant, of a given word. We give a sufficient condition for the closure under bounded prefix-suffix duplication of a class of languages. Consequently, the class of regular languages is closed under bounded prefix-suffix duplication. furthermore, we propose an algorithm deciding whether a regular language is a finite k-prefix-suffix duplication language. An efficient algorithm solving the membership problem for the k-prefix-suffix duplication of a language is also presented. Finally, we define the k-prefix-suffix duplication distance between two words, extend it to languages and show how it can be computed for regular languages.
7;Akio Fujiyoshi;;Recognition of Labeled Multidigraphs by Spanning Tree Automata;In this paper, we study tree automata recognizing labeled multidigraphs. We define that a labeled multidigraph is accepted by a tree automaton if and only if the graph has a spanning tree accepted by the tree automaton. We call this automaton a spanning tree automaton. The membership problem of labeled multidigraphs for a spanning tree automaton is NP-complete because the Hamiltonian path problem can be easily reduced to it. However, it will be shown that the membership problem is solvable in linear time for graphs of bounded tree-width.
7;Vladimir V. Gusev;Elena V. Pribavkina;Reset Thresholds of Automata with Two Cycle Lengths;We present several series of synchronizing automata with multiple parameters, generalizing previously known results. Let p and q be two arbitrary co-prime positive integers, q &gt. p. We describe reset thresholds of the colorings of primitive digraphs with exactly one cycle of length p and one cycle of length q. Also, we study reset thresholds of the colorings of primitive digraphs with exactly one cycle of length q and two cycles of length p.
7;Elena V. Pribavkina;Vladimir V. Gusev;Reset Thresholds of Automata with Two Cycle Lengths;We present several series of synchronizing automata with multiple parameters, generalizing previously known results. Let p and q be two arbitrary co-prime positive integers, q &gt. p. We describe reset thresholds of the colorings of primitive digraphs with exactly one cycle of length p and one cycle of length q. Also, we study reset thresholds of the colorings of primitive digraphs with exactly one cycle of length q and two cycles of length p.
7;Oscar H. Ibarra;;On the Ambiguity, Finite-Valuedness, and Lossiness Problems in Acceptors and Transducers;We prove new decidability and undecidability results concerning the finite-ambiguity problem in acceptors, and the finite-valuedness and lossiness problems in transducers. The acceptors and transducers we study have infinite memory.
7;Galina Jirásková;Matúš Palmovský, Juraj Šebej;Kleene Closure on Regular and Prefix-Free Languages;We study the Kleene closure operation on regular and prefix-free languages. Using an alphabet of size 2n, we get the contiguous range from 1 to 3/4·2n of complexities of the Kleene closure of regular languages accepted by minimal n-state deterministic finite automata. In the case of prefix-free languages, the Kleene closure may attain just three possible complexities n − 2, n − 1, and n.
7;Matúš Palmovský;Galina Jirásková, Juraj Šebej;Kleene Closure on Regular and Prefix-Free Languages;We study the Kleene closure operation on regular and prefix-free languages. Using an alphabet of size 2n, we get the contiguous range from 1 to 3/4·2n of complexities of the Kleene closure of regular languages accepted by minimal n-state deterministic finite automata. In the case of prefix-free languages, the Kleene closure may attain just three possible complexities n − 2, n − 1, and n.
7;Juraj Šebej;Galina Jirásková, Matúš Palmovský;Kleene Closure on Regular and Prefix-Free Languages;We study the Kleene closure operation on regular and prefix-free languages. Using an alphabet of size 2n, we get the contiguous range from 1 to 3/4·2n of complexities of the Kleene closure of regular languages accepted by minimal n-state deterministic finite automata. In the case of prefix-free languages, the Kleene closure may attain just three possible complexities n − 2, n − 1, and n.
7;Sang-Ki Ko;Yo-Sub Han;Left is Better than Right for Reducing Nondeterminism of NFAs;We study the NFA reductions by invariant equivalences. It is well-known that the NFA minimization problem is PSPACE-complete. Therefore, there have been approaches to reduce the size of NFAs in low polynomial time by computing invariant equivalence and merging the states within same equivalence class. Here we consider the nondeterminism reduction of NFAs by invariant equivalences. We, in particular, show that the left-invariant equivalence is more useful than the right-invariant equivalence for reducing NFA nondeterminism. We also present experimental evidence for showing that NFA reduction by left-invariant equivalence achieves the better reduction of nondeterminism than right-invariant equivalence.
7;Yo-Sub Han;Sang-Ki Ko;Left is Better than Right for Reducing Nondeterminism of NFAs;We study the NFA reductions by invariant equivalences. It is well-known that the NFA minimization problem is PSPACE-complete. Therefore, there have been approaches to reduce the size of NFAs in low polynomial time by computing invariant equivalence and merging the states within same equivalence class. Here we consider the nondeterminism reduction of NFAs by invariant equivalences. We, in particular, show that the left-invariant equivalence is more useful than the right-invariant equivalence for reducing NFA nondeterminism. We also present experimental evidence for showing that NFA reduction by left-invariant equivalence achieves the better reduction of nondeterminism than right-invariant equivalence.
7;Petr Kůrka;Tomáš Vávra;Analytic Functions Computable by Finite State Transducers;We show that the only analytic functions computable by finite state transducers in sofic Möbius number systems are Möbius transformations.
7;Tomáš Vávra;Petr Kůrka;Analytic Functions Computable by Finite State Transducers;We show that the only analytic functions computable by finite state transducers in sofic Möbius number systems are Möbius transformations.
8;Cezar Câmpeanu;;Cover Languages and Implementations;A cover language is a superset of a given language. Deterministic Finite Cover Automata (DFCA) are Deterministic Finite Automata (DFA) accepting finite languages and other words longer than any word in the given language. Some papers from the 60’s were constructing DFCAs as a byproduct using ad-hoc procedures, but DFCAs have never been defined until 1998. The notion of Deterministic Finite Cover Automaton, which is based on the concept of similarity relations, was introduced for the very first time at WIA’98, where the authors give the first rigorous formal definition and a clear minimization algorithm.
8;Helmut Jürgensen;;Automata for Codes;We survey the actual and potential rôles of automata in the modelling of information transmission systems and, in particular, in the encoder, channel and decoder components of such systems. Our focus is on applications of codes in such systems and on the relevance of automaton theoretic methods to these applications. We discuss, for example, the issues of error-detection, fault-tolerance and error-correction for variable-length codes. Beyond reviewing known work in a possibly new setting, we also present some recent results on fault-tolerant decoders for systems in which synchronization errors are likely. We conclude with a kind of research programme, a list of rather general open problems requiring solutions.
8;Margus Veanes;;Applications of Symbolic Finite Automata;Symbolic automata theory lifts classical automata theory to rich alphabet theories. It does so by replacing an explicit alphabet with an alphabet described implicitly by a Boolean algebra. How does this lifting affect the basic algorithms that lay the foundation for modern automata theory and what is the incentive for doing this? We investigate these questions here. In our approach we use state-of-the-art constraint solving techniques for automata analysis that are both expressive and efficient, even for very large and infinite alphabets. We show how symbolic finite automata enable applications ranging from modern regex analysis to advanced web security analysis, that were out of reach with prior methods.
8;Houda Abbad;Éric Laugerotte;Computing Weights;This paper introduces an efficient weighted regognition algorithm. It is based on a suitable tree structure called ZPC without building the position automaton. The ZPC-structure results from the compact language and the polynomial structure of weighted expressions. We show that the time complexity of this algorithm is the best oneuntil now.
8;Éric Laugerotte;Houda Abbad;Computing Weights;This paper introduces an efficient weighted regognition algorithm. It is based on a suitable tree structure called ZPC without building the position automaton. The ZPC-structure results from the compact language and the polynomial structure of weighted expressions. We show that the time complexity of this algorithm is the best oneuntil now.
8;Eric Balkanski;F. Blanchet-Sadri, Matthew Kilgore, B. J. Wyatt;Partial Word DFAs;Recently, Dassow et al. connected partial words and regular languages. Partial words are sequences in which some positions may be undefined, represented with a “hole” symbol ⋄. If we restrict what the symbol ⋄ can represent, we can use partial words to compress the representation of regular languages. Doing so allows the creation of so-called ⋄-DFAs which are smaller than the DFAs recognizing the original language L, which recognize the compressed language. However, the ⋄-DFAs may be larger than the NFAs recognizing L. In this paper, we investigate a question of Dassow et al. as to how these sizes are related.
8;F. Blanchet-Sadri;Eric Balkanski, Matthew Kilgore, B. J. Wyatt;Partial Word DFAs;Recently, Dassow et al. connected partial words and regular languages. Partial words are sequences in which some positions may be undefined, represented with a “hole” symbol ⋄. If we restrict what the symbol ⋄ can represent, we can use partial words to compress the representation of regular languages. Doing so allows the creation of so-called ⋄-DFAs which are smaller than the DFAs recognizing the original language L, which recognize the compressed language. However, the ⋄-DFAs may be larger than the NFAs recognizing L. In this paper, we investigate a question of Dassow et al. as to how these sizes are related.
8;Matthew Kilgore;Eric Balkanski, F. Blanchet-Sadri, B. J. Wyatt;Partial Word DFAs;Recently, Dassow et al. connected partial words and regular languages. Partial words are sequences in which some positions may be undefined, represented with a “hole” symbol ⋄. If we restrict what the symbol ⋄ can represent, we can use partial words to compress the representation of regular languages. Doing so allows the creation of so-called ⋄-DFAs which are smaller than the DFAs recognizing the original language L, which recognize the compressed language. However, the ⋄-DFAs may be larger than the NFAs recognizing L. In this paper, we investigate a question of Dassow et al. as to how these sizes are related.
8;B. J. Wyatt;Eric Balkanski, F. Blanchet-Sadri, Matthew Kilgore;Partial Word DFAs;Recently, Dassow et al. connected partial words and regular languages. Partial words are sequences in which some positions may be undefined, represented with a “hole” symbol ⋄. If we restrict what the symbol ⋄ can represent, we can use partial words to compress the representation of regular languages. Doing so allows the creation of so-called ⋄-DFAs which are smaller than the DFAs recognizing the original language L, which recognize the compressed language. However, the ⋄-DFAs may be larger than the NFAs recognizing L. In this paper, we investigate a question of Dassow et al. as to how these sizes are related.
8;Fevzi Belli;Mutlu Beyazıt;Using Regular Grammars for Event-Based Testing;Model-based testing involves formal models for test generation. This paper suggests regular grammars for event-based modeling. This model, represented in BNF, will then be systematically modified by well-defined mutation operators in order to generate fault models, called mutants. Specific algorithms apply to both the model of the system under consideration and the mutants to generate test cases. While existing methods focus on single events the approach introduced in this paper suggests considering event sequences of length k≥1, that is, k-sequences. The approach also enables to cope with a tough problem encountered in mutation-oriented testing: the elimination of mutants that are equivalent to the original model, and mutants that model the same faults multiple times. These mutants lead to unproductive test suites that cause wasting of resources. The approach proposed devises strategies to exclude the mentioned mutants in that they will not be generated at all.
8;Mutlu Beyazıt;Fevzi Belli;Using Regular Grammars for Event-Based Testing;Model-based testing involves formal models for test generation. This paper suggests regular grammars for event-based modeling. This model, represented in BNF, will then be systematically modified by well-defined mutation operators in order to generate fault models, called mutants. Specific algorithms apply to both the model of the system under consideration and the mutants to generate test cases. While existing methods focus on single events the approach introduced in this paper suggests considering event sequences of length k≥1, that is, k-sequences. The approach also enables to cope with a tough problem encountered in mutation-oriented testing: the elimination of mutants that are equivalent to the original model, and mutants that model the same faults multiple times. These mutants lead to unproductive test suites that cause wasting of resources. The approach proposed devises strategies to exclude the mentioned mutants in that they will not be generated at all.
8;Niels Bjørn Bugge Grathwohl;Fritz Henglein, Lasse Nielsen, Ulrik Terp Rasmussen;Two-Pass Greedy Regular Expression Parsing;We present new algorithms for producing greedy parses for regular expressions (REs) in a semi-streaming fashion. Our lean-log algorithm executes in time O(mn) for REs of size m and input strings of size n and outputs a compact bit-coded parse tree representation. It improves on previous algorithms by: operating in only 2 passes. using only O(m) words of random-access memory (independent of n). requiring only kn bits of sequentially written and read log storage, where \(k &lt. \frac{1}{3} m\) is the number of alternatives and Kleene stars in the RE. processing the input string as a symbol stream and not requiring it to be stored at all. Previous RE parsing algorithms do not scale linearly with input size, or require substantially more log storage and employ 3 passes where the first consists of reversing the input, or do not or are not known to produce a greedy parse. The performance of our unoptimized C-based prototype indicates that our lean-log algorithm has also in practice superior performance and is surprisingly competitive with RE tools not performing full parsing, such as Grep.
8;Fritz Henglein;Niels Bjørn Bugge Grathwohl, Lasse Nielsen, Ulrik Terp Rasmussen;Two-Pass Greedy Regular Expression Parsing;We present new algorithms for producing greedy parses for regular expressions (REs) in a semi-streaming fashion. Our lean-log algorithm executes in time O(mn) for REs of size m and input strings of size n and outputs a compact bit-coded parse tree representation. It improves on previous algorithms by: operating in only 2 passes. using only O(m) words of random-access memory (independent of n). requiring only kn bits of sequentially written and read log storage, where \(k &lt. \frac{1}{3} m\) is the number of alternatives and Kleene stars in the RE. processing the input string as a symbol stream and not requiring it to be stored at all. Previous RE parsing algorithms do not scale linearly with input size, or require substantially more log storage and employ 3 passes where the first consists of reversing the input, or do not or are not known to produce a greedy parse. The performance of our unoptimized C-based prototype indicates that our lean-log algorithm has also in practice superior performance and is surprisingly competitive with RE tools not performing full parsing, such as Grep.
8;Lasse Nielsen;Niels Bjørn Bugge Grathwohl, Fritz Henglein, Ulrik Terp Rasmussen;Two-Pass Greedy Regular Expression Parsing;We present new algorithms for producing greedy parses for regular expressions (REs) in a semi-streaming fashion. Our lean-log algorithm executes in time O(mn) for REs of size m and input strings of size n and outputs a compact bit-coded parse tree representation. It improves on previous algorithms by: operating in only 2 passes. using only O(m) words of random-access memory (independent of n). requiring only kn bits of sequentially written and read log storage, where \(k &lt. \frac{1}{3} m\) is the number of alternatives and Kleene stars in the RE. processing the input string as a symbol stream and not requiring it to be stored at all. Previous RE parsing algorithms do not scale linearly with input size, or require substantially more log storage and employ 3 passes where the first consists of reversing the input, or do not or are not known to produce a greedy parse. The performance of our unoptimized C-based prototype indicates that our lean-log algorithm has also in practice superior performance and is surprisingly competitive with RE tools not performing full parsing, such as Grep.
8;Ulrik Terp Rasmussen;Niels Bjørn Bugge Grathwohl, Fritz Henglein, Lasse Nielsen;Two-Pass Greedy Regular Expression Parsing;We present new algorithms for producing greedy parses for regular expressions (REs) in a semi-streaming fashion. Our lean-log algorithm executes in time O(mn) for REs of size m and input strings of size n and outputs a compact bit-coded parse tree representation. It improves on previous algorithms by: operating in only 2 passes. using only O(m) words of random-access memory (independent of n). requiring only kn bits of sequentially written and read log storage, where \(k &lt. \frac{1}{3} m\) is the number of alternatives and Kleene stars in the RE. processing the input string as a symbol stream and not requiring it to be stored at all. Previous RE parsing algorithms do not scale linearly with input size, or require substantially more log storage and employ 3 passes where the first consists of reversing the input, or do not or are not known to produce a greedy parse. The performance of our unoptimized C-based prototype indicates that our lean-log algorithm has also in practice superior performance and is surprisingly competitive with RE tools not performing full parsing, such as Grep.
8;Janusz Brzozowski;David Liu;Universal Witnesses for State Complexity of Basic Operations Combined with Reversal;We study the state complexity of boolean operations, concatenation, and star, with one or two of the argument languages reversed. We derive tight upper bounds for the symmetric differences and differences of such languages. We prove that the previously discovered bounds for union, intersection, concatenation and star of such languages can all be met by the recently introduced universal witness and its variants.
8;David Liu;Janusz Brzozowski;Universal Witnesses for State Complexity of Basic Operations Combined with Reversal;We study the state complexity of boolean operations, concatenation, and star, with one or two of the argument languages reversed. We derive tight upper bounds for the symmetric differences and differences of such languages. We prove that the previously discovered bounds for union, intersection, concatenation and star of such languages can all be met by the recently introduced universal witness and its variants.
8;Mathieu Caralp;Pierre-Alain Reynier, Jean-Marc Talbot;Trimming Visibly Pushdown Automata;We study the problem of trimming visibly pushdown automata (VPA). We first describe a polynomial time procedure which, given a visibly pushdown automaton that accepts only well-nested words, returns an equivalent visibly pushdown automaton that is trimmed. We then show how this procedure can be lifted to the setting of arbitrary VPA. Furthermore, we present a way of building, given a VPA, an equivalent VPA which is both deterministic and trimmed.
8;Pierre-Alain Reynier;Mathieu Caralp, Jean-Marc Talbot;Trimming Visibly Pushdown Automata;We study the problem of trimming visibly pushdown automata (VPA). We first describe a polynomial time procedure which, given a visibly pushdown automaton that accepts only well-nested words, returns an equivalent visibly pushdown automaton that is trimmed. We then show how this procedure can be lifted to the setting of arbitrary VPA. Furthermore, we present a way of building, given a VPA, an equivalent VPA which is both deterministic and trimmed.
8;Jean-Marc Talbot;Mathieu Caralp, Pierre-Alain Reynier;Trimming Visibly Pushdown Automata;We study the problem of trimming visibly pushdown automata (VPA). We first describe a polynomial time procedure which, given a visibly pushdown automaton that accepts only well-nested words, returns an equivalent visibly pushdown automaton that is trimmed. We then show how this procedure can be lifted to the setting of arbitrary VPA. Furthermore, we present a way of building, given a VPA, an equivalent VPA which is both deterministic and trimmed.
8;Dmitry Chistikov;Rupak Majumdar;A Uniformization Theorem for Nested Word to Word Transductions;We study the class of relations implemented by nested word to word transducers (also known as visibly pushdown transducers). We show that any such relation can be uniformized by a functional relation from the same class, implemented by an unambiguous transducer. We give an exponential upper bound on the state complexity of the uniformization, improving a previous doubly exponential upper bound. Our construction generalizes a classical construction by Schützenberger for the disambiguation of nondeterministic finite-state automata, using determinization and summarization constructions on nested word automata. Besides theoretical interest, our procedure can be the basis for synthesis procedures for nested word to word transductions.
8;Rupak Majumdar;Dmitry Chistikov;A Uniformization Theorem for Nested Word to Word Transductions;We study the class of relations implemented by nested word to word transducers (also known as visibly pushdown transducers). We show that any such relation can be uniformized by a functional relation from the same class, implemented by an unambiguous transducer. We give an exponential upper bound on the state complexity of the uniformization, improving a previous doubly exponential upper bound. Our construction generalizes a classical construction by Schützenberger for the disambiguation of nondeterministic finite-state automata, using determinization and summarization constructions on nested word automata. Besides theoretical interest, our procedure can be the basis for synthesis procedures for nested word to word transductions.
8;Pierpaolo Degano;Gian-Luigi Ferrari, Gianluca Mezzetti;Towards Nominal Context-Free Model-Checking;Two kinds of automata are introduced, for recognising regular and context-free nominal languages. We compare their expressive power with that of analogous proposals in the literature. Some properties of our languages are proved, in particular that emptiness of a context-free nominal language L is decidable, and that the intersection of L with a regular nominal language is still context-free. This paves the way for model-checking systems against access control properties in the nominal case, which is our main objective.
8;Gian-Luigi Ferrari;Pierpaolo Degano, Gianluca Mezzetti;Towards Nominal Context-Free Model-Checking;Two kinds of automata are introduced, for recognising regular and context-free nominal languages. We compare their expressive power with that of analogous proposals in the literature. Some properties of our languages are proved, in particular that emptiness of a context-free nominal language L is decidable, and that the intersection of L with a regular nominal language is still context-free. This paves the way for model-checking systems against access control properties in the nominal case, which is our main objective.
8;Gianluca Mezzetti;Pierpaolo Degano, Gian-Luigi Ferrari;Towards Nominal Context-Free Model-Checking;Two kinds of automata are introduced, for recognising regular and context-free nominal languages. We compare their expressive power with that of analogous proposals in the literature. Some properties of our languages are proved, in particular that emptiness of a context-free nominal language L is decidable, and that the intersection of L with a regular nominal language is still context-free. This paves the way for model-checking systems against access control properties in the nominal case, which is our main objective.
8;Akim Demaille;Alexandre Duret-Lutz, Sylvain Lombardy, Jacques Sakarovitch;Implementation Concepts in Vaucanson 2;Vaucanson is an open source C++ platform dedicated to the computation with finite weighted automata. It is generic: it allows to write algorithms that apply on a wide set of mathematical objects. Initiated ten years ago, several shortcomings were discovered along the years, especially problems related to code complexity and obfuscation as well as performance issues. This paper presents the concepts underlying Vaucanson 2, a complete rewrite of the platform that addresses these issues.
8;Alexandre Duret-Lutz;Akim Demaille, Sylvain Lombardy, Jacques Sakarovitch;Implementation Concepts in Vaucanson 2;Vaucanson is an open source C++ platform dedicated to the computation with finite weighted automata. It is generic: it allows to write algorithms that apply on a wide set of mathematical objects. Initiated ten years ago, several shortcomings were discovered along the years, especially problems related to code complexity and obfuscation as well as performance issues. This paper presents the concepts underlying Vaucanson 2, a complete rewrite of the platform that addresses these issues.
8;Sylvain Lombardy;Akim Demaille, Alexandre Duret-Lutz, Jacques Sakarovitch;Implementation Concepts in Vaucanson 2;Vaucanson is an open source C++ platform dedicated to the computation with finite weighted automata. It is generic: it allows to write algorithms that apply on a wide set of mathematical objects. Initiated ten years ago, several shortcomings were discovered along the years, especially problems related to code complexity and obfuscation as well as performance issues. This paper presents the concepts underlying Vaucanson 2, a complete rewrite of the platform that addresses these issues.
8;Jacques Sakarovitch;Akim Demaille, Alexandre Duret-Lutz, Sylvain Lombardy;Implementation Concepts in Vaucanson 2;Vaucanson is an open source C++ platform dedicated to the computation with finite weighted automata. It is generic: it allows to write algorithms that apply on a wide set of mathematical objects. Initiated ten years ago, several shortcomings were discovered along the years, especially problems related to code complexity and obfuscation as well as performance issues. This paper presents the concepts underlying Vaucanson 2, a complete rewrite of the platform that addresses these issues.
8;Thomas Genet;Tristan Le Gall, Axel Legay, Valérie Murat;A Completion Algorithm for Lattice Tree Automata;When dealing with infinite-state systems, Regular Tree Model Checking approaches may have some difficulties to represent infinite sets of data. We propose Lattice Tree Automata, an extended version of tree automata to represent complex data domains and their related operations in an efficient manner. Moreover, we introduce a new completion-based algorithm for computing the possibly infinite set of reachable states in a finite amount of time. This algorithm is independent of the lattice making it possible to seamlessly plug abstract domains into a Regular Tree Model Checking algorithm. As a first instance, we implemented a completion with an interval abstract domain. We provide some experiments showing that this implementation permits to scale up regular tree model-checking of Java programs dealing with integer arithmetics.
8;Tristan Le Gall;Thomas Genet, Axel Legay, Valérie Murat;A Completion Algorithm for Lattice Tree Automata;When dealing with infinite-state systems, Regular Tree Model Checking approaches may have some difficulties to represent infinite sets of data. We propose Lattice Tree Automata, an extended version of tree automata to represent complex data domains and their related operations in an efficient manner. Moreover, we introduce a new completion-based algorithm for computing the possibly infinite set of reachable states in a finite amount of time. This algorithm is independent of the lattice making it possible to seamlessly plug abstract domains into a Regular Tree Model Checking algorithm. As a first instance, we implemented a completion with an interval abstract domain. We provide some experiments showing that this implementation permits to scale up regular tree model-checking of Java programs dealing with integer arithmetics.
8;Axel Legay;Thomas Genet, Tristan Le Gall, Valérie Murat;A Completion Algorithm for Lattice Tree Automata;When dealing with infinite-state systems, Regular Tree Model Checking approaches may have some difficulties to represent infinite sets of data. We propose Lattice Tree Automata, an extended version of tree automata to represent complex data domains and their related operations in an efficient manner. Moreover, we introduce a new completion-based algorithm for computing the possibly infinite set of reachable states in a finite amount of time. This algorithm is independent of the lattice making it possible to seamlessly plug abstract domains into a Regular Tree Model Checking algorithm. As a first instance, we implemented a completion with an interval abstract domain. We provide some experiments showing that this implementation permits to scale up regular tree model-checking of Java programs dealing with integer arithmetics.
8;Valérie Murat;Thomas Genet, Tristan Le Gall, Axel Legay;A Completion Algorithm for Lattice Tree Automata;When dealing with infinite-state systems, Regular Tree Model Checking approaches may have some difficulties to represent infinite sets of data. We propose Lattice Tree Automata, an extended version of tree automata to represent complex data domains and their related operations in an efficient manner. Moreover, we introduce a new completion-based algorithm for computing the possibly infinite set of reachable states in a finite amount of time. This algorithm is independent of the lattice making it possible to seamlessly plug abstract domains into a Regular Tree Model Checking algorithm. As a first instance, we implemented a completion with an interval abstract domain. We provide some experiments showing that this implementation permits to scale up regular tree model-checking of Java programs dealing with integer arithmetics.
8;Yo-Sub Han;Sang-Ki Ko, Kai Salomaa;Approximate Matching between a Context-Free Grammar and a Finite-State Automaton;Given a context-free grammar (CFG) and a finite-state automaton (FA), we tackle the problem of computing the most similar pair of strings from two languages. We in particular consider three different gap cost models, linear, affine and concave models, that are crucial for finding a proper alignment between two bio sequences. We design efficient algorithms for computing the edit-distance between a CFG and an FA under these gap cost models. The time complexity of our algorithm for computing the linear or affine gap distance is polynomial and the time complexity for the concave gap distance is exponential.
8;Sang-Ki Ko;Yo-Sub Han, Kai Salomaa;Approximate Matching between a Context-Free Grammar and a Finite-State Automaton;Given a context-free grammar (CFG) and a finite-state automaton (FA), we tackle the problem of computing the most similar pair of strings from two languages. We in particular consider three different gap cost models, linear, affine and concave models, that are crucial for finding a proper alignment between two bio sequences. We design efficient algorithms for computing the edit-distance between a CFG and an FA under these gap cost models. The time complexity of our algorithm for computing the linear or affine gap distance is polynomial and the time complexity for the concave gap distance is exponential.
8;Kai Salomaa;Yo-Sub Han, Sang-Ki Ko;Approximate Matching between a Context-Free Grammar and a Finite-State Automaton;Given a context-free grammar (CFG) and a finite-state automaton (FA), we tackle the problem of computing the most similar pair of strings from two languages. We in particular consider three different gap cost models, linear, affine and concave models, that are crucial for finding a proper alignment between two bio sequences. We design efficient algorithms for computing the edit-distance between a CFG and an FA under these gap cost models. The time complexity of our algorithm for computing the linear or affine gap distance is polynomial and the time complexity for the concave gap distance is exponential.
8;Md. Mahbubul Hasan;A. S. M. Sohidull Islam, M. Sohel Rahman, Ayon Sen;On Palindromic Sequence Automata and Applications;In this paper, we present a novel weighted finite automata called PSA (Palindromic Subsequence Automata) that is a compact representation of all the palindromic subsequences of a string. Then we use PSA to solve the LCPS (Longest Common Palindromic Subsequence) problem. Our automata based algorithms are efficient both in theory and in practice.
8;A. S. M. Sohidull Islam;Md. Mahbubul Hasan, M. Sohel Rahman, Ayon Sen;On Palindromic Sequence Automata and Applications;In this paper, we present a novel weighted finite automata called PSA (Palindromic Subsequence Automata) that is a compact representation of all the palindromic subsequences of a string. Then we use PSA to solve the LCPS (Longest Common Palindromic Subsequence) problem. Our automata based algorithms are efficient both in theory and in practice.
8;M. Sohel Rahman;Md. Mahbubul Hasan, A. S. M. Sohidull Islam, Ayon Sen;On Palindromic Sequence Automata and Applications;In this paper, we present a novel weighted finite automata called PSA (Palindromic Subsequence Automata) that is a compact representation of all the palindromic subsequences of a string. Then we use PSA to solve the LCPS (Longest Common Palindromic Subsequence) problem. Our automata based algorithms are efficient both in theory and in practice.
8;Ayon Sen;Md. Mahbubul Hasan, A. S. M. Sohidull Islam, M. Sohel Rahman;On Palindromic Sequence Automata and Applications;In this paper, we present a novel weighted finite automata called PSA (Palindromic Subsequence Automata) that is a compact representation of all the palindromic subsequences of a string. Then we use PSA to solve the LCPS (Longest Common Palindromic Subsequence) problem. Our automata based algorithms are efficient both in theory and in practice.
8;Patrick Henry;Géraud Sénizergues; LALBLC A Program Testing the Equivalence of dpda’s;We describe the program LALBLC which tests whether two deterministic pushdown automata recognize the same language.
8;Géraud Sénizergues;Patrick Henry; LALBLC A Program Testing the Equivalence of dpda’s;We describe the program LALBLC which tests whether two deterministic pushdown automata recognize the same language.
8;Markus Holzer;Sebastian Jakobi;Brzozowski’s Minimization Algorithm—More Robust than Expected;For a finite automaton, regardless whether it is deterministic or nondeterministic, Brzozowski’s minimization algorithm computes the equivalent minimal deterministic finite automaton by applying reversal and power-set construction twice. Although this is an exponential algorithm because of the power-set construction, it performs well in experimental studies compared to efficient O(nlogn) minimization algorithms. Here we show how to slightly enhance Brzozowski’s minimization algorithm by some sort of reachability information so that it can be applied to the following automata models: deterministic cover automata, almost equivalent deterministic finite state machines, and k-similar automata.
8;Sebastian Jakobi;Markus Holzer;Brzozowski’s Minimization Algorithm—More Robust than Expected;For a finite automaton, regardless whether it is deterministic or nondeterministic, Brzozowski’s minimization algorithm computes the equivalent minimal deterministic finite automaton by applying reversal and power-set construction twice. Although this is an exponential algorithm because of the power-set construction, it performs well in experimental studies compared to efficient O(nlogn) minimization algorithms. Here we show how to slightly enhance Brzozowski’s minimization algorithm by some sort of reachability information so that it can be applied to the following automata models: deterministic cover automata, almost equivalent deterministic finite state machines, and k-similar automata.
8;Oscar H. Ibarra;Bala Ravikumar;Some Decision Problems Concerning NPDAs, Palindromes, and Dyck Languages;We address several types of decision questions related to context-free languages when an NPDA is given as input. First we consider the question of whether the NPDA makes a bounded number of stack reversals (over all accepting inputs) and show that this problem is undecidable even when the NPDA is only 2-ambiguous. We consider the same problem for counter machines (i.e., whether the counter makes a bounded number of reversals) and show that it is also undecidable. On the other hand, we show that the problem is decidable for unambiguous NPDAs even when augmented with reversal-bounded counters. Next, we look at problems of equivalence, containment and disjointness with fixed languages. With the fixed language L0 being one of the following: P = \(\{ x \# x^r \ | \)x ∈ (0 + 1)* }, Pu = \(\{ x x^r \ | \)x ∈ (0 + 1)* }, Dk = Dyck language with k-type of parentheses, or Sk = two-sided Dyck language with k types of parentheses, we consider problems such as: ‘Is L(M) ∩ L0 = ∅?’, ‘Is L(M) ⊆ L0?’, or ‘Is L(M) = L0?’, where M is an input NPDA (or a restricted form of it). For example, we show that the problem, ‘Is L(M) ∩ P?’, is undecidable when M is a deterministic one-counter acceptor, while the problem ‘Is L(M) ⊆ P?’ is decidable even for NPDAs augmented with reversal-bounded counters. Another result is that the problem ‘Is L(M) ⊆ Pu?’ is decidable in polynomial time for M an NPDA. We also show several other related decidability and undecidability results.
8;Bala Ravikumar;Oscar H. Ibarra;Some Decision Problems Concerning NPDAs, Palindromes, and Dyck Languages;We address several types of decision questions related to context-free languages when an NPDA is given as input. First we consider the question of whether the NPDA makes a bounded number of stack reversals (over all accepting inputs) and show that this problem is undecidable even when the NPDA is only 2-ambiguous. We consider the same problem for counter machines (i.e., whether the counter makes a bounded number of reversals) and show that it is also undecidable. On the other hand, we show that the problem is decidable for unambiguous NPDAs even when augmented with reversal-bounded counters. Next, we look at problems of equivalence, containment and disjointness with fixed languages. With the fixed language L0 being one of the following: P = \(\{ x \# x^r \ | \)x ∈ (0 + 1)* }, Pu = \(\{ x x^r \ | \)x ∈ (0 + 1)* }, Dk = Dyck language with k-type of parentheses, or Sk = two-sided Dyck language with k types of parentheses, we consider problems such as: ‘Is L(M) ∩ L0 = ∅?’, ‘Is L(M) ⊆ L0?’, or ‘Is L(M) = L0?’, where M is an input NPDA (or a restricted form of it). For example, we show that the problem, ‘Is L(M) ∩ P?’, is undecidable when M is a deterministic one-counter acceptor, while the problem ‘Is L(M) ⊆ P?’ is decidable even for NPDAs augmented with reversal-bounded counters. Another result is that the problem ‘Is L(M) ⊆ Pu?’ is decidable in polynomial time for M an NPDA. We also show several other related decidability and undecidability results.
8;Jozef Jirásek;Galina Jirásková;On the Boundary of Regular Languages;We prove that the tight bound on the state complexity of the boundary of regular languages, defined as bd\((L)=L^* \cap ( \, \overline{L} \, )^*\), is 22n − 2 + 22n − 3 + 2n − 2 + 2 − 2·3n − 2 − n. Our witness languages are described over a five-letter alphabet. For a four-letter alphabet, the lower bound is smaller by just one, and we conjecture that the upper bound cannot be met in the quaternary case.
8;Galina Jirásková;Jozef Jirásek;On the Boundary of Regular Languages;We prove that the tight bound on the state complexity of the boundary of regular languages, defined as bd\((L)=L^* \cap ( \, \overline{L} \, )^*\), is 22n − 2 + 22n − 3 + 2n − 2 + 2 − 2·3n − 2 − n. Our witness languages are described over a five-letter alphabet. For a four-letter alphabet, the lower bound is smaller by just one, and we conjecture that the upper bound cannot be met in the quaternary case.
9;Yuan Gao;Kai Salomaa;In Memoriam Sheng Yu;Professor Sheng Yu passed away unexpectedly in London, Canada on January 23, 2012, one day before his 62nd birthday. Sheng was one of the world leading theoretical computer scientists. His strong commitment to excellence in scholarship has touched everyone who has worked or studied with him. This includes a large segment of the “CIAA community” and, in particular, the authors of the current article. Sheng Yu’s work will continue to influence and inspire automata theory research for a long time to come.
9;Kai Salomaa;Yuan Gao;In Memoriam Sheng Yu;Professor Sheng Yu passed away unexpectedly in London, Canada on January 23, 2012, one day before his 62nd birthday. Sheng was one of the world leading theoretical computer scientists. His strong commitment to excellence in scholarship has touched everyone who has worked or studied with him. This includes a large segment of the “CIAA community” and, in particular, the authors of the current article. Sheng Yu’s work will continue to influence and inspire automata theory research for a long time to come.
9;Janusz Brzozowski;;In Search of Most Complex Regular Languages;Regular languages that are most complex under common complexity measures are studied. In particular, certain ternary languages Un(a,b,c), \(n\geqslant 3\), over the alphabet {a,b,c} are examined. It is proved that the state complexity bounds that hold for arbitrary regular languages are also met by the languages Un(a,b,c) for union, intersection, difference, symmetric difference, product (concatenation) and star. Maximal bounds are also met by Un(a,b,c) for the number of atoms, the quotient complexity of atoms, the size of the syntactic semigroup, reversal, and 22 combined operations, 5 of which require slightly modified versions. The language Un(a,b,c,d) is an extension of Un(a,b,c), obtained by adding an identity input to the minimal DFA of Un(a,b,c). The witness Un(a,b,c,d) and its modified versions work for 14 more combined operations. Thus Un(a,b,c) and Un(a,b,c,d) appear to be universal witnesses for alphabets of size 3 and 4, respectively.
9;Andrzej Ehrenfeucht;Grzegorz Rozenberg;A Formal Framework for Processes Inspired by the Functioning of Living Cells;Natural Computing is concerned with both human-designed computing inspired by nature and computing taking place in nature. The former research strand investigates computational techniques, models of computation and computational devices inspired by nature. The latter research strand investigates, in terms of information processing, processes taking place in nature.
9;Grzegorz Rozenberg;Andrzej Ehrenfeucht;A Formal Framework for Processes Inspired by the Functioning of Living Cells;Natural Computing is concerned with both human-designed computing inspired by nature and computing taking place in nature. The former research strand investigates computational techniques, models of computation and computational devices inspired by nature. The latter research strand investigates, in terms of information processing, processes taking place in nature.
9;Paul Gastin;Benjamin Monmege;Adding Pebbles to Weighted Automata;We extend weighted automata and weighted rational expressions with 2-way moves and (reusable) pebbles. We show with examples from natural language modeling and quantitative model-checking that weighted expressions and automata with pebbles are more expressive and allow much more natural and intuitive specifications than classical ones. We extend Kleene-Schützenberger theorem showing that weighted expressions and automata with pebbles have the same expressive power. We focus on an efficient translation from expressions to automata. We also prove that the evaluation problem for weighted automata can be done very efficiently if the number of (reusable) pebbles is low.
9;Benjamin Monmege;Paul Gastin;Adding Pebbles to Weighted Automata;We extend weighted automata and weighted rational expressions with 2-way moves and (reusable) pebbles. We show with examples from natural language modeling and quantitative model-checking that weighted expressions and automata with pebbles are more expressive and allow much more natural and intuitive specifications than classical ones. We extend Kleene-Schützenberger theorem showing that weighted expressions and automata with pebbles have the same expressive power. We focus on an efficient translation from expressions to automata. We also prove that the evaluation problem for weighted automata can be done very efficiently if the number of (reusable) pebbles is low.
9;José N. Oliveira;;Typed Linear Algebra for Weigthed (Probabilistic) Automata;There is a need for a language able to reconcile the recent upsurge of interest in quantitative methods in the software sciences with logic and set theory that have been used for so many years in capturing the qualitative aspects of the same body of knowledge. Such a lingua franca should be typed, polymorphic, diagrammatic, calculational and easy to blend with traditional notation.
9;Cyril Allauzen;Michael Riley;A Pushdown Transducer Extension for the OpenFst Library;Pushdown automata are devices that can efficiently represent context-free languages, have natural weighted versions, and combine naturally with finite automata. We describe a pushdown transducer extension to OpenFst, a weighted finite-state transducer library. We present several weighted pushdown algorithms, some with clear finite-state analogues, describe their library usage and give some applications of these methods to recognition, parsing and translation.
9;Michael Riley;Cyril Allauzen;A Pushdown Transducer Extension for the OpenFst Library;Pushdown automata are devices that can efficiently represent context-free languages, have natural weighted versions, and combine naturally with finite automata. We describe a pushdown transducer extension to OpenFst, a weighted finite-state transducer library. We present several weighted pushdown algorithms, some with clear finite-state analogues, describe their library usage and give some applications of these methods to recognition, parsing and translation.
9;Joshua Amavi;Jacques Chabin, Pierre Réty;Weak Inclusion for Recursive XML Types;Considering that the unranked tree languages L(G) and L(G′) are those defined by given possibly-recursive XML typesG and G′, this paper proposes a method to verify whether L(G) is “approximatively” included in L(G′). The approximation consists in weakening the father-children relationships. Experimental results are discussed, showing the efficiency of our method in many situations.
9;Jacques Chabin;Joshua Amavi, Pierre Réty;Weak Inclusion for Recursive XML Types;Considering that the unranked tree languages L(G) and L(G′) are those defined by given possibly-recursive XML typesG and G′, this paper proposes a method to verify whether L(G) is “approximatively” included in L(G′). The approximation consists in weakening the father-children relationships. Experimental results are discussed, showing the efficiency of our method in many situations.
9;Pierre Réty;Joshua Amavi, Jacques Chabin;Weak Inclusion for Recursive XML Types;Considering that the unranked tree languages L(G) and L(G′) are those defined by given possibly-recursive XML typesG and G′, this paper proposes a method to verify whether L(G) is “approximatively” included in L(G′). The approximation consists in weakening the father-children relationships. Experimental results are discussed, showing the efficiency of our method in many situations.
9;Mikhail V. Berlinkov;;Synchronizing Automata on Quasi-Eulerian Digraph;We describe a new version of the so-called extension method that was used to prove quadratic upper bounds on the minimum length of reset words for various important classes of synchronizing automata. Our approach is formulated in terms of Markov chains. it is in a sense dual to the usual extension method and improves on a recent result by Jungers. As an application, we obtain a quadratic upper bound on the minimum length of reset words for a generalization of Eulerian automata.
9;Tullio Ceccherini-Silberstein;Michel Coornaert, Francesca Fiorenzi, Zoran Šunić;Cellular Automata on Regular Rooted Trees;We study cellular automata on regular rooted trees. This includes the characterization of sofic tree shifts in terms of unrestricted Rabin automata and the decidability of the surjectivity problem for cellular automata between sofic tree shifts.
9;Michel Coornaert;Tullio Ceccherini-Silberstein, Francesca Fiorenzi, Zoran Šunić;Cellular Automata on Regular Rooted Trees;We study cellular automata on regular rooted trees. This includes the characterization of sofic tree shifts in terms of unrestricted Rabin automata and the decidability of the surjectivity problem for cellular automata between sofic tree shifts.
9;Francesca Fiorenzi;Tullio Ceccherini-Silberstein, Michel Coornaert, Zoran Šunić;Cellular Automata on Regular Rooted Trees;We study cellular automata on regular rooted trees. This includes the characterization of sofic tree shifts in terms of unrestricted Rabin automata and the decidability of the surjectivity problem for cellular automata between sofic tree shifts.
9;Zoran Šunić;Tullio Ceccherini-Silberstein, Michel Coornaert, Francesca Fiorenzi;Cellular Automata on Regular Rooted Trees;We study cellular automata on regular rooted trees. This includes the characterization of sofic tree shifts in terms of unrestricted Rabin automata and the decidability of the surjectivity problem for cellular automata between sofic tree shifts.
9;Stefano Crespi Reghizzi;Pierluigi L. San Pietro;Strict Local Testability with Consensus Equals Regularity;A recent language definition device named consensual is based on agreement between similar words. Considering, say, a regular set of words over a bipartite alphabet made by pairs of unmarked/marked letters, the match relation specifies when such words agree. Therefore a regular set (the “base”) over the bipartite alphabet specifies another language over the unmarked alphabet, called the consensual language. A word is in the consensual language if a set of corresponding matching words is in the base. From previous results, the family of consensual languages based on regular sets have an NLOGSPACE word problem, include non-semilinear languages, and are incomparable with the context-free (CF) ones. moreover the size of a consensual specification can be in a logarithmic ratio with respect to a NFA for the same language. We study the consensual languages that are produced by other language families: the Strictly Locally Testable of McNaughton and Papert and the context-free/sensitive ones. Using a recent generalization of Medvedev’s homomorphic characterization of regular languages, we prove that regular languages are exactly the consensual languages based on strictly locally testable sets, a result that hints at a novel parallel decomposition of finite automata into locally testable components. The consensual family based on context-free sets strictly includes the CF family, while the consensual and the base families collapse together if the context-sensitive languages are chosen instead of the CF.
9;Pierluigi L. San Pietro;Stefano Crespi Reghizzi;Strict Local Testability with Consensus Equals Regularity;A recent language definition device named consensual is based on agreement between similar words. Considering, say, a regular set of words over a bipartite alphabet made by pairs of unmarked/marked letters, the match relation specifies when such words agree. Therefore a regular set (the “base”) over the bipartite alphabet specifies another language over the unmarked alphabet, called the consensual language. A word is in the consensual language if a set of corresponding matching words is in the base. From previous results, the family of consensual languages based on regular sets have an NLOGSPACE word problem, include non-semilinear languages, and are incomparable with the context-free (CF) ones. moreover the size of a consensual specification can be in a logarithmic ratio with respect to a NFA for the same language. We study the consensual languages that are produced by other language families: the Strictly Locally Testable of McNaughton and Papert and the context-free/sensitive ones. Using a recent generalization of Medvedev’s homomorphic characterization of regular languages, we prove that regular languages are exactly the consensual languages based on strictly locally testable sets, a result that hints at a novel parallel decomposition of finite automata into locally testable components. The consensual family based on context-free sets strictly includes the CF family, while the consensual and the base families collapse together if the context-sensitive languages are chosen instead of the CF.
9;Pierpaolo Degano;Gian-Luigi Ferrari, Gianluca Mezzetti;Nominal Automata for Resource Usage Control;Two classes of nominal automata, namely Usage Automata (UAs) and Variable Finite Automata (VFAs) are considered to express resource control policies over program execution traces expressed by a nominal calculus (Usages). We first analyse closure properties of UAs, and then show UAs less expressive than VFAs. We finally carry over to VFAs the symbolic technique for model checking Usages against UAs, so making it possible to verify the compliance of a program with a larger class of security properties.
9;Gian-Luigi Ferrari;Pierpaolo Degano, Gianluca Mezzetti;Nominal Automata for Resource Usage Control;Two classes of nominal automata, namely Usage Automata (UAs) and Variable Finite Automata (VFAs) are considered to express resource control policies over program execution traces expressed by a nominal calculus (Usages). We first analyse closure properties of UAs, and then show UAs less expressive than VFAs. We finally carry over to VFAs the symbolic technique for model checking Usages against UAs, so making it possible to verify the compliance of a program with a larger class of security properties.
9;Gianluca Mezzetti;Pierpaolo Degano, Gian-Luigi Ferrari;Nominal Automata for Resource Usage Control;Two classes of nominal automata, namely Usage Automata (UAs) and Variable Finite Automata (VFAs) are considered to express resource control policies over program execution traces expressed by a nominal calculus (Usages). We first analyse closure properties of UAs, and then show UAs less expressive than VFAs. We finally carry over to VFAs the symbolic technique for model checking Usages against UAs, so making it possible to verify the compliance of a program with a larger class of security properties.
9;Manfred Droste;Bundit Pibaljommee;Weighted Nested Word Automata and Logics over Strong Bimonoids;Nested words have been introduced by Alur and Madhusudan as a model for e.g. recursive programs or XML documents and have received much recent interest. In this paper, we investigate a quantitative automaton model and a quantitative logic for nested words. The behavior resp. the semantics map nested words to weights taken from a strong bimonoid. Strong bimonoids can be viewed as semirings without requiring the distributivity assumption which was essential in the classical theory of formal power series. strong bimonoids include e.g. all bounded lattices and many other structures from multi-valued logics. Our main results show that weighted nested word automata and suitable weighted MSO logics are expressively equivalent. This extends the classical Büchi-Elgot result from words to a weighted setting for nested words.
9;Bundit Pibaljommee;Manfred Droste;Weighted Nested Word Automata and Logics over Strong Bimonoids;Nested words have been introduced by Alur and Madhusudan as a model for e.g. recursive programs or XML documents and have received much recent interest. In this paper, we investigate a quantitative automaton model and a quantitative logic for nested words. The behavior resp. the semantics map nested words to weights taken from a strong bimonoid. Strong bimonoids can be viewed as semirings without requiring the distributivity assumption which was essential in the classical theory of formal power series. strong bimonoids include e.g. all bounded lattices and many other structures from multi-valued logics. Our main results show that weighted nested word automata and suitable weighted MSO logics are expressively equivalent. This extends the classical Büchi-Elgot result from words to a weighted setting for nested words.
9;Simone Faro;Thierry Lecroq;A Fast Suffix Automata Based Algorithm for Exact Online String Matching;Searching for all occurrences of a pattern in a text is a fundamental problem in computer science with applications in many other fields, like natural language processing, information retrieval and computational biology. Automata play a very important role in the design of efficient solutions for the exact string matching problem. In this paper we propose a new very simple solution which turns out to be very efficient in practical cases. It is based on a suitable factorization of the pattern and on a straightforward and light encoding of the suffix automaton. It turns out that on average the new technique leads to longer shift than that proposed by other known solutions which make use of suffix automata.
9;Thierry Lecroq;Simone Faro;A Fast Suffix Automata Based Algorithm for Exact Online String Matching;Searching for all occurrences of a pattern in a text is a fundamental problem in computer science with applications in many other fields, like natural language processing, information retrieval and computational biology. Automata play a very important role in the design of efficient solutions for the exact string matching problem. In this paper we propose a new very simple solution which turns out to be very efficient in practical cases. It is based on a suitable factorization of the pattern and on a straightforward and light encoding of the suffix automaton. It turns out that on average the new technique leads to longer shift than that proposed by other known solutions which make use of suffix automata.
9;Fedor Fominykh;Mikhail Volkov;P(l)aying for Synchronization;Two topics are presented: synchronization games and synchronization costs. In a synchronization game on a deterministic finite automaton, there are two players, Alice and Bob, whose moves alternate. Alice wants to synchronize the given automaton, while Bob aims to make her task as hard as possible. We answer a few natural questions related to such games. Speaking about synchronization costs, we consider deterministic automata in which each transition has a certain price. The problem is whether or not a given automaton can be synchronized within a given budget. We determine the complexity of this problem.
9;Mikhail Volkov;Fedor Fominykh;P(l)aying for Synchronization;Two topics are presented: synchronization games and synchronization costs. In a synchronization game on a deterministic finite automaton, there are two players, Alice and Bob, whose moves alternate. Alice wants to synchronize the given automaton, while Bob aims to make her task as hard as possible. We answer a few natural questions related to such games. Speaking about synchronization costs, we consider deterministic automata in which each transition has a certain price. The problem is whether or not a given automaton can be synchronized within a given budget. We determine the complexity of this problem.
9;Vladimir V. Gusev;;Synchronizing Automata of Bounded Rank;We reduce the problem of synchronization of an n-state automaton with letters of rank at most r &lt. n to the problem of synchronization of an r-state automaton with constraints given by a regular language. Using this technique we construct a series of synchronizing n-state automata in which every letter has rank r &lt. n and whose reset threshold is at least r2 − r − 1 Moreover, if \(r &gt. \frac{n}{2}\), such automata are strongly connected.
9;Daniel Goč;Dane Henshall, Jeffrey Shallit;Automatic Theorem-Proving in Combinatorics on Words;We describe a technique for mechanically proving certain kinds of theorems in combinatorics on words, using finite automata and a package for manipulating them. We illustrate our technique by applying it to (a) solve an open problem of Currie and Saari on the lengths of unbordered factors in the Thue-Morse sequence. (b) verify an old result of Prodinger and Urbanek on the paperfolding sequence and (c) find an explicit expression for the recurrence function for the Rudin-Shapiro sequence. All results were obtained by machine computations.
9;Dane Henshall;Daniel Goč, Jeffrey Shallit;Automatic Theorem-Proving in Combinatorics on Words;We describe a technique for mechanically proving certain kinds of theorems in combinatorics on words, using finite automata and a package for manipulating them. We illustrate our technique by applying it to (a) solve an open problem of Currie and Saari on the lengths of unbordered factors in the Thue-Morse sequence. (b) verify an old result of Prodinger and Urbanek on the paperfolding sequence and (c) find an explicit expression for the recurrence function for the Rudin-Shapiro sequence. All results were obtained by machine computations.
9;Jeffrey Shallit;Daniel Goč, Dane Henshall;Automatic Theorem-Proving in Combinatorics on Words;We describe a technique for mechanically proving certain kinds of theorems in combinatorics on words, using finite automata and a package for manipulating them. We illustrate our technique by applying it to (a) solve an open problem of Currie and Saari on the lengths of unbordered factors in the Thue-Morse sequence. (b) verify an old result of Prodinger and Urbanek on the paperfolding sequence and (c) find an explicit expression for the recurrence function for the Rudin-Shapiro sequence. All results were obtained by machine computations.
9;Oscar H. Ibarra;Nicholas Q. Tran;How to Synchronize the Heads of a Multitape Automaton;Given an n-tape automaton M with a one-way read-only head per tape and a right end marker $ on each tape, we say that M is aligned or 0-synchronized (or simply, synchronized) if for every n-tuple x = (x1, …, xn) that is accepted, there is a computation on x such that at any time during the computation, all heads, except those that have reached the end marker, are on the same position. When a head reaches the marker, it can no longer move. As usual, an n-tuple x = (x1, …, xn) is accepted if M eventually reaches the configuration where all n heads are on $ in an accepting state. In two recent papers, we looked at the problem of deciding, given an n-tape automaton of a given type, whether there exists an equivalent synchronized n-tape automaton of the same type. In this paper, we exhibit various classes of multitape automata which can(not) be converted to equivalent synchronized multitape automata.
9;Nicholas Q. Tran;Oscar H. Ibarra;How to Synchronize the Heads of a Multitape Automaton;Given an n-tape automaton M with a one-way read-only head per tape and a right end marker $ on each tape, we say that M is aligned or 0-synchronized (or simply, synchronized) if for every n-tuple x = (x1, …, xn) that is accepted, there is a computation on x such that at any time during the computation, all heads, except those that have reached the end marker, are on the same position. When a head reaches the marker, it can no longer move. As usual, an n-tuple x = (x1, …, xn) is accepted if M eventually reaches the configuration where all n heads are on $ in an accepting state. In two recent papers, we looked at the problem of deciding, given an n-tape automaton of a given type, whether there exists an equivalent synchronized n-tape automaton of the same type. In this paper, we exhibit various classes of multitape automata which can(not) be converted to equivalent synchronized multitape automata.
9;Franz Jahn;Manfred Kufleitner, Alexander Lauser;Regular Ideal Languages and Their Boolean Combinations;We consider ideals and Boolean combinations of ideals. For the regular languages within these classes we give expressively complete automaton models. In addition, we consider general properties of regular ideals and their Boolean combinations. These properties include effective algebraic characterizations and lattice identities.
9;Manfred Kufleitner;Franz Jahn, Alexander Lauser;Regular Ideal Languages and Their Boolean Combinations;We consider ideals and Boolean combinations of ideals. For the regular languages within these classes we give expressively complete automaton models. In addition, we consider general properties of regular ideals and their Boolean combinations. These properties include effective algebraic characterizations and lattice identities.
9;Alexander Lauser;Franz Jahn, Manfred Kufleitner;Regular Ideal Languages and Their Boolean Combinations;We consider ideals and Boolean combinations of ideals. For the regular languages within these classes we give expressively complete automaton models. In addition, we consider general properties of regular ideals and their Boolean combinations. These properties include effective algebraic characterizations and lattice identities.
9;Artur Jeż;Andreas Maletti;Hyper-minimization for Deterministic Tree Automata;Hyper-minimization aims to reduce the size of the representation of a language beyond the limits imposed by classical minimization. To this end, the hyper-minimal representation can represent a language that has a finite difference to the original language. The first hyper-minimization algorithm is presented for (bottom-up) deterministic tree automata, which represent the recognizable tree languages. It runs in time \({\cal O}(\ell m n)\), where ℓ is the maximal rank of the input symbols, m is the number of transitions, and n is the number of states of the input tree automaton.
9;Andreas Maletti;Artur Jeż;Hyper-minimization for Deterministic Tree Automata;Hyper-minimization aims to reduce the size of the representation of a language beyond the limits imposed by classical minimization. To this end, the hyper-minimal representation can represent a language that has a finite difference to the original language. The first hyper-minimization algorithm is presented for (bottom-up) deterministic tree automata, which represent the recognizable tree languages. It runs in time \({\cal O}(\ell m n)\), where ℓ is the maximal rank of the input symbols, m is the number of transitions, and n is the number of states of the input tree automaton.
10;Sheng Yu;;Derick Wood: Always in Our Hearts;Professor Derick Wood passed away on October 4, 2010. He was only seventy year old. His death was a great loss to his family, friends, colleagues and students, especially to his beloved wife Mary. He left us many interesting research results, more than three hundred publications [1], including three monograph and textbooks [3,4,5], and a lot of vivid memories of an energetic, thoughtful, humorous, careful, and decisive Derick Wood.
10;Olivier Gauwin;Joachim Niehren;Streamable Fragments of Forward XPath;We present a query answering algorithm for a fragment of Forward XPath on Xml streams that we obtain by compilation to deterministic nested word automata. Our algorithm is earliest and in polynomial time. This proves the finite streamability of the fragment of Forward XPath with child steps, outermost-descendant steps, label tests, negation, and conjunction (aka filters), under the reasonable assumption that the number of conjunctions is bounded. We also prove that finite streamability fails without this assumption except if P=NP.
10;Joachim Niehren;Olivier Gauwin;Streamable Fragments of Forward XPath;We present a query answering algorithm for a fragment of Forward XPath on Xml streams that we obtain by compilation to deterministic nested word automata. Our algorithm is earliest and in polynomial time. This proves the finite streamability of the fragment of Forward XPath with child steps, outermost-descendant steps, label tests, negation, and conjunction (aka filters), under the reasonable assumption that the number of conjunctions is bounded. We also prove that finite streamability fails without this assumption except if P=NP.
10;Markus Holzer;Martin Kutrib;Gaining Power by Input Operations: Finite Automata and Beyond;We summarize results on extended finite automata, which are basically finite state machines with the additional ability to manipulate the still unread part of the input. Well-known manipulation functions are reversal, left-revolving, right-revolving, and circular interchanging, or even biologically motivated functions as hairpin inversion. We mainly focus on the computational power of these machines and on the closure properties by standard formal language operations of the induced language families. Moreover, we also discuss several generalizations of this concept, the natural generalization to hybrid extended finite automata, which allows several input manipulation functions, and in particular, extended pushdown automata, which lead to an alternative characterization of Khabbaz hierarchy of languages. We do not prove these results but we merely draw attention to the big picture, some of the main ideas involved, and open problems for further research.
10;Martin Kutrib;Markus Holzer;Gaining Power by Input Operations: Finite Automata and Beyond;We summarize results on extended finite automata, which are basically finite state machines with the additional ability to manipulate the still unread part of the input. Well-known manipulation functions are reversal, left-revolving, right-revolving, and circular interchanging, or even biologically motivated functions as hairpin inversion. We mainly focus on the computational power of these machines and on the closure properties by standard formal language operations of the induced language families. Moreover, we also discuss several generalizations of this concept, the natural generalization to hybrid extended finite automata, which allows several input manipulation functions, and in particular, extended pushdown automata, which lead to an alternative characterization of Khabbaz hierarchy of languages. We do not prove these results but we merely draw attention to the big picture, some of the main ideas involved, and open problems for further research.
10;Joshua Amavi;Jacques Chabin, Mirian Halfeld Ferrari, Pierre Réty;Weak Inclusion for XML Types;Considering that the unranked tree languages L(G) and L(G′) are those defined by given non-recursive XML typesG and G′, this paper proposes a simple and intuitive method to verify whether L(G) is “approximatively” included in L(G′). Our approximative criterion consists in weakening the father-children relationships. Experimental results are discussed, showing the efficiency of our method in many situations.
10;Jacques Chabin;Joshua Amavi, Mirian Halfeld Ferrari, Pierre Réty;Weak Inclusion for XML Types;Considering that the unranked tree languages L(G) and L(G′) are those defined by given non-recursive XML typesG and G′, this paper proposes a simple and intuitive method to verify whether L(G) is “approximatively” included in L(G′). Our approximative criterion consists in weakening the father-children relationships. Experimental results are discussed, showing the efficiency of our method in many situations.
10;Mirian Halfeld Ferrari;Joshua Amavi, Jacques Chabin, Pierre Réty;Weak Inclusion for XML Types;Considering that the unranked tree languages L(G) and L(G′) are those defined by given non-recursive XML typesG and G′, this paper proposes a simple and intuitive method to verify whether L(G) is “approximatively” included in L(G′). Our approximative criterion consists in weakening the father-children relationships. Experimental results are discussed, showing the efficiency of our method in many situations.
10;Pierre Réty;Joshua Amavi, Jacques Chabin, Mirian Halfeld Ferrari;Weak Inclusion for XML Types;Considering that the unranked tree languages L(G) and L(G′) are those defined by given non-recursive XML typesG and G′, this paper proposes a simple and intuitive method to verify whether L(G) is “approximatively” included in L(G′). Our approximative criterion consists in weakening the father-children relationships. Experimental results are discussed, showing the efficiency of our method in many situations.
10;Denis Béchet;Alexandre Dikovsky, Annie Foret;Categorial Grammars with Iterated Types form a Strict Hierarchy of k-Valued Languages;The notion of k-valued categorial grammars where a word is associated to at most k types is often used in the field of lexicalized grammars as a fruitful constraint for obtaining several properties like the existence of learning algorithms. This principle is relevant only when the classes of k-valued grammars correspond to a real hierarchy of languages. Such a property had been shown earlier for classical categorial grammars.
10;Alexandre Dikovsky;Denis Béchet, Annie Foret;Categorial Grammars with Iterated Types form a Strict Hierarchy of k-Valued Languages;The notion of k-valued categorial grammars where a word is associated to at most k types is often used in the field of lexicalized grammars as a fruitful constraint for obtaining several properties like the existence of learning algorithms. This principle is relevant only when the classes of k-valued grammars correspond to a real hierarchy of languages. Such a property had been shown earlier for classical categorial grammars.
10;Annie Foret;Denis Béchet, Alexandre Dikovsky;Categorial Grammars with Iterated Types form a Strict Hierarchy of k-Valued Languages;The notion of k-valued categorial grammars where a word is associated to at most k types is often used in the field of lexicalized grammars as a fruitful constraint for obtaining several properties like the existence of learning algorithms. This principle is relevant only when the classes of k-valued grammars correspond to a real hierarchy of languages. Such a property had been shown earlier for classical categorial grammars.
10;Erez Buchnik;;Bouma2 – A High-Performance Input-Aware Multiple String-Match Algorithm;We present Bouma2, a new algorithm for exact multiple string-match. It is highly parallelizable, has small footprint, and can be tuned using statistics of the input stream. It uses a special hashing technique to map the pattern-set to 2-symbol sequences, allowing the match procedure to be considerably optimized. This algorithm employs a fast-path/slow-path principle at match-time, which facilitates pipelining in H/W. We also produce experimental comparative results.
10;Vincent Carnino;Sven De Felice;Random Generation of Deterministic Acyclic Automata Using Markov Chains;In this article we propose an algorithm, based on Markov chain techniques, to generate random automata that are deterministic, accessible and acyclic. The distribution of the output approaches the uniform distribution on n-state such automata. We then show how to adapt this algorithm in order to generate minimal acyclic automata with n states almost uniformly.
10;Sven De Felice;Vincent Carnino;Random Generation of Deterministic Acyclic Automata Using Markov Chains;In this article we propose an algorithm, based on Markov chain techniques, to generate random automata that are deterministic, accessible and acyclic. The distribution of the output approaches the uniform distribution on n-state such automata. We then show how to adapt this algorithm in order to generate minimal acyclic automata with n states almost uniformly.
10;José M. Castaño;Rodrigo Castaño;Variable and Clause Ordering in an FSA Approach to Propositional Satisfiability;We use a finite state (FSA) construction approach to address the problem of propositional satisfiability (SAT). We use a very simple translation from formulas in conjunctive normal form (CNF) to regular expressions and use regular expressions to construct an FSA. As a consequence of the FSA construction, we obtain an ALL-SAT solver and model counter. We compare how several variable ordering (state ordering) heuristics affect the running time of the FSA construction. We also present a strategy for clause ordering (automata composition). We compare the running time of state-of-the-art model counters, BDD based sat solvers and we show that this FSA approach obtains state-of-the-art performance on some hard unsatisfiable benchmarks. This work brings up many questions on the possible use of automata to address SAT.
10;Rodrigo Castaño;José M. Castaño;Variable and Clause Ordering in an FSA Approach to Propositional Satisfiability;We use a finite state (FSA) construction approach to address the problem of propositional satisfiability (SAT). We use a very simple translation from formulas in conjunctive normal form (CNF) to regular expressions and use regular expressions to construct an FSA. As a consequence of the FSA construction, we obtain an ALL-SAT solver and model counter. We compare how several variable ordering (state ordering) heuristics affect the running time of the FSA construction. We also present a strategy for clause ordering (automata composition). We compare the running time of state-of-the-art model counters, BDD based sat solvers and we show that this FSA approach obtains state-of-the-art performance on some hard unsatisfiable benchmarks. This work brings up many questions on the possible use of automata to address SAT.
10;Giusi Castiglione;Antonio Restivo, Marinella Sciortino;Nondeterministic Moore Automata and Brzozowski’s Algorithm;Moore automata represent a model that has many applications. In this paper we define a notion of coherent nondeterministic Moore automaton (NMA) and show that such a model has the same computational power of the classical deterministic Moore automaton. We consider also the problem of constructing the minimal deterministic Moore automaton equivalent to a given NMA. In this paper we propose an algorithm that is a variant of Brzozowski’s algorithm in the sense that it is essentially structured as reverse operation and subset construction performed twice.
10;Antonio Restivo;Giusi Castiglione, Marinella Sciortino;Nondeterministic Moore Automata and Brzozowski’s Algorithm;Moore automata represent a model that has many applications. In this paper we define a notion of coherent nondeterministic Moore automaton (NMA) and show that such a model has the same computational power of the classical deterministic Moore automaton. We consider also the problem of constructing the minimal deterministic Moore automaton equivalent to a given NMA. In this paper we propose an algorithm that is a variant of Brzozowski’s algorithm in the sense that it is essentially structured as reverse operation and subset construction performed twice.
10;Marinella Sciortino;Giusi Castiglione, Antonio Restivo;Nondeterministic Moore Automata and Brzozowski’s Algorithm;Moore automata represent a model that has many applications. In this paper we define a notion of coherent nondeterministic Moore automaton (NMA) and show that such a model has the same computational power of the classical deterministic Moore automaton. We consider also the problem of constructing the minimal deterministic Moore automaton equivalent to a given NMA. In this paper we propose an algorithm that is a variant of Brzozowski’s algorithm in the sense that it is essentially structured as reverse operation and subset construction performed twice.
10;Supaporn Chairungsee;Maxime Crochemore;Building Phylogeny with Minimal Absent Words;An absent word in a sequence is a segment that does not occur in the given sequence. It is a minimal absent word if all its proper factors occur in the given sequence.
10;Maxime Crochemore;Supaporn Chairungsee;Building Phylogeny with Minimal Absent Words;An absent word in a sequence is a segment that does not occur in the given sequence. It is a minimal absent word if all its proper factors occur in the given sequence.
10;Chih-Hong Cheng;Barbara Jobstmann, Christian Buckl, Alois Knoll;On the Hardness of Priority Synthesis;We study properties of priority synthesis [2], an automatic method to ensure desired safety properties in component-based systems using priorities. Priorities are a powerful concept to orchestrate components [3], e.g., the BIP framework [1] for designing and modeling embedded and autonomous systems is based on this concept.
10;Barbara Jobstmann;Chih-Hong Cheng, Christian Buckl, Alois Knoll;On the Hardness of Priority Synthesis;We study properties of priority synthesis [2], an automatic method to ensure desired safety properties in component-based systems using priorities. Priorities are a powerful concept to orchestrate components [3], e.g., the BIP framework [1] for designing and modeling embedded and autonomous systems is based on this concept.
10;Christian Buckl;Chih-Hong Cheng, Barbara Jobstmann, Alois Knoll;On the Hardness of Priority Synthesis;We study properties of priority synthesis [2], an automatic method to ensure desired safety properties in component-based systems using priorities. Priorities are a powerful concept to orchestrate components [3], e.g., the BIP framework [1] for designing and modeling embedded and autonomous systems is based on this concept.
10;Alois Knoll;Chih-Hong Cheng, Barbara Jobstmann, Christian Buckl;On the Hardness of Priority Synthesis;We study properties of priority synthesis [2], an automatic method to ensure desired safety properties in component-based systems using priorities. Priorities are a powerful concept to orchestrate components [3], e.g., the BIP framework [1] for designing and modeling embedded and autonomous systems is based on this concept.
10;Jan Daciuk;Dawid Weiss;Smaller Representation of Finite State Automata;This paper is a follow-up to Jan Daciuk’s experiments on space-efficient finite state automata representation that can be used directly for traversals in main memory [4]. We investigate several techniques of reducing the memory footprint of minimal automata, mainly exploiting the fact that transition labels and transition pointer offset values are not evenly distributed and so are suitable for compression. We achieve a size gain of around 20–30% compared to the original representation given in [4]. This result is comparable to the state-of-the-art dictionary compression techniques like the LZ-trie [10] method, but remains memory and CPU efficient during construction.
10;Dawid Weiss;Jan Daciuk;Smaller Representation of Finite State Automata;This paper is a follow-up to Jan Daciuk’s experiments on space-efficient finite state automata representation that can be used directly for traversals in main memory [4]. We investigate several techniques of reducing the memory footprint of minimal automata, mainly exploiting the fact that transition labels and transition pointer offset values are not evenly distributed and so are suitable for compression. We achieve a size gain of around 20–30% compared to the original representation given in [4]. This result is comparable to the state-of-the-art dictionary compression techniques like the LZ-trie [10] method, but remains memory and CPU efficient during construction.
10;Ingo Felscher;Wolfgang Thomas;Compositional Failure Detection in Structured Transition Systems;In model-checking, systems are often given as products. We propose an approach that is built on a preprocessing of specifications in terms of appropriate automata. This allows to incorporate information about the local behaviour and synchronization of the system components into the specification. We develop a framework of (partially) synchronized automaton products and a format of corresponding specification automata that allows for a compositional failure detection of linear regular properties (either for finite or for infinite behaviour). As a result we obtain an algorithm which separates the local and the non-local segments of system runs, resulting in improved complexity bounds in typical specifications.
10;Wolfgang Thomas;Ingo Felscher;Compositional Failure Detection in Structured Transition Systems;In model-checking, systems are often given as products. We propose an approach that is built on a preprocessing of specifications in terms of appropriate automata. This allows to incorporate information about the local behaviour and synchronization of the system components into the specification. We develop a framework of (partially) synchronized automaton products and a format of corresponding specification automata that allows for a compositional failure detection of linear regular properties (either for finite or for infinite behaviour). As a result we obtain an algorithm which separates the local and the non-local segments of system runs, resulting in improved complexity bounds in typical specifications.
10;Paweł Gawrychowski;;Chrobak Normal Form Revisited, with Applications;It is well known that any nondeterministic finite automata over a unary alphabet can be represented in a certain normal form called the Chrobak normal form [1]. We present a very simple conversion procedure working in \(\mathcal{O}(n^3)\) time. Then we extend the algorithm to improve two trade-offs concerning conversions between different representations of unary regular languages. Given an n-state NFA, we are able to find a regular expression of size \(\mathcal{O}(\frac{n^2}{\log^2 n})\) describing the same language (which improves the previously known \(\mathcal{O}(n^2)\) size bound [8]) and a context-free grammar in Chomsky normal form with \(\mathcal{O}(\sqrt{n\log n})\) nonterminals (which improves the previously known \(\mathcal{O}(n^{2/3})\) bound [3]).
10;Yo-Sub Han;Sang-Ki Ko;A Cellular Automaton Model for Car Traffic with a Form-One-Lane Rule;We propose a cellular automaton model that simulates a traffic flow with a junction. We include a ‘form-one-lane’ rule that decides which car moves ahead when two cars on two different lanes are in front of a junction. We present a fundamental diagram of the proposed model and car distribution examples. We also demonstrate that the proposed model is useful for predicting the real-world traffic flow with a junction.
10;Sang-Ki Ko;Yo-Sub Han;A Cellular Automaton Model for Car Traffic with a Form-One-Lane Rule;We propose a cellular automaton model that simulates a traffic flow with a junction. We include a ‘form-one-lane’ rule that decides which car moves ahead when two cars on two different lanes are in front of a junction. We present a fundamental diagram of the proposed model and car distribution examples. We also demonstrate that the proposed model is useful for predicting the real-world traffic flow with a junction.
10;Pierre-Cyrille Héam;Vincent Hugot, Olga Kouchnarenko;Loops and Overloops for Tree Walking Automata;Tree Walking Automata (TWA) have lately received renewed interest thanks to their tight connection to XML. This paper introduces the notion of tree overloops, which is closely related to tree loops, and investigates the use of both for the following common operations on TWA: testing membership, transformation into a Bottom-Up Tree Automaton (BUTA), and testing emptiness. Notably, we argue that transformation into a BUTA is slightly less straightforward than was assumed, show that using overloops yields much smaller BUTA in the deterministic case, and provide a polynomial over-approximation of this construction which detects emptiness with surprising accuracy against randomly generated TWA.
10;Vincent Hugot;Pierre-Cyrille Héam, Olga Kouchnarenko;Loops and Overloops for Tree Walking Automata;Tree Walking Automata (TWA) have lately received renewed interest thanks to their tight connection to XML. This paper introduces the notion of tree overloops, which is closely related to tree loops, and investigates the use of both for the following common operations on TWA: testing membership, transformation into a Bottom-Up Tree Automaton (BUTA), and testing emptiness. Notably, we argue that transformation into a BUTA is slightly less straightforward than was assumed, show that using overloops yields much smaller BUTA in the deterministic case, and provide a polynomial over-approximation of this construction which detects emptiness with surprising accuracy against randomly generated TWA.
10;Olga Kouchnarenko;Pierre-Cyrille Héam, Vincent Hugot;Loops and Overloops for Tree Walking Automata;Tree Walking Automata (TWA) have lately received renewed interest thanks to their tight connection to XML. This paper introduces the notion of tree overloops, which is closely related to tree loops, and investigates the use of both for the following common operations on TWA: testing membership, transformation into a Bottom-Up Tree Automaton (BUTA), and testing emptiness. Notably, we argue that transformation into a BUTA is slightly less straightforward than was assumed, show that using overloops yields much smaller BUTA in the deterministic case, and provide a polynomial over-approximation of this construction which detects emptiness with surprising accuracy against randomly generated TWA.
10;Markus Holzer;Martin Kutrib, Katja Meckel;Nondeterministic State Complexity of Star-Free Languages;We investigate the nondeterministic state complexity of several operations on finite automata accepting star-free languages. It turns out that in most cases exactly the same tight bounds as for general regular languages are reached. This nicely complements the results recently obtained in [8] for the operation problem of star-free languages accepted by deterministic finite automata.
10;Martin Kutrib;Markus Holzer, Katja Meckel;Nondeterministic State Complexity of Star-Free Languages;We investigate the nondeterministic state complexity of several operations on finite automata accepting star-free languages. It turns out that in most cases exactly the same tight bounds as for general regular languages are reached. This nicely complements the results recently obtained in [8] for the operation problem of star-free languages accepted by deterministic finite automata.
10;Katja Meckel;Markus Holzer, Martin Kutrib;Nondeterministic State Complexity of Star-Free Languages;We investigate the nondeterministic state complexity of several operations on finite automata accepting star-free languages. It turns out that in most cases exactly the same tight bounds as for general regular languages are reached. This nicely complements the results recently obtained in [8] for the operation problem of star-free languages accepted by deterministic finite automata.
10;Oscar H. Ibarra;;On the Containment and Equivalence Problems for GSMs, Transducers, and Linear CFGs;We explore the boundaries between decidability and undecidability of the containment and equivalence problems for restricted classes of nondeterministic generalized sequential machines (NGSMs), nondeterministic finite transducers (NFTs), nondeterministic pushdown transducers (NPDTs), and linear context-free grammars (LCFGs). We believe that our results are the sharpest known to date concerning these devices.
10;Artur Jeż;Andreas Maletti;Computing All ℓ-Cover Automata Fast;Given a language L and a number ℓ, an ℓ-cover automaton for L is a DFA M such that its language coincides with L on all words of length at most ℓ. It is known that an equivalent minimal ℓ-cover automaton can be constructed in time \(\mathcal{O}(n \log n)\), where n is the number of states of M. This is achieved by a clever and sophisticated variant of Hopcroft’s algorithm, which computes the ℓ-similarity inside the main algorithm. This contribution presents an alternative simple algorithm with running time \(\mathcal{O}(n \log n)\), in which the computation is split into three phases. First, a compact representation of the gap table is created. Second, this representation is enriched with information about the length of a shortest word leading to the states. These two steps are independent of the parameter ℓ. Third, the ℓ-similarity is extracted by simple comparisons against ℓ. In particular, this approach allows the calculation of all the sizes of minimal ℓ-cover automata (for all valid ℓ) in the same time bound.
10;Andreas Maletti;Artur Jeż;Computing All ℓ-Cover Automata Fast;Given a language L and a number ℓ, an ℓ-cover automaton for L is a DFA M such that its language coincides with L on all words of length at most ℓ. It is known that an equivalent minimal ℓ-cover automaton can be constructed in time \(\mathcal{O}(n \log n)\), where n is the number of states of M. This is achieved by a clever and sophisticated variant of Hopcroft’s algorithm, which computes the ℓ-similarity inside the main algorithm. This contribution presents an alternative simple algorithm with running time \(\mathcal{O}(n \log n)\), in which the computation is split into three phases. First, a compact representation of the gap table is created. Second, this representation is enriched with information about the length of a shortest word leading to the states. These two steps are independent of the parameter ℓ. Third, the ℓ-similarity is extracted by simple comparisons against ℓ. In particular, this approach allows the calculation of all the sizes of minimal ℓ-cover automata (for all valid ℓ) in the same time bound.
11;Nataša Jonoska;;Using Automata to Describe Self-Assembled Nanostructures;There is an increased necessity for mathematical study of self-assembly of various phenomena ranging from nano-scale structures, material design, crystals, biomolecular cages such as viral capsids and for computing. We show an algebraic model for describing and characterizing nanostructures built by a set of molecular building blocks. This algebraic approach connects the classifcal view of crystal dissection with a more modern system based on algebraic automata theory.
11;Karen Rudie;;A Summary of Some Discrete-Event System Control Problems;A summary of the area of control of discrete-event systems is given. In this research area, automata and formal language theory is used as a tool to model physical problems that arise in technological and industrial systems. The key ingredients to discrete-event control problems are a process that can be modeled by an automaton, events in that process that cannot be disabled or prevented from occurring, and a controlling agent that manipulates the events that can be disabled to guarantee that the process under control either generates all the strings in some prescribed language or as many strings as possible in some prescribed language. When multiple controlling agents act on a process, decentralized control problems arise. In decentralized discrete-event systems, it is presumed that the agents effecting control cannot each see all event occurrences. Partial observation leads to some problems that cannot be solved in polynomial time and some others that are not even decidable.
11;Cyril Allauzen;Corinna Cortes, Mehryar Mohri;Large-Scale Training of SVMs with Automata Kernels;This paper presents a novel application of automata algorithms to machine learning. It introduces the first optimization solution for support vector machines used with sequence kernels that is purely based on weighted automata and transducer algorithms, without requiring any specific solver. The algorithms presented apply to a family of kernels covering all those commonly used in text and speech processing or computational biology. We show that these algorithms have significantly better computational complexity than previous ones and report the results of large-scale experiments demonstrating a dramatic reduction of the training time, typically by several orders of magnitude.
11;Corinna Cortes;Cyril Allauzen, Mehryar Mohri;Large-Scale Training of SVMs with Automata Kernels;This paper presents a novel application of automata algorithms to machine learning. It introduces the first optimization solution for support vector machines used with sequence kernels that is purely based on weighted automata and transducer algorithms, without requiring any specific solver. The algorithms presented apply to a family of kernels covering all those commonly used in text and speech processing or computational biology. We show that these algorithms have significantly better computational complexity than previous ones and report the results of large-scale experiments demonstrating a dramatic reduction of the training time, typically by several orders of magnitude.
11;Mehryar Mohri;Cyril Allauzen, Corinna Cortes;Large-Scale Training of SVMs with Automata Kernels;This paper presents a novel application of automata algorithms to machine learning. It introduces the first optimization solution for support vector machines used with sequence kernels that is purely based on weighted automata and transducer algorithms, without requiring any specific solver. The algorithms presented apply to a family of kernels covering all those commonly used in text and speech processing or computational biology. We show that these algorithms have significantly better computational complexity than previous ones and report the results of large-scale experiments demonstrating a dramatic reduction of the training time, typically by several orders of magnitude.
11;Cyril Allauzen;Michael Riley, Johan Schalkwyk;Filters for Efficient Composition of Weighted Finite-State Transducers;This paper describes a weighted finite-state transducer composition algorithm that generalizes the concept of the composition filter and presents various filters that process epsilon transitions, look-ahead along paths, and push forward labels along epsilon paths. These filters, either individually or in combination, make it possible to compose some transducers much more efficiently in time and space than otherwise possible. We present examples of this drawn, in part, from demanding speech-processing applications. The generalized composition algorithm and many of these filters have been included in OpenFst, an open-source weighted transducer library.
11;Michael Riley;Cyril Allauzen, Johan Schalkwyk;Filters for Efficient Composition of Weighted Finite-State Transducers;This paper describes a weighted finite-state transducer composition algorithm that generalizes the concept of the composition filter and presents various filters that process epsilon transitions, look-ahead along paths, and push forward labels along epsilon paths. These filters, either individually or in combination, make it possible to compose some transducers much more efficiently in time and space than otherwise possible. We present examples of this drawn, in part, from demanding speech-processing applications. The generalized composition algorithm and many of these filters have been included in OpenFst, an open-source weighted transducer library.
11;Johan Schalkwyk;Cyril Allauzen, Michael Riley;Filters for Efficient Composition of Weighted Finite-State Transducers;This paper describes a weighted finite-state transducer composition algorithm that generalizes the concept of the composition filter and presents various filters that process epsilon transitions, look-ahead along paths, and push forward labels along epsilon paths. These filters, either individually or in combination, make it possible to compose some transducers much more efficiently in time and space than otherwise possible. We present examples of this drawn, in part, from demanding speech-processing applications. The generalized composition algorithm and many of these filters have been included in OpenFst, an open-source weighted transducer library.
11;Marco Almeida;Nelma Moreira, Rogério Reis;Incremental DFA Minimisation;We present a new incremental algorithm for minimising deterministic finite automata. It runs in quadratic time for any practical application and may be halted at any point, returning a partially minimised automaton. Hence, the algorithm may be applied to a given automaton at the same time as it is processing a string for acceptance. We also include some experimental comparative results.
11;Nelma Moreira;Marco Almeida, Rogério Reis;Incremental DFA Minimisation;We present a new incremental algorithm for minimising deterministic finite automata. It runs in quadratic time for any practical application and may be halted at any point, returning a partially minimised automaton. Hence, the algorithm may be applied to a given automaton at the same time as it is processing a string for acceptance. We also include some experimental comparative results.
11;Rogério Reis;Marco Almeida, Nelma Moreira;Incremental DFA Minimisation;We present a new incremental algorithm for minimising deterministic finite automata. It runs in quadratic time for any practical application and may be halted at any point, returning a partially minimised automaton. Hence, the algorithm may be applied to a given automaton at the same time as it is processing a string for acceptance. We also include some experimental comparative results.
11;Jan Antoš;Bořivoj Melichar;Finite Automata for Generalized Approach to Backward Pattern Matching;We generalized the DAWG backward pattern matching approach to be able to solve a broad range of pattern matching problems. We use a definition of a class of problems. We describe a finite automaton for the basic pattern matching problem of finding an exact occurrence of one string in a text. We propose a mechanism to use simple operations over finite automata in a systematic approach to derive automata for solving problems from a defined class, such as approximate matching, regular expression matching, sequence matching, matching of set of patterns, etc. and their combinations. The benefit of this approach is the ability to quickly derive solutions for newly formulated pattern matching problems.
11;Bořivoj Melichar;Jan Antoš;Finite Automata for Generalized Approach to Backward Pattern Matching;We generalized the DAWG backward pattern matching approach to be able to solve a broad range of pattern matching problems. We use a definition of a class of problems. We describe a finite automaton for the basic pattern matching problem of finding an exact occurrence of one string in a text. We propose a mechanism to use simple operations over finite automata in a systematic approach to derive automata for solving problems from a defined class, such as approximate matching, regular expression matching, sequence matching, matching of set of patterns, etc. and their combinations. The benefit of this approach is the ability to quickly derive solutions for newly formulated pattern matching problems.
11;José Bacelar Almeida;Nelma Moreira, David Pereira, Simão Melo de Sousa;Partial Derivative Automata Formalized in Coq ;In this paper we present a computer assisted proof of the correctness of a partial derivative automata construction from a regular expression within the Coq proof assistant. This proof is part of a formalization of Kleene algebra and regular languages in Coq towards their usage in program certification.
11;Nelma Moreira;José Bacelar Almeida, David Pereira, Simão Melo de Sousa;Partial Derivative Automata Formalized in Coq ;In this paper we present a computer assisted proof of the correctness of a partial derivative automata construction from a regular expression within the Coq proof assistant. This proof is part of a formalization of Kleene algebra and regular languages in Coq towards their usage in program certification.
11;David Pereira;José Bacelar Almeida, Nelma Moreira, Simão Melo de Sousa;Partial Derivative Automata Formalized in Coq ;In this paper we present a computer assisted proof of the correctness of a partial derivative automata construction from a regular expression within the Coq proof assistant. This proof is part of a formalization of Kleene algebra and regular languages in Coq towards their usage in program certification.
11;Simão Melo de Sousa;José Bacelar Almeida, Nelma Moreira, David Pereira;Partial Derivative Automata Formalized in Coq ;In this paper we present a computer assisted proof of the correctness of a partial derivative automata construction from a regular expression within the Coq proof assistant. This proof is part of a formalization of Kleene algebra and regular languages in Coq towards their usage in program certification.
11;Jean-Marc Champarnaud;Jean-Philippe Dubernard, Hadrien Jeanne;Regular Geometrical Languages and Tiling the Plane;We show that if a binary language L is regular, prolongable and geometrical, then it can generate, on certain assumptions, a p1 type tiling of a part of ℕ2. We also show that the sequence of states that appear along a horizontal line in such a tiling only depends on the shape of the tiling sub-figure and is somehow periodic.
11;Jean-Philippe Dubernard;Jean-Marc Champarnaud, Hadrien Jeanne;Regular Geometrical Languages and Tiling the Plane;We show that if a binary language L is regular, prolongable and geometrical, then it can generate, on certain assumptions, a p1 type tiling of a part of ℕ2. We also show that the sequence of states that appear along a horizontal line in such a tiling only depends on the shape of the tiling sub-figure and is somehow periodic.
11;Hadrien Jeanne;Jean-Marc Champarnaud, Jean-Philippe Dubernard;Regular Geometrical Languages and Tiling the Plane;We show that if a binary language L is regular, prolongable and geometrical, then it can generate, on certain assumptions, a p1 type tiling of a part of ℕ2. We also show that the sequence of states that appear along a horizontal line in such a tiling only depends on the shape of the tiling sub-figure and is somehow periodic.
11;Krzysztof Chmiel;Adam Roman;COMPAS - A Computing Package for Synchronization;In this paper we describe COMPAS - the open-source computing package, dedicated to the computations on synchronizing automata. COMPAS design is based on a generic programming paradigm. This makes the package very powerful because of its flexibility and extensibility. The paper describes shortly the package architecture and its main algorithms and some examples of use. COMPAS allows to easily operate on synchronizing automata, verifying new synchronizing algorithms etc. To the best of our knowledge, this is the first such flexible, extensible and open-source package for synchronization.
11;Adam Roman;Krzysztof Chmiel;COMPAS - A Computing Package for Synchronization;In this paper we describe COMPAS - the open-source computing package, dedicated to the computations on synchronizing automata. COMPAS design is based on a generic programming paradigm. This makes the package very powerful because of its flexibility and extensibility. The paper describes shortly the package architecture and its main algorithms and some examples of use. COMPAS allows to easily operate on synchronizing automata, verifying new synchronizing algorithms etc. To the best of our knowledge, this is the first such flexible, extensible and open-source package for synchronization.
11;Alessandro Cimatti;Sergio Mover, Marco Roveri, Stefano Tonetta;From Sequential Extended Regular Expressions to NFA with Symbolic Labels;Practical property specification languages such as the IEEE standard PSL use at their core Sequential Extended Regular Expressions (SERE). In order to enable the reuse of traditional verification techniques, it is necessary to translate SEREs into automata. SERE are regular expressions built over alphabets resulting from the state variables of the design under analysis. Thus, a traditional approach to generate the automaton would suffer from the fact that the size of the alphabet is exponential in the number of symbols in the design.
11;Sergio Mover;Alessandro Cimatti, Marco Roveri, Stefano Tonetta;From Sequential Extended Regular Expressions to NFA with Symbolic Labels;Practical property specification languages such as the IEEE standard PSL use at their core Sequential Extended Regular Expressions (SERE). In order to enable the reuse of traditional verification techniques, it is necessary to translate SEREs into automata. SERE are regular expressions built over alphabets resulting from the state variables of the design under analysis. Thus, a traditional approach to generate the automaton would suffer from the fact that the size of the alphabet is exponential in the number of symbols in the design.
11;Marco Roveri;Alessandro Cimatti, Sergio Mover, Stefano Tonetta;From Sequential Extended Regular Expressions to NFA with Symbolic Labels;Practical property specification languages such as the IEEE standard PSL use at their core Sequential Extended Regular Expressions (SERE). In order to enable the reuse of traditional verification techniques, it is necessary to translate SEREs into automata. SERE are regular expressions built over alphabets resulting from the state variables of the design under analysis. Thus, a traditional approach to generate the automaton would suffer from the fact that the size of the alphabet is exponential in the number of symbols in the design.
11;Stefano Tonetta;Alessandro Cimatti, Sergio Mover, Marco Roveri;From Sequential Extended Regular Expressions to NFA with Symbolic Labels;Practical property specification languages such as the IEEE standard PSL use at their core Sequential Extended Regular Expressions (SERE). In order to enable the reuse of traditional verification techniques, it is necessary to translate SEREs into automata. SERE are regular expressions built over alphabets resulting from the state variables of the design under analysis. Thus, a traditional approach to generate the automaton would suffer from the fact that the size of the alphabet is exponential in the number of symbols in the design.
11;Bo Cui;Yuan Gao, Lila Kari, Sheng Yu;State Complexity of Catenation Combined with Union and Intersection;In this paper, we study the state complexities of two particular combinations of operations: catenation combined with union and catenation combined with intersection. We show that the state complexity of the former combined operation is considerably less than the mathematical composition of the state complexities of catenation and union, while the state complexity of the latter one is equal to the mathematical composition of the state complexities of catenation and intersection.
11;Yuan Gao;Bo Cui, Lila Kari, Sheng Yu;State Complexity of Catenation Combined with Union and Intersection;In this paper, we study the state complexities of two particular combinations of operations: catenation combined with union and catenation combined with intersection. We show that the state complexity of the former combined operation is considerably less than the mathematical composition of the state complexities of catenation and union, while the state complexity of the latter one is equal to the mathematical composition of the state complexities of catenation and intersection.
11;Lila Kari;Bo Cui, Yuan Gao, Sheng Yu;State Complexity of Catenation Combined with Union and Intersection;In this paper, we study the state complexities of two particular combinations of operations: catenation combined with union and catenation combined with intersection. We show that the state complexity of the former combined operation is considerably less than the mathematical composition of the state complexities of catenation and union, while the state complexity of the latter one is equal to the mathematical composition of the state complexities of catenation and intersection.
11;Sheng Yu;Bo Cui, Yuan Gao, Lila Kari;State Complexity of Catenation Combined with Union and Intersection;In this paper, we study the state complexities of two particular combinations of operations: catenation combined with union and catenation combined with intersection. We show that the state complexity of the former combined operation is considerably less than the mathematical composition of the state complexities of catenation and union, while the state complexity of the latter one is equal to the mathematical composition of the state complexities of catenation and intersection.
11;Volker Diekert;Steffen Kopecki;Complexity Results and the Growths of Hairpin Completions of Regular Languages (Extended Abstract);The hairpin completion is a natural operation on formal languages which has been inspired by molecular phenomena in biology and by DNA-computing. In 2009 we presented in [6] a (polynomial time) decision algorithm to decide regularity of the hairpin completion. In this paper we provide four new results: 1.) We show that the decision problem is NL-complete. 2.) There is a polynomial time decision algorithm which runs in time \(\mathcal{O}(n^{8})\), this improves [6], which provided \(\mathcal{O}(n^{20})\). 3.) For the one-sided case (which is closer to DNA computing) the time is \(\mathcal{O}(n^{2})\), only. 4.) The hairpin completion is unambiguous linear context-free. This result allows to compute the growth (generating function) of the hairpin completion and to compare it with the growth of the underlying regular language.
11;Steffen Kopecki;Volker Diekert;Complexity Results and the Growths of Hairpin Completions of Regular Languages (Extended Abstract);The hairpin completion is a natural operation on formal languages which has been inspired by molecular phenomena in biology and by DNA-computing. In 2009 we presented in [6] a (polynomial time) decision algorithm to decide regularity of the hairpin completion. In this paper we provide four new results: 1.) We show that the decision problem is NL-complete. 2.) There is a polynomial time decision algorithm which runs in time \(\mathcal{O}(n^{8})\), this improves [6], which provided \(\mathcal{O}(n^{20})\). 3.) For the one-sided case (which is closer to DNA computing) the time is \(\mathcal{O}(n^{2})\), only. 4.) The hairpin completion is unambiguous linear context-free. This result allows to compute the growth (generating function) of the hairpin completion and to compare it with the growth of the underlying regular language.
11;Attila Egri-Nagy;Chrystopher L. Nehaniv;On Straight Words and Minimal Permutators in Finite Transformation Semigroups;Motivated by issues arising in computer science, we investigate the loop-free paths from the identity transformation and corresponding straight words in the Cayley graph of a finite transformation semigroup with a fixed generator set. Of special interest are words that permute a given subset of the state set. Certain such words, called minimal permutators, are shown to comprise a code, and the straight ones comprise a finite code. Thus, words that permute a given subset are uniquely factorizable as products of the subset’s minimal permutators, and these can be further reduced to straight minimal permutators. This leads to insight into structure of local pools of reversibility in transformation semigroups in terms of the set of words permuting a given subset. These findings can be exploited in practical calculations for hierarchical decompositions of finite automata. As an example we consider groups arising in biological systems.
11;Chrystopher L. Nehaniv;Attila Egri-Nagy;On Straight Words and Minimal Permutators in Finite Transformation Semigroups;Motivated by issues arising in computer science, we investigate the loop-free paths from the identity transformation and corresponding straight words in the Cayley graph of a finite transformation semigroup with a fixed generator set. Of special interest are words that permute a given subset of the state set. Certain such words, called minimal permutators, are shown to comprise a code, and the straight ones comprise a finite code. Thus, words that permute a given subset are uniquely factorizable as products of the subset’s minimal permutators, and these can be further reduced to straight minimal permutators. This leads to insight into structure of local pools of reversibility in transformation semigroups in terms of the set of words permuting a given subset. These findings can be exploited in practical calculations for hierarchical decompositions of finite automata. As an example we consider groups arising in biological systems.
11;Chiara Epifanio;Christiane Frougny, Alessandra Gabriele, Filippo Mignosi, Jeffrey Shallit;On Lazy Representations and Sturmian Graphs;In this paper we establish a strong relationship between the set of lazy representations and the set of paths in a Sturmian graph associated with a real number α. We prove that for any non-negative integer i the unique path weighted i in the Sturmian graph associated with α represents the lazy representation of i in the Ostrowski numeration system associated with α. Moreover, we provide several properties of the representations of the natural integers in this numeration system.
11;Christiane Frougny;Chiara Epifanio, Alessandra Gabriele, Filippo Mignosi, Jeffrey Shallit;On Lazy Representations and Sturmian Graphs;In this paper we establish a strong relationship between the set of lazy representations and the set of paths in a Sturmian graph associated with a real number α. We prove that for any non-negative integer i the unique path weighted i in the Sturmian graph associated with α represents the lazy representation of i in the Ostrowski numeration system associated with α. Moreover, we provide several properties of the representations of the natural integers in this numeration system.
11;Alessandra Gabriele;Chiara Epifanio, Christiane Frougny, Filippo Mignosi, Jeffrey Shallit;On Lazy Representations and Sturmian Graphs;In this paper we establish a strong relationship between the set of lazy representations and the set of paths in a Sturmian graph associated with a real number α. We prove that for any non-negative integer i the unique path weighted i in the Sturmian graph associated with α represents the lazy representation of i in the Ostrowski numeration system associated with α. Moreover, we provide several properties of the representations of the natural integers in this numeration system.
11;Filippo Mignosi;Chiara Epifanio, Christiane Frougny, Alessandra Gabriele, Jeffrey Shallit;On Lazy Representations and Sturmian Graphs;In this paper we establish a strong relationship between the set of lazy representations and the set of paths in a Sturmian graph associated with a real number α. We prove that for any non-negative integer i the unique path weighted i in the Sturmian graph associated with α represents the lazy representation of i in the Ostrowski numeration system associated with α. Moreover, we provide several properties of the representations of the natural integers in this numeration system.
11;Jeffrey Shallit;Chiara Epifanio, Christiane Frougny, Alessandra Gabriele, Filippo Mignosi;On Lazy Representations and Sturmian Graphs;In this paper we establish a strong relationship between the set of lazy representations and the set of paths in a Sturmian graph associated with a real number α. We prove that for any non-negative integer i the unique path weighted i in the Sturmian graph associated with α represents the lazy representation of i in the Ostrowski numeration system associated with α. Moreover, we provide several properties of the representations of the natural integers in this numeration system.
11;Wit Foryś;Piotr Oprocha, Slawomir Bakalarski;Symbolic Dynamics, Flower Automata and Infinite Traces;Considering a finite alphabet as a set of allowed instructions, we can identify finite words with basic actions or programs. Hence infinite paths on a flower automaton can represent order in which these programs are executed and a flower shift related with it represents list of instructions to be executed at some mid-point of the computation.
11;Piotr Oprocha;Wit Foryś, Slawomir Bakalarski;Symbolic Dynamics, Flower Automata and Infinite Traces;Considering a finite alphabet as a set of allowed instructions, we can identify finite words with basic actions or programs. Hence infinite paths on a flower automaton can represent order in which these programs are executed and a flower shift related with it represents list of instructions to be executed at some mid-point of the computation.
11;Slawomir Bakalarski;Wit Foryś, Piotr Oprocha;Symbolic Dynamics, Flower Automata and Infinite Traces;Considering a finite alphabet as a set of allowed instructions, we can identify finite words with basic actions or programs. Hence infinite paths on a flower automaton can represent order in which these programs are executed and a flower shift related with it represents list of instructions to be executed at some mid-point of the computation.
11;Radu Grosu;;The Cayley-Hamilton Theorem for Noncommutative Semirings;The Cayley-Hamilton theorem (CHT) is a classic result in linear algebra over fields which states that a matrix satisfies its own characteristic polynomial. CHT has been extended from fields to commutative semirings by Rutherford in 1964. However, to the best of our knowledge, no result is known for noncommutative semirings. This is a serious limitation, as the class of regular languages, with finite automata as their recognizers, is a noncommutative idempotent semiring. In this paper we extend the CHT to noncommutative semirings. We also provide a simpler version of CHT for noncommutative idempotent semirings.
11;Michael Gerbush;Brent Heeringa;Approximating Minimum Reset Sequences;We consider the problem of finding minimum reset sequences in synchronizing automata. The well-known Černý conjecture states that every n-state synchronizing automaton has a reset sequence with length at most (n − 1)2. While this conjecture gives an upper bound on the length of every reset sequence, it does not directly address the problem of finding the shortest reset sequence. We call this the minimum reset sequence (mrs) problem. We give an O(kmnk + n4/k)-time \(\lceil \frac{n-1}{k-1} \rceil\)-approximation for the mrs problem for any k ≥ 2. We also show that our analysis is tight. When k = 2 our algorithm reduces to Eppstein’s algorithm and yields an (n − 1)-approximation. When k = n our algorithm is the familiar exponential-time, exact algorithm. We define a non-trivial class of mrs which we call stack cover. We show that stack cover naturally generalizes two classic optimization problems: minset cover and shortest common supersequence. Both these problems are known to be hard to approximate, although at present, set cover has a slightly stronger lower bound. In particular, it is NP-hard to approximate set cover to within a factor of c ·logn for some c &gt. 0. Thus, the minimum reset sequence problem is as least as hard to approximate as set cover. This improves the previous best lower bound which showed that it was NP-hard to approximate the mrs on binary alphabets to within any constant factor. Our result requires an alphabet of arbitrary size.
11;Brent Heeringa;Michael Gerbush;Approximating Minimum Reset Sequences;We consider the problem of finding minimum reset sequences in synchronizing automata. The well-known Černý conjecture states that every n-state synchronizing automaton has a reset sequence with length at most (n − 1)2. While this conjecture gives an upper bound on the length of every reset sequence, it does not directly address the problem of finding the shortest reset sequence. We call this the minimum reset sequence (mrs) problem. We give an O(kmnk + n4/k)-time \(\lceil \frac{n-1}{k-1} \rceil\)-approximation for the mrs problem for any k ≥ 2. We also show that our analysis is tight. When k = 2 our algorithm reduces to Eppstein’s algorithm and yields an (n − 1)-approximation. When k = n our algorithm is the familiar exponential-time, exact algorithm. We define a non-trivial class of mrs which we call stack cover. We show that stack cover naturally generalizes two classic optimization problems: minset cover and shortest common supersequence. Both these problems are known to be hard to approximate, although at present, set cover has a slightly stronger lower bound. In particular, it is NP-hard to approximate set cover to within a factor of c ·logn for some c &gt. 0. Thus, the minimum reset sequence problem is as least as hard to approximate as set cover. This improves the previous best lower bound which showed that it was NP-hard to approximate the mrs on binary alphabets to within any constant factor. Our result requires an alphabet of arbitrary size.
11;Norbert Hundeshagen;Friedrich Otto, Marcel Vollweiler;Transductions Computed by PC-Systems of Monotone Deterministic Restarting Automata;We associate a transduction (that is, a binary relation) with the characteristic language of a restarting automaton, and we prove that in this way monotone deterministic restarting automata yield a characterization of pushdown transductions. Then we study the class of transductions that are computed by parallel communicating systems (PC-systems) of monotone deterministic restarting automata. We will see that this class includes all transductions that are computable.
11;Friedrich Otto;Norbert Hundeshagen, Marcel Vollweiler;Transductions Computed by PC-Systems of Monotone Deterministic Restarting Automata;We associate a transduction (that is, a binary relation) with the characteristic language of a restarting automaton, and we prove that in this way monotone deterministic restarting automata yield a characterization of pushdown transductions. Then we study the class of transductions that are computed by parallel communicating systems (PC-systems) of monotone deterministic restarting automata. We will see that this class includes all transductions that are computable.
11;Marcel Vollweiler;Norbert Hundeshagen, Friedrich Otto;Transductions Computed by PC-Systems of Monotone Deterministic Restarting Automata;We associate a transduction (that is, a binary relation) with the characteristic language of a restarting automaton, and we prove that in this way monotone deterministic restarting automata yield a characterization of pushdown transductions. Then we study the class of transductions that are computed by parallel communicating systems (PC-systems) of monotone deterministic restarting automata. We will see that this class includes all transductions that are computable.
11;J. Howard Johnson;;Uniformizing Rational Relations for Natural Language Applications Using Weighted Determinization;Rational functions have many applications in natural language processing. Specifying them can be difficult since many of the techniques over-generalize and incorrect transformations need to be removed or avoided. Uniformization is the process of restricting a rational relation to make it single-valued while preserving its domain. One way of doing this is to use weighted determinization with an appropriate semiring to produce a subsequential transducer when this is possible. A basic algorithm using the genealogical minimum as the selection process is discussed with a motivating example.
12;Gonzalo Navarro;;Implementation and Application of Automata in String Processing;Automata have been enormously successful in matching different types of complex patterns on sequences, with applications in many areas, from text retrieval to bioinformatics, from multimedia databases to signal processing. In general terms, the process to match a complex pattern is (1) design a NFA that recognizes the pattern. (2) slightly modify it to recognize any string ending with the pattern. (3) convert it into a DFA. (4) feed it with the sequence, signaling the endpoints of a pattern occurrence each time the DFA reaches a final state. Alternatively one can omit step (2) and backtrack with the DFA on the suffix tree of the sequence, which leads to sublinear-time complex pattern matching in many relevant cases. This process, as it is well-known, has a potential problem in stage (3), because the DFA can be of exponential size. Rather than being a theoretical reservation, the problem does arise in a number of real-life situations.
12;Christoph Koch;;Applications of Automata in XML Processing;XML is at once a document format and a semistructed data model, and has become a de-facto standard for exchanging data on the Internet. XML documents can alternatively be viewed as labeled trees, and tree automata are natural mechanisms for a wide range of processing tasks on XML documents. In this talk, I survey applications of automata in XML processing with an emphasis on those directions of work that so far have had the greatest practical impact. The talk will consist of three parts. In the first, I will discuss XML validation. The standard schema formalisms for XML, Document Type Definitions and XML Schema, are regular tree grammars at their core. These official standards of the World Wide Web Consortium are well-founded in automata theory and formal language theory, and are designed to incorporate special restrictions to facilitate the creation of automata for document validation. The second part will cover XML stream processing techniques and XML publish-subscribe systems, an area in which a number of exciting automata-based systems have been built. The third and final part covers XML query processing using automata, and applications in Web information extraction.
12;Helmut Seidl;;Program Analysis through Finite Tree Automata;Dynamic Pushdown Networks (dpn’s) have recently been introduced as a convenient abstraction of systems which provide recursive procedure calls and spawning of concurrent tasks such as Java programs [1, 4-6]. We show how the executions of dpn’s can naturally be represented through ranked trees. The configuration reached by a program execution then can be read off from the sequence of leaves of this execution tree. This observation allows us to reduce decision problems such as reachability of configurations within a regular set for dpn’s to standard decision problems for finite tree automata.
12;Markus Holzer;Andreas Maletti;An nlogn Algorithm for Hyper-minimizing States in a (Minimized) Deterministic Automaton;We improve a recent result [A. Badr: Hyper-Minimization in O(n2). In Proc. CIAA, LNCS 5148, 2008] for hyper-minimized finite automata. Namely, we present an O(nlogn) algorithm that computes for a given finite deterministic automaton (dfa) an almost equivalent dfa that is as small as possible—such an automaton is called hyper-minimal. Here two finite automata are almost equivalent if and only if the symmetric difference of their languages is finite. In other words, two almost-equivalent automata disagree on acceptance on finitely many inputs. In this way, we solve an open problem stated in [A. Badr, V. Geffert, I. Shipman: Hyper-minimizing minimized deterministic finite state automata. RAIRO Theor. Inf. Appl. 43(1), 2009] and by Badr. Moreover, we show that minimization linearly reduces to hyper-minimization, which shows that the time-bound O(n logn) is optimal for hyper-minimization.
12;Andreas Maletti;Markus Holzer;An nlogn Algorithm for Hyper-minimizing States in a (Minimized) Deterministic Automaton;We improve a recent result [A. Badr: Hyper-Minimization in O(n2). In Proc. CIAA, LNCS 5148, 2008] for hyper-minimized finite automata. Namely, we present an O(nlogn) algorithm that computes for a given finite deterministic automaton (dfa) an almost equivalent dfa that is as small as possible—such an automaton is called hyper-minimal. Here two finite automata are almost equivalent if and only if the symmetric difference of their languages is finite. In other words, two almost-equivalent automata disagree on acceptance on finitely many inputs. In this way, we solve an open problem stated in [A. Badr, V. Geffert, I. Shipman: Hyper-minimizing minimized deterministic finite state automata. RAIRO Theor. Inf. Appl. 43(1), 2009] and by Badr. Moreover, we show that minimization linearly reduces to hyper-minimization, which shows that the time-bound O(n logn) is optimal for hyper-minimization.
12;Giusi Castiglione;Antonio Restivo, Marinella Sciortino;On Extremal Cases of Hopcroft’s Algorithm;In this paper we consider the problem of minimization of deterministic finite automata (DFA) with reference to Hopcroft’s algorithm. Hopcroft’s algorithm has several degrees of freedom, so there can exist different sequences of refinements of the set of the states that lead to the final partition. We find an infinite family of binary automata for which such a process is unique. Some recent papers (cf. [3,7,1]) have been devoted to find families of automata for which Hopcroft’s algorithm has its worst execution time. They are unary automata associated to circular words. However, automata minimization can be achieved also in linear time when the alphabet has only one letter (cf. [14]), so in this paper we face the tightness of the algorithm when the alphabet contains more than one letter. In particular we define an infinite family of binary automata representing the worst case of Hopcroft’s algorithm. They are automata associated to particular trees and we deepen the connection between the refinement process of Hopcroft’s algorithm and the combinatorial properties of such trees.
12;Antonio Restivo;Giusi Castiglione, Marinella Sciortino;On Extremal Cases of Hopcroft’s Algorithm;In this paper we consider the problem of minimization of deterministic finite automata (DFA) with reference to Hopcroft’s algorithm. Hopcroft’s algorithm has several degrees of freedom, so there can exist different sequences of refinements of the set of the states that lead to the final partition. We find an infinite family of binary automata for which such a process is unique. Some recent papers (cf. [3,7,1]) have been devoted to find families of automata for which Hopcroft’s algorithm has its worst execution time. They are unary automata associated to circular words. However, automata minimization can be achieved also in linear time when the alphabet has only one letter (cf. [14]), so in this paper we face the tightness of the algorithm when the alphabet contains more than one letter. In particular we define an infinite family of binary automata representing the worst case of Hopcroft’s algorithm. They are automata associated to particular trees and we deepen the connection between the refinement process of Hopcroft’s algorithm and the combinatorial properties of such trees.
12;Marinella Sciortino;Giusi Castiglione, Antonio Restivo;On Extremal Cases of Hopcroft’s Algorithm;In this paper we consider the problem of minimization of deterministic finite automata (DFA) with reference to Hopcroft’s algorithm. Hopcroft’s algorithm has several degrees of freedom, so there can exist different sequences of refinements of the set of the states that lead to the final partition. We find an infinite family of binary automata for which such a process is unique. Some recent papers (cf. [3,7,1]) have been devoted to find families of automata for which Hopcroft’s algorithm has its worst execution time. They are unary automata associated to circular words. However, automata minimization can be achieved also in linear time when the alphabet has only one letter (cf. [14]), so in this paper we face the tightness of the algorithm when the alphabet contains more than one letter. In particular we define an infinite family of binary automata representing the worst case of Hopcroft’s algorithm. They are automata associated to particular trees and we deepen the connection between the refinement process of Hopcroft’s algorithm and the combinatorial properties of such trees.
12;Jean Vuillemin;Nicolas Gama;Compact Normal Form for Regular Languages as Xor Automata;The only presently known normal form for a regular language \({\mathcal{L}}\in{\mathcal{R}\mathrm{eg}}\) is its Minimal Deterministic Automaton \({\mathrm{MDA}}({\mathcal{L}})\). We show that a regular language is also characterized by a finite dimension \(\dim({\mathcal{L}})\), which is always smaller than the number \(|{\mathrm{MDA}}({\mathcal{L}})|\) of states, and often exponentially so. The dimension is also the minimal number of states of all Nondeterministic Xor Automaton (NXA) which accept the language. NXAs combine the advantages of deterministic automata (normal form, negation, minimization, equivalence of states, accessibility) and of nondeterministic ones (compactness, mirror language). We present an algorithmic construction of the Minimal Non Deterministic Xor Automaton \({\mathrm{MXA}}(\mathcal{L})\), in cubic time from any NXA for \({\mathcal{L}}\in{\mathcal{R}\mathrm{eg}}\). The MXA provides another normal form: \({\mathcal{L}}=\mathcal{L}^{\prime}\Leftrightarrow{\mathrm{MXA}}({\mathcal{L}})={\mathrm{MXA}}(\mathcal{L}^{\prime})\). Our algorithm establishes a missing connection between Brzozowski’s mirror-based minimization method for deterministic automata, and algorithms based on state-equivalence.
12;Nicolas Gama;Jean Vuillemin;Compact Normal Form for Regular Languages as Xor Automata;The only presently known normal form for a regular language \({\mathcal{L}}\in{\mathcal{R}\mathrm{eg}}\) is its Minimal Deterministic Automaton \({\mathrm{MDA}}({\mathcal{L}})\). We show that a regular language is also characterized by a finite dimension \(\dim({\mathcal{L}})\), which is always smaller than the number \(|{\mathrm{MDA}}({\mathcal{L}})|\) of states, and often exponentially so. The dimension is also the minimal number of states of all Nondeterministic Xor Automaton (NXA) which accept the language. NXAs combine the advantages of deterministic automata (normal form, negation, minimization, equivalence of states, accessibility) and of nondeterministic ones (compactness, mirror language). We present an algorithmic construction of the Minimal Non Deterministic Xor Automaton \({\mathrm{MXA}}(\mathcal{L})\), in cubic time from any NXA for \({\mathcal{L}}\in{\mathcal{R}\mathrm{eg}}\). The MXA provides another normal form: \({\mathcal{L}}=\mathcal{L}^{\prime}\Leftrightarrow{\mathrm{MXA}}({\mathcal{L}})={\mathrm{MXA}}(\mathcal{L}^{\prime})\). Our algorithm establishes a missing connection between Brzozowski’s mirror-based minimization method for deterministic automata, and algorithms based on state-equivalence.
12;Martin Kutrib;Andreas Malcher;Cellular Automata with Sparse Communication;We investigate cellular automata whose internal inter-cell communication is bounded. The communication is quantitatively measured by the number of uses of the links between cells. It is shown that even the weakest non-trivial device in question, that is, one-way cellular automata where each two neighboring cells may communicate constantly often only, accept rather complicated languages. We investigate the computational capacity of the devices in question and prove an infinite strict hierarchy depending on the bound on the total number of communications during a computation. Despite their sparse communication even for the weakest devices, by reduction of Hilbert’s tenth problem undecidability of several problems is derived. Finally, the question whether a given real-time one-way cellular automaton belongs to the weakest class is shown to be undecidable. This result can be adapted to answer an open question posed in [16].
12;Andreas Malcher;Martin Kutrib;Cellular Automata with Sparse Communication;We investigate cellular automata whose internal inter-cell communication is bounded. The communication is quantitatively measured by the number of uses of the links between cells. It is shown that even the weakest non-trivial device in question, that is, one-way cellular automata where each two neighboring cells may communicate constantly often only, accept rather complicated languages. We investigate the computational capacity of the devices in question and prove an infinite strict hierarchy depending on the bound on the total number of communications during a computation. Despite their sparse communication even for the weakest devices, by reduction of Hilbert’s tenth problem undecidability of several problems is derived. Finally, the question whether a given real-time one-way cellular automaton belongs to the weakest class is shown to be undecidable. This result can be adapted to answer an open question posed in [16].
12;Adam Clarridge;Kai Salomaa;A Cellular Automaton Model for Car Traffic with a Slow-to-Stop Rule;We propose a modification of the widely known Benjamin-Johnson-Hui (BJH) cellular automaton model for single-lane traffic simulation. In particular, our model includes a ‘slow-to-stop’ rule that exhibits more realistic microscopic driver behaviour than the BJH model. We present some statistics related to fuel economy and pollution generation and show that our model differs greatly in these measures. We give concise results based on extensive simulations using our system.
12;Kai Salomaa;Adam Clarridge;A Cellular Automaton Model for Car Traffic with a Slow-to-Stop Rule;We propose a modification of the widely known Benjamin-Johnson-Hui (BJH) cellular automaton model for single-lane traffic simulation. In particular, our model includes a ‘slow-to-stop’ rule that exhibits more realistic microscopic driver behaviour than the BJH model. We present some statistics related to fuel economy and pollution generation and show that our model differs greatly in these measures. We give concise results based on extensive simulations using our system.
12;Jan Holub;Stanislav Štekr;On Parallel Implementations of Deterministic Finite Automata;We present implementations of parallel DFA run methods and find whether and under what conditions is worthy to use the parallel methods of simulation of run of finite automata.
12;Stanislav Štekr;Jan Holub;On Parallel Implementations of Deterministic Finite Automata;We present implementations of parallel DFA run methods and find whether and under what conditions is worthy to use the parallel methods of simulation of run of finite automata.
12;André Almeida;Marco Almeida, José Alves, Nelma Moreira, Rogério Reis;FAdo and GUItar: Tools for Automata Manipulation and Visualization;FAdo is an ongoing project which aims to provide a set of tools for symbolic manipulation of formal languages. To allow high-level programming with complex data structures, easy prototyping of algorithms, and portability (to use in computer grid systems for example), are its main features. Our main motivation is the theoretical and experimental research, but we have also in mind the construction of a pedagogical tool for teaching automata theory and formal languages. For the graphical visualization and interactive manipulation a new interface application, GUItar, is being developed. In this paper, we describe the main components of the FAdo system as well as the basics of the graphical interface and editor, the export/import filters and its generic interface with external systems, such as FAdo .
12;Marco Almeida;André Almeida, José Alves, Nelma Moreira, Rogério Reis;FAdo and GUItar: Tools for Automata Manipulation and Visualization;FAdo is an ongoing project which aims to provide a set of tools for symbolic manipulation of formal languages. To allow high-level programming with complex data structures, easy prototyping of algorithms, and portability (to use in computer grid systems for example), are its main features. Our main motivation is the theoretical and experimental research, but we have also in mind the construction of a pedagogical tool for teaching automata theory and formal languages. For the graphical visualization and interactive manipulation a new interface application, GUItar, is being developed. In this paper, we describe the main components of the FAdo system as well as the basics of the graphical interface and editor, the export/import filters and its generic interface with external systems, such as FAdo .
12;José Alves;André Almeida, Marco Almeida, Nelma Moreira, Rogério Reis;FAdo and GUItar: Tools for Automata Manipulation and Visualization;FAdo is an ongoing project which aims to provide a set of tools for symbolic manipulation of formal languages. To allow high-level programming with complex data structures, easy prototyping of algorithms, and portability (to use in computer grid systems for example), are its main features. Our main motivation is the theoretical and experimental research, but we have also in mind the construction of a pedagogical tool for teaching automata theory and formal languages. For the graphical visualization and interactive manipulation a new interface application, GUItar, is being developed. In this paper, we describe the main components of the FAdo system as well as the basics of the graphical interface and editor, the export/import filters and its generic interface with external systems, such as FAdo .
12;Nelma Moreira;André Almeida, Marco Almeida, José Alves, Rogério Reis;FAdo and GUItar: Tools for Automata Manipulation and Visualization;FAdo is an ongoing project which aims to provide a set of tools for symbolic manipulation of formal languages. To allow high-level programming with complex data structures, easy prototyping of algorithms, and portability (to use in computer grid systems for example), are its main features. Our main motivation is the theoretical and experimental research, but we have also in mind the construction of a pedagogical tool for teaching automata theory and formal languages. For the graphical visualization and interactive manipulation a new interface application, GUItar, is being developed. In this paper, we describe the main components of the FAdo system as well as the basics of the graphical interface and editor, the export/import filters and its generic interface with external systems, such as FAdo .
12;Rogério Reis;André Almeida, Marco Almeida, José Alves, Nelma Moreira;FAdo and GUItar: Tools for Automata Manipulation and Visualization;FAdo is an ongoing project which aims to provide a set of tools for symbolic manipulation of formal languages. To allow high-level programming with complex data structures, easy prototyping of algorithms, and portability (to use in computer grid systems for example), are its main features. Our main motivation is the theoretical and experimental research, but we have also in mind the construction of a pedagogical tool for teaching automata theory and formal languages. For the graphical visualization and interactive manipulation a new interface application, GUItar, is being developed. In this paper, we describe the main components of the FAdo system as well as the basics of the graphical interface and editor, the export/import filters and its generic interface with external systems, such as FAdo .
12;François Barthélemy;;A Testing Framework for Finite-State Morphology;This paper describes a unit testing framework for the languages which rely on rational relations to describe Natural Language Morphology. A test is divided into two parts: firstly compute a finite-state machine. secondly inspect this machine to compute its cardinality. The first part involves the finite-state machines to be tested and finite-state machines encoding the inputs of the test. A dependency relation is used to relate tests and the components of the description.
12;Yanbing Liu;Yifu Yang, Ping Liu, Jianlong Tan;A Table Compression Method for Extended Aho-Corasick Automaton;The Aho-Corasick algorithm is a classic method for matching a set of strings. However, the huge memory usage of Aho-Corasick automaton prevents it from being applied to large-scale pattern sets. Here we present a simple but efficient table compression method to reduce the automaton’s space. The basic idea of our method is based on equivalent rows elimination, which groups state rows into equivalent classes and eliminates the duplicates. Experiments demonstrate that the proposed method significantly reduces the memory usage and still runs at linear searching time comparable to that of extended Aho-Corasick algorithm. Our method provides good trade-off between memory usage and searching time.
12;Yifu Yang;Yanbing Liu, Ping Liu, Jianlong Tan;A Table Compression Method for Extended Aho-Corasick Automaton;The Aho-Corasick algorithm is a classic method for matching a set of strings. However, the huge memory usage of Aho-Corasick automaton prevents it from being applied to large-scale pattern sets. Here we present a simple but efficient table compression method to reduce the automaton’s space. The basic idea of our method is based on equivalent rows elimination, which groups state rows into equivalent classes and eliminates the duplicates. Experiments demonstrate that the proposed method significantly reduces the memory usage and still runs at linear searching time comparable to that of extended Aho-Corasick algorithm. Our method provides good trade-off between memory usage and searching time.
12;Ping Liu;Yanbing Liu, Yifu Yang, Jianlong Tan;A Table Compression Method for Extended Aho-Corasick Automaton;The Aho-Corasick algorithm is a classic method for matching a set of strings. However, the huge memory usage of Aho-Corasick automaton prevents it from being applied to large-scale pattern sets. Here we present a simple but efficient table compression method to reduce the automaton’s space. The basic idea of our method is based on equivalent rows elimination, which groups state rows into equivalent classes and eliminates the duplicates. Experiments demonstrate that the proposed method significantly reduces the memory usage and still runs at linear searching time comparable to that of extended Aho-Corasick algorithm. Our method provides good trade-off between memory usage and searching time.
12;Jianlong Tan;Yanbing Liu, Yifu Yang, Ping Liu;A Table Compression Method for Extended Aho-Corasick Automaton;The Aho-Corasick algorithm is a classic method for matching a set of strings. However, the huge memory usage of Aho-Corasick automaton prevents it from being applied to large-scale pattern sets. Here we present a simple but efficient table compression method to reduce the automaton’s space. The basic idea of our method is based on equivalent rows elimination, which groups state rows into equivalent classes and eliminates the duplicates. Experiments demonstrate that the proposed method significantly reduces the memory usage and still runs at linear searching time comparable to that of extended Aho-Corasick algorithm. Our method provides good trade-off between memory usage and searching time.
12;Kazuhiro Inaba;Haruo Hosoya;Compact Representation for Answer Sets of n-ary Regular Queries;An n-ary query over trees takes an input tree t and returns a set of n-tuples of the nodes of t. In this paper, a compact data structure is introduced for representing the answer sets of n-ary queries defined by tree automata. Despite that the number of the elements of the answer set can be as large as |t|n, our representation allows to store the set using only O(3n |t|) space. Several basic operations on the sets are shown to be efficiently executable on the representation.
12;Haruo Hosoya;Kazuhiro Inaba;Compact Representation for Answer Sets of n-ary Regular Queries;An n-ary query over trees takes an input tree t and returns a set of n-tuples of the nodes of t. In this paper, a compact data structure is introduced for representing the answer sets of n-ary queries defined by tree automata. Despite that the number of the elements of the answer set can be as large as |t|n, our representation allows to store the set using only O(3n |t|) space. Several basic operations on the sets are shown to be efficiently executable on the representation.
12;Akio Fujiyoshi;;Recognition of a Spanning Tree of Directed Acyclic Graphs by Tree Automata;In this paper, we study tree automata for directed acyclic graphs (DAGs). We define the movement of a tree automaton on a DAG so that a DAG is accepted by a tree automaton if and only if a DAG has a spanning tree accepted by a tree automaton. The NP-completeness of the membership problem of DAGs for a tree automaton is shown, and a linear-time recognition algorithm of series-parallel graphs for a tree automaton is presented.
12;Pierre-Cyrille Héam;Cyril Nicaud, Sylvain Schmitz;Random Generation of Deterministic Tree (Walking) Automata;Uniform random generators deliver a simple empirical means to estimate the average complexity of an algorithm. We present a general rejection algorithm that generates sequential letter-to-letter transducers up to isomorphism. We tailor this general scheme to randomly generate deterministic tree walking automata and deterministic top-down tree automata. We apply our implementation of the generator to the estimation of the average complexity of a deterministic tree walking automata to nondeterministic top-down tree automata construction we also implemented.
12;Cyril Nicaud;Pierre-Cyrille Héam, Sylvain Schmitz;Random Generation of Deterministic Tree (Walking) Automata;Uniform random generators deliver a simple empirical means to estimate the average complexity of an algorithm. We present a general rejection algorithm that generates sequential letter-to-letter transducers up to isomorphism. We tailor this general scheme to randomly generate deterministic tree walking automata and deterministic top-down tree automata. We apply our implementation of the generator to the estimation of the average complexity of a deterministic tree walking automata to nondeterministic top-down tree automata construction we also implemented.
12;Sylvain Schmitz;Pierre-Cyrille Héam, Cyril Nicaud;Random Generation of Deterministic Tree (Walking) Automata;Uniform random generators deliver a simple empirical means to estimate the average complexity of an algorithm. We present a general rejection algorithm that generates sequential letter-to-letter transducers up to isomorphism. We tailor this general scheme to randomly generate deterministic tree walking automata and deterministic top-down tree automata. We apply our implementation of the generator to the estimation of the average complexity of a deterministic tree walking automata to nondeterministic top-down tree automata construction we also implemented.
12;Taro Suzuki;Satoshi Okui;Hedge Pattern Partial Derivative;We propose hedge pattern partial derivatives, an extension of Antimirov’s partial derivatives, in order to give an operational semantics of pattern matching of regular hedge expression patterns, which is crucial in XML processing. We show that correct and small matching automata can be constructed from hedge pattern partial derivatives.
12;Satoshi Okui;Taro Suzuki;Hedge Pattern Partial Derivative;We propose hedge pattern partial derivatives, an extension of Antimirov’s partial derivatives, in order to give an operational semantics of pattern matching of regular hedge expression patterns, which is crucial in XML processing. We show that correct and small matching automata can be constructed from hedge pattern partial derivatives.
12;Roméo Courbis;Pierre-Cyrille Héam, Olga Kouchnarenko;TAGED Approximations for Temporal Properties Model-Checking;This paper investigates the use of tree automata with global equalities and disequalities (TAGED for short) in reachability analysis over term rewriting systems (TRSs). The reachability problem being in general undecidable on non terminating TRSs, we provide TAGED-based construction, and then design approximation-based semi-decision procedures to model-check useful temporal patterns on infinite state rewriting graphs. To show that the above TAGED-based construction can be effectively carried out, complexity analysis for rewriting TAGED-definable languages is given.
12;Pierre-Cyrille Héam;Roméo Courbis, Olga Kouchnarenko;TAGED Approximations for Temporal Properties Model-Checking;This paper investigates the use of tree automata with global equalities and disequalities (TAGED for short) in reachability analysis over term rewriting systems (TRSs). The reachability problem being in general undecidable on non terminating TRSs, we provide TAGED-based construction, and then design approximation-based semi-decision procedures to model-check useful temporal patterns on infinite state rewriting graphs. To show that the above TAGED-based construction can be effectively carried out, complexity analysis for rewriting TAGED-definable languages is given.
12;Olga Kouchnarenko;Roméo Courbis, Pierre-Cyrille Héam;TAGED Approximations for Temporal Properties Model-Checking;This paper investigates the use of tree automata with global equalities and disequalities (TAGED for short) in reachability analysis over term rewriting systems (TRSs). The reachability problem being in general undecidable on non terminating TRSs, we provide TAGED-based construction, and then design approximation-based semi-decision procedures to model-check useful temporal patterns on infinite state rewriting graphs. To show that the above TAGED-based construction can be effectively carried out, complexity analysis for rewriting TAGED-definable languages is given.
12;Mohamed Faouzi Atig;Tayssir Touili;Verifying Parallel Programs with Dynamic Communication Structures;We address the verification problem of networks of communicating pushdown systems modeling communicating parallel programs with procedure calls. Processes in such networks can read the control state of the other processes according to a given communication structure (specifying the observability rights between processes). The reachability problem of such models is undecidable in general. First, we define a class of networks that effectively preserves recognizability (hence, its reachability problem is decidable). Then, we consider networks where the communication structure can change dynamically during the execution according to a phase graph. The reachability problem for these dynamic networks being undecidable in general, we define a subclass for which it becomes decidable. Then, we consider reachability when the switches in the communication structures are bounded. We show that this problem is undecidable even for one switch. Then, we define a natural class of models for which this problem is decidable. This class can be used in the definition of an efficient semi-decision procedure for the analysis of the general model of dynamic networks. Our techniques allowed to find bugs in two versions of a Windows NT Bluetooth driver.
12;Tayssir Touili;Mohamed Faouzi Atig;Verifying Parallel Programs with Dynamic Communication Structures;We address the verification problem of networks of communicating pushdown systems modeling communicating parallel programs with procedure calls. Processes in such networks can read the control state of the other processes according to a given communication structure (specifying the observability rights between processes). The reachability problem of such models is undecidable in general. First, we define a class of networks that effectively preserves recognizability (hence, its reachability problem is decidable). Then, we consider networks where the communication structure can change dynamically during the execution according to a phase graph. The reachability problem for these dynamic networks being undecidable in general, we define a subclass for which it becomes decidable. Then, we consider reachability when the switches in the communication structures are bounded. We show that this problem is undecidable even for one switch. Then, we define a natural class of models for which this problem is decidable. This class can be used in the definition of an efficient semi-decision procedure for the analysis of the general model of dynamic networks. Our techniques allowed to find bugs in two versions of a Windows NT Bluetooth driver.
12;Pierre Ganty;Nicolas Maquet, Jean-François Raskin;Fixpoint Guided Abstraction Refinement for Alternating Automata;In this paper, we develop and evaluate two new algorithms for checking emptiness of alternating automata. These algorithms build on previous works. First, they rely on antichains to efficiently manipulate the state-spaces underlying the analysis of alternating automata. Second, they are abstract algorithms with built-in refinement operators based on techniques that exploit information computed by abstract fixed points (and not counter-examples as it is usually the case). The efficiency of our new algorithms is illustrated by experimental results.
12;Nicolas Maquet;Pierre Ganty, Jean-François Raskin;Fixpoint Guided Abstraction Refinement for Alternating Automata;In this paper, we develop and evaluate two new algorithms for checking emptiness of alternating automata. These algorithms build on previous works. First, they rely on antichains to efficiently manipulate the state-spaces underlying the analysis of alternating automata. Second, they are abstract algorithms with built-in refinement operators based on techniques that exploit information computed by abstract fixed points (and not counter-examples as it is usually the case). The efficiency of our new algorithms is illustrated by experimental results.
12;Jean-François Raskin;Pierre Ganty, Nicolas Maquet;Fixpoint Guided Abstraction Refinement for Alternating Automata;In this paper, we develop and evaluate two new algorithms for checking emptiness of alternating automata. These algorithms build on previous works. First, they rely on antichains to efficiently manipulate the state-spaces underlying the analysis of alternating automata. Second, they are abstract algorithms with built-in refinement operators based on techniques that exploit information computed by abstract fixed points (and not counter-examples as it is usually the case). The efficiency of our new algorithms is illustrated by experimental results.
13;Markus Holzer;Martin Kutrib;Nondeterministic Finite Automata—Recent Results on the Descriptional and Computational Complexity;Nondeterministic finite automata (NFAs) were introduced in [67], where their equivalence to deterministic finite automata was shown. Over the last 50 years, a vast literature documenting the importance of finite automata as an enormously valuable concept has been developed. In the present paper, we tour a fragment of this literature. Mostly, we discuss recent developments relevant to NFAs related problems like, for example, (i) simulation of and by several types of finite automata, (ii) minimization and approximation, (iii) size estimation of minimal NFAs, and (iv) state complexity of language operations. We thus come across descriptional and computational complexity issues of nondeterministic finite automata. We do not prove these results but we merely draw attention to the big picture and some of the main ideas involved.
13;Martin Kutrib;Markus Holzer;Nondeterministic Finite Automata—Recent Results on the Descriptional and Computational Complexity;Nondeterministic finite automata (NFAs) were introduced in [67], where their equivalence to deterministic finite automata was shown. Over the last 50 years, a vast literature documenting the importance of finite automata as an enormously valuable concept has been developed. In the present paper, we tour a fragment of this literature. Mostly, we discuss recent developments relevant to NFAs related problems like, for example, (i) simulation of and by several types of finite automata, (ii) minimization and approximation, (iii) size estimation of minimal NFAs, and (iv) state complexity of language operations. We thus come across descriptional and computational complexity issues of nondeterministic finite automata. We do not prove these results but we merely draw attention to the big picture and some of the main ideas involved.
13;Kai Salomaa;;Language Decompositions, Primality, and Trajectory-Based Operations;We consider the decomposability of languages and the notion of primality with respect to catenation, as well as, more general operations. We survey recent results and discuss open problems.
13;Mihalis Yannakakis;;Automata, Probability, and Recursion;We discuss work on the modeling and analysis of systems with probabilistic and recursive features. Recursive Markov chains extend ordinary finite state Markov chains with the ability to invoke other Markov chains in a potentially recursive manner. The equivalent model of Probabilistic Pushdown Automata extends ordinary pushdown automata with probabilistic actions. Both of these are natural abstract models for probabilistic programs with procedures, and related systems. They generalize other classical well-studied stochastic models, e.g. Stochastic Context-free Grammars and (Multi-type) Branching Processes, that arise in a variety of areas. More generally, Recursive Markov Decision Processes and Recursive Stochastic Games can be used to model recursive systems that have both probabilistic and nonprobabilistic, controllable actions. In recent years there has been substantial work on the algorithmic analysis of these models, regarding basic questions of termination, reachability, and analysis of the properties of their executions. In this talk we will present some of the basic theory, algorithmic methods, results, and challenges.
13;Hsu-Chun Yen;;Concurrency, Synchronization, and Conflicts in Petri Nets;Petri nets represent one of the most popular formalisms for specifying, modeling, and analyzing concurrent systems. In spite of their popularity, many interesting problems concerning Petri nets are either undecidable or of very high complexity. Lipton [7] and Rackoff [10] showed exponential space lower and upper bounds, respectively, for the boundedness problem. As for the containment and the equivalence problems, Rabin [1] and Hack [5], respectively, showed these two problems to be undecidable. The reachability problem is known to be decidable [8] and exponential-space-hard [7].
13;Yih-Kuen Tsay;Bow-Yaw Wang;Automated Compositional Reasoning of Intuitionistically Closed Regular Properties;Analysis of infinitary safety properties with automated compositional reasoning through learning is discussed. We consider the class of intuitionistically closed regular languages and show that it forms a Heyting algebra and is finitely approximatable. Consequently, compositional proof rules can be verified automatically and learning algorithms for finitary regular languages suffice for generating the needed contextual assumptions. We also provide a semantic justification of an axiom to deduce circular compositional proof rules for such infinitary languages.
13;Bow-Yaw Wang;Yih-Kuen Tsay;Automated Compositional Reasoning of Intuitionistically Closed Regular Properties;Analysis of infinitary safety properties with automated compositional reasoning through learning is discussed. We consider the class of intuitionistically closed regular languages and show that it forms a Heyting algebra and is finitely approximatable. Consequently, compositional proof rules can be verified automatically and learning algorithms for finitary regular languages suffice for generating the needed contextual assumptions. We also provide a semantic justification of an axiom to deduce circular compositional proof rules for such infinitary languages.
13;Marco Almeida;Nelma Moreira, Rogério Reis;Antimirov and Mosses’s Rewrite System Revisited;Antimirov and Mosses proposed a rewrite system for deciding the equivalence of two (extended) regular expressions. In this paper we present a functional approach to that method, prove its correctness, and give some experimental comparative results. Besides an improved version of Antimirov and Mosses’s algorithm, we present a version using partial derivatives. Our preliminary results lead to the conclusion that, indeed, these methods are feasible and, generally, faster than the classical methods.
13;Nelma Moreira;Marco Almeida, Rogério Reis;Antimirov and Mosses’s Rewrite System Revisited;Antimirov and Mosses proposed a rewrite system for deciding the equivalence of two (extended) regular expressions. In this paper we present a functional approach to that method, prove its correctness, and give some experimental comparative results. Besides an improved version of Antimirov and Mosses’s algorithm, we present a version using partial derivatives. Our preliminary results lead to the conclusion that, indeed, these methods are feasible and, generally, faster than the classical methods.
13;Rogério Reis;Marco Almeida, Nelma Moreira;Antimirov and Mosses’s Rewrite System Revisited;Antimirov and Mosses proposed a rewrite system for deciding the equivalence of two (extended) regular expressions. In this paper we present a functional approach to that method, prove its correctness, and give some experimental comparative results. Besides an improved version of Antimirov and Mosses’s algorithm, we present a version using partial derivatives. Our preliminary results lead to the conclusion that, indeed, these methods are feasible and, generally, faster than the classical methods.
13;Ahmed Bouajjani;Peter Habermehl, Lukáš Holík, Tayssir Touili, Tomáš Vojnar;Antichain-Based Universality and Inclusion Testing over Nondeterministic Finite Tree Automata;We propose new antichain-based algorithms for checking universality and inclusion of nondeterministic tree automata (NTA). We have implemented these algorithms in a prototype tool and our experiments show that they provide a significant improvement over the traditional determinisation-based approaches. We use our antichain-based inclusion checking algorithm to build an abstract regular tree model checking framework based entirely on NTA. We show the significantly improved efficiency of this framework through a series of experiments with verifying various programs over dynamic linked tree-shaped data structures.
13;Peter Habermehl;Ahmed Bouajjani, Lukáš Holík, Tayssir Touili, Tomáš Vojnar;Antichain-Based Universality and Inclusion Testing over Nondeterministic Finite Tree Automata;We propose new antichain-based algorithms for checking universality and inclusion of nondeterministic tree automata (NTA). We have implemented these algorithms in a prototype tool and our experiments show that they provide a significant improvement over the traditional determinisation-based approaches. We use our antichain-based inclusion checking algorithm to build an abstract regular tree model checking framework based entirely on NTA. We show the significantly improved efficiency of this framework through a series of experiments with verifying various programs over dynamic linked tree-shaped data structures.
13;Lukáš Holík;Ahmed Bouajjani, Peter Habermehl, Tayssir Touili, Tomáš Vojnar;Antichain-Based Universality and Inclusion Testing over Nondeterministic Finite Tree Automata;We propose new antichain-based algorithms for checking universality and inclusion of nondeterministic tree automata (NTA). We have implemented these algorithms in a prototype tool and our experiments show that they provide a significant improvement over the traditional determinisation-based approaches. We use our antichain-based inclusion checking algorithm to build an abstract regular tree model checking framework based entirely on NTA. We show the significantly improved efficiency of this framework through a series of experiments with verifying various programs over dynamic linked tree-shaped data structures.
13;Tayssir Touili;Ahmed Bouajjani, Peter Habermehl, Lukáš Holík, Tomáš Vojnar;Antichain-Based Universality and Inclusion Testing over Nondeterministic Finite Tree Automata;We propose new antichain-based algorithms for checking universality and inclusion of nondeterministic tree automata (NTA). We have implemented these algorithms in a prototype tool and our experiments show that they provide a significant improvement over the traditional determinisation-based approaches. We use our antichain-based inclusion checking algorithm to build an abstract regular tree model checking framework based entirely on NTA. We show the significantly improved efficiency of this framework through a series of experiments with verifying various programs over dynamic linked tree-shaped data structures.
13;Tomáš Vojnar;Ahmed Bouajjani, Peter Habermehl, Lukáš Holík, Tayssir Touili;Antichain-Based Universality and Inclusion Testing over Nondeterministic Finite Tree Automata;We propose new antichain-based algorithms for checking universality and inclusion of nondeterministic tree automata (NTA). We have implemented these algorithms in a prototype tool and our experiments show that they provide a significant improvement over the traditional determinisation-based approaches. We use our antichain-based inclusion checking algorithm to build an abstract regular tree model checking framework based entirely on NTA. We show the significantly improved efficiency of this framework through a series of experiments with verifying various programs over dynamic linked tree-shaped data structures.
13;J. -M. Champarnaud;J. -Ph. Dubernard, H. Jeanne;Testing Whether a Binary and Prolongeable Regular Language L Is Geometrical or Not on the Minimal Deterministic Automaton of Pref(L);Our aim is to present an efficient algorithm that checks whether a binary and prolongeable regular language is geometrical or not, based on specific properties of its minimal deterministic automaton. Geometrical languages have been introduced in the framework of off-line temporal validation of real-time softwares. Actually, validation can be achieved through both a model based on regular languages and a model based on discrete geometry. Geometrical languages are intended to develop a link between these two models. The regular case is of practical interest regarding to implementation features, which motivates the design of an efficient geometricity test addressing the family of regular languages.
13;J. -Ph. Dubernard;J. -M. Champarnaud, H. Jeanne;Testing Whether a Binary and Prolongeable Regular Language L Is Geometrical or Not on the Minimal Deterministic Automaton of Pref(L);Our aim is to present an efficient algorithm that checks whether a binary and prolongeable regular language is geometrical or not, based on specific properties of its minimal deterministic automaton. Geometrical languages have been introduced in the framework of off-line temporal validation of real-time softwares. Actually, validation can be achieved through both a model based on regular languages and a model based on discrete geometry. Geometrical languages are intended to develop a link between these two models. The regular case is of practical interest regarding to implementation features, which motivates the design of an efficient geometricity test addressing the family of regular languages.
13;H. Jeanne;J. -M. Champarnaud, J. -Ph. Dubernard;Testing Whether a Binary and Prolongeable Regular Language L Is Geometrical or Not on the Minimal Deterministic Automaton of Pref(L);Our aim is to present an efficient algorithm that checks whether a binary and prolongeable regular language is geometrical or not, based on specific properties of its minimal deterministic automaton. Geometrical languages have been introduced in the framework of off-line temporal validation of real-time softwares. Actually, validation can be achieved through both a model based on regular languages and a model based on discrete geometry. Geometrical languages are intended to develop a link between these two models. The regular case is of practical interest regarding to implementation features, which motivates the design of an efficient geometricity test addressing the family of regular languages.
13;Andrei Păun;Mihaela Păun, Alfonso Rodríguez-Patón;Hopcroft’s Minimization Technique: Queues or Stacks?;We consider the absolute worst case time complexity for Hopcroft’s minimization algorithm applied to unary languages (or a modification of this algorithm for cover automata minimization). We show that in this setting the worst case is reached only for deterministic automata or cover automata following the structure of the de Bruijn words. We refine a previous result by showing that the Berstel/Carton example reported before is actually the absolute worst case time complexity in the case of unary languages for deterministic automata. We show that the same result is valid also when considering the setting of cover automata and an algorithm based on the Hopcroft’s method used for minimization of cover automata. We also show that a LIFO implementation for the splitting list is desirable for the case of unary languages in the setting of deterministic finite automata.
13;Mihaela Păun;Andrei Păun, Alfonso Rodríguez-Patón;Hopcroft’s Minimization Technique: Queues or Stacks?;We consider the absolute worst case time complexity for Hopcroft’s minimization algorithm applied to unary languages (or a modification of this algorithm for cover automata minimization). We show that in this setting the worst case is reached only for deterministic automata or cover automata following the structure of the de Bruijn words. We refine a previous result by showing that the Berstel/Carton example reported before is actually the absolute worst case time complexity in the case of unary languages for deterministic automata. We show that the same result is valid also when considering the setting of cover automata and an algorithm based on the Hopcroft’s method used for minimization of cover automata. We also show that a LIFO implementation for the splitting list is desirable for the case of unary languages in the setting of deterministic finite automata.
13;Alfonso Rodríguez-Patón;Andrei Păun, Mihaela Păun;Hopcroft’s Minimization Technique: Queues or Stacks?;We consider the absolute worst case time complexity for Hopcroft’s minimization algorithm applied to unary languages (or a modification of this algorithm for cover automata minimization). We show that in this setting the worst case is reached only for deterministic automata or cover automata following the structure of the de Bruijn words. We refine a previous result by showing that the Berstel/Carton example reported before is actually the absolute worst case time complexity in the case of unary languages for deterministic automata. We show that the same result is valid also when considering the setting of cover automata and an algorithm based on the Hopcroft’s method used for minimization of cover automata. We also show that a LIFO implementation for the splitting list is desirable for the case of unary languages in the setting of deterministic finite automata.
13;Pedro García;Manuel Vázquez de Parga, Gloria I. Álvarez, José Ruiz;Learning Regular Languages Using Nondeterministic Finite Automata;A new general method for inference of regular languages using nondeterministic automata as output has recently been developed and proved to converge. The aim of this paper is to describe and analyze the behavior of two implementations of that method and to compare it with two well known algorithms for the same task. A complete set of experiments has been carried out and the results of the new algorithms improve the existing ones both in recognition rates as in sizes of the output automata.
13;Manuel Vázquez de Parga;Pedro García, Gloria I. Álvarez, José Ruiz;Learning Regular Languages Using Nondeterministic Finite Automata;A new general method for inference of regular languages using nondeterministic automata as output has recently been developed and proved to converge. The aim of this paper is to describe and analyze the behavior of two implementations of that method and to compare it with two well known algorithms for the same task. A complete set of experiments has been carried out and the results of the new algorithms improve the existing ones both in recognition rates as in sizes of the output automata.
13;Gloria I. Álvarez;Pedro García, Manuel Vázquez de Parga, José Ruiz;Learning Regular Languages Using Nondeterministic Finite Automata;A new general method for inference of regular languages using nondeterministic automata as output has recently been developed and proved to converge. The aim of this paper is to describe and analyze the behavior of two implementations of that method and to compare it with two well known algorithms for the same task. A complete set of experiments has been carried out and the results of the new algorithms improve the existing ones both in recognition rates as in sizes of the output automata.
13;José Ruiz;Pedro García, Manuel Vázquez de Parga, Gloria I. Álvarez;Learning Regular Languages Using Nondeterministic Finite Automata;A new general method for inference of regular languages using nondeterministic automata as output has recently been developed and proved to converge. The aim of this paper is to describe and analyze the behavior of two implementations of that method and to compare it with two well known algorithms for the same task. A complete set of experiments has been carried out and the results of the new algorithms improve the existing ones both in recognition rates as in sizes of the output automata.
13;Kazuhiro Inaba;Haruo Hosoya, Sebastian Maneth;Multi-Return Macro Tree Transducers;An extension of macro tree transducers is introduced with the capability of states to return multiple trees at the same time. Under call-by-value semantics, the new model is strictly more expressive than call-by-value macro tree transducers, and moreover, it has better closure properties under composition.
13;Haruo Hosoya;Kazuhiro Inaba, Sebastian Maneth;Multi-Return Macro Tree Transducers;An extension of macro tree transducers is introduced with the capability of states to return multiple trees at the same time. Under call-by-value semantics, the new model is strictly more expressive than call-by-value macro tree transducers, and moreover, it has better closure properties under composition.
13;Sebastian Maneth;Kazuhiro Inaba, Haruo Hosoya;Multi-Return Macro Tree Transducers;An extension of macro tree transducers is introduced with the capability of states to return multiple trees at the same time. Under call-by-value semantics, the new model is strictly more expressive than call-by-value macro tree transducers, and moreover, it has better closure properties under composition.
13;François Cantin;Axel Legay, Pierre Wolper;Computing Convex Hulls by Automata Iteration;This paper considers the problem of computing the real convex hull of a finite set of n-dimensional integer vectors. The starting point is a finite-automaton representation of the initial set of vectors. The proposed method consists in computing a sequence of automata representing approximations of the convex hull and using extrapolation techniques to compute the limit of this sequence. The convex hull can then be directly computed from this limit in the form of an automaton-based representation of the corresponding set of real vectors. The technique is quite general and has been implemented. Also, our result fits in a wider scheme whose objective is to improve the techniques for converting automata-based representation of constraints to formulas.
13;Axel Legay;François Cantin, Pierre Wolper;Computing Convex Hulls by Automata Iteration;This paper considers the problem of computing the real convex hull of a finite set of n-dimensional integer vectors. The starting point is a finite-automaton representation of the initial set of vectors. The proposed method consists in computing a sequence of automata representing approximations of the convex hull and using extrapolation techniques to compute the limit of this sequence. The convex hull can then be directly computed from this limit in the form of an automaton-based representation of the corresponding set of real vectors. The technique is quite general and has been implemented. Also, our result fits in a wider scheme whose objective is to improve the techniques for converting automata-based representation of constraints to formulas.
13;Pierre Wolper;François Cantin, Axel Legay;Computing Convex Hulls by Automata Iteration;This paper considers the problem of computing the real convex hull of a finite set of n-dimensional integer vectors. The starting point is a finite-automaton representation of the initial set of vectors. The proposed method consists in computing a sequence of automata representing approximations of the convex hull and using extrapolation techniques to compute the limit of this sequence. The convex hull can then be directly computed from this limit in the form of an automaton-based representation of the corresponding set of real vectors. The technique is quite general and has been implemented. Also, our result fits in a wider scheme whose objective is to improve the techniques for converting automata-based representation of constraints to formulas.
13;Takuya Nishiyama;Yasuhiko Minamide;A Translation from the HTML DTD into a Regular Hedge Grammar;The PHP string analyzer developed by the second author approximates the string output of a program with a context-free grammar. By developing a procedure to decide inclusion between context-free and regular hedge languages, Minamide and Tozawa applied this analysis to checking the validity of dynamically generated XHTML documents. In this paper, we consider the problem of checking the validity of dynamically generated HTML documents instead of XHTML documents.
13;Yasuhiko Minamide;Takuya Nishiyama;A Translation from the HTML DTD into a Regular Hedge Grammar;The PHP string analyzer developed by the second author approximates the string output of a program with a context-free grammar. By developing a procedure to decide inclusion between context-free and regular hedge languages, Minamide and Tozawa applied this analysis to checking the validity of dynamically generated XHTML documents. In this paper, we consider the problem of checking the validity of dynamically generated HTML documents instead of XHTML documents.
13;Andreas Maletti;;Tree-Series-to-Tree-Series Transformations;We investigate the tree-series-to-tree-series (ts-ts) transformation computed by tree series transducers. Unless the used semiring is complete, this transformation is, in general, not well-defined. In practice, many used semirings are not complete (like the probability semiring). We establish a syntactical condition that guarantees well-definedness of the ts-ts transformation in arbitrary commutative semirings. For positive (ie, zero-sum and zero-divisor free) semirings the condition actually characterizes the well-definedness, so that well-definedness is decidable in this scenario.
13;Ryan Dixon;Ömer Eğecioğlu, Timothy Sherwood;Automata-Theoretic Analysis of Bit-Split Languages for Packet Scanning;Bit-splitting breaks the problem of monitoring traffic payloads to detect the occurrence of suspicious patterns into several parallel components, each of which searches for a particular bit pattern. We analyze bit-splitting as applied to Aho-Corasick style string matching. The problem can be viewed as the recovery of a special class of regular languages over product alphabets from a collection of homomorphic images. We use this characterization to prove correctness and to give space bounds. In particular we show that the NFA to DFA conversion of the Aho-Corasick type machine used for bit-splitting incurs only linear overhead.
13;Ömer Eğecioğlu;Ryan Dixon, Timothy Sherwood;Automata-Theoretic Analysis of Bit-Split Languages for Packet Scanning;Bit-splitting breaks the problem of monitoring traffic payloads to detect the occurrence of suspicious patterns into several parallel components, each of which searches for a particular bit pattern. We analyze bit-splitting as applied to Aho-Corasick style string matching. The problem can be viewed as the recovery of a special class of regular languages over product alphabets from a collection of homomorphic images. We use this characterization to prove correctness and to give space bounds. In particular we show that the NFA to DFA conversion of the Aho-Corasick type machine used for bit-splitting incurs only linear overhead.
13;Timothy Sherwood;Ryan Dixon, Ömer Eğecioğlu;Automata-Theoretic Analysis of Bit-Split Languages for Packet Scanning;Bit-splitting breaks the problem of monitoring traffic payloads to detect the occurrence of suspicious patterns into several parallel components, each of which searches for a particular bit pattern. We analyze bit-splitting as applied to Aho-Corasick style string matching. The problem can be viewed as the recovery of a special class of regular languages over product alphabets from a collection of homomorphic images. We use this characterization to prove correctness and to give space bounds. In particular we show that the NFA to DFA conversion of the Aho-Corasick type machine used for bit-splitting incurs only linear overhead.
13;Jan Lahoda;Bořivoj Melichar, Jan Žd’árek;Pattern Matching in DCA Coded Text;A new algorithm searching all occurrences of a regular expression pattern in a text is presented. It uses only the text that has been compressed by the text compression using antidictionaries without its decompression. The proposed algorithm runs in \({\mathcal O}(2^m\cdot||{\rm AD}||^2+n_c+r)\) worst case time, where m is the length of the pattern, AD is the antidictionary, nC is the length of the coded text and r is the number of found matches.
13;Bořivoj Melichar;Jan Lahoda, Jan Žd’árek;Pattern Matching in DCA Coded Text;A new algorithm searching all occurrences of a regular expression pattern in a text is presented. It uses only the text that has been compressed by the text compression using antidictionaries without its decompression. The proposed algorithm runs in \({\mathcal O}(2^m\cdot||{\rm AD}||^2+n_c+r)\) worst case time, where m is the length of the pattern, AD is the antidictionary, nC is the length of the coded text and r is the number of found matches.
13;Jan Žd’árek;Jan Lahoda, Bořivoj Melichar;Pattern Matching in DCA Coded Text;A new algorithm searching all occurrences of a regular expression pattern in a text is presented. It uses only the text that has been compressed by the text compression using antidictionaries without its decompression. The proposed algorithm runs in \({\mathcal O}(2^m\cdot||{\rm AD}||^2+n_c+r)\) worst case time, where m is the length of the pattern, AD is the antidictionary, nC is the length of the coded text and r is the number of found matches.
13;Rob van Glabbeek;Bas Ploeger;Five Determinisation Algorithms;Determinisation of nondeterministic finite automata is a well-studied problem that plays an important role in compiler theory and system verification. In the latter field, one often encounters automata consisting of millions or even billions of states. On such input, the memory usage of analysis tools becomes the major bottleneck. In this paper we present several determinisation algorithms, all variants of the well-known subset construction, that aim to reduce memory usage and produce smaller output automata. One of them produces automata that are already minimal. We apply our algorithms to determinise automata that describe the possible sequences appearing after a fixed-length run of cellular automaton 110, and obtain a significant improvement in both memory and time efficiency.
13;Bas Ploeger;Rob van Glabbeek;Five Determinisation Algorithms;Determinisation of nondeterministic finite automata is a well-studied problem that plays an important role in compiler theory and system verification. In the latter field, one often encounters automata consisting of millions or even billions of states. On such input, the memory usage of analysis tools becomes the major bottleneck. In this paper we present several determinisation algorithms, all variants of the well-known subset construction, that aim to reduce memory usage and produce smaller output automata. One of them produces automata that are already minimal. We apply our algorithms to determinise automata that describe the possible sequences appearing after a fixed-length run of cellular automaton 110, and obtain a significant improvement in both memory and time efficiency.
13;Harald Hempel;Madlen Kimmritz;Persistent Computations of Turing Machines;In this paper we formally define the notion of persistent Turing machines to model interactive computations. We compare the power of persistent computations with their classical counterparts.
13;Madlen Kimmritz;Harald Hempel;Persistent Computations of Turing Machines;In this paper we formally define the notion of persistent Turing machines to model interactive computations. We compare the power of persistent computations with their classical counterparts.
13;Egor Dolzhenko;Nataša Jonoska;On Complexity of Two Dimensional Languages Generated by Transducers;We consider two-dimensional languages, called here 2d transducer languages, generated by iterative applications of transducers (finite state automata with output). To each transducer a two-dimensional language consisting of blocks of symbols is associated: the bottom row of a block is an input string accepted by the transducer and, by iterative application of the transducer, each row of the block is an output of the transducer on the preceding row. We observe that this class of languages is a proper subclass of recognizable picture languages containing the class of all factorial local 2d languages. By taking the average growth rate of the number of blocks in the language as a measure of its complexity, also known as the entropy of the language, we show that every entropy value of a one-dimensional regular language can be obtained as an entropy value of a 2d transducer language.
13;Nataša Jonoska;Egor Dolzhenko;On Complexity of Two Dimensional Languages Generated by Transducers;We consider two-dimensional languages, called here 2d transducer languages, generated by iterative applications of transducers (finite state automata with output). To each transducer a two-dimensional language consisting of blocks of symbols is associated: the bottom row of a block is an input string accepted by the transducer and, by iterative application of the transducer, each row of the block is an output of the transducer on the preceding row. We observe that this class of languages is a proper subclass of recognizable picture languages containing the class of all factorial local 2d languages. By taking the average growth rate of the number of blocks in the language as a measure of its complexity, also known as the entropy of the language, we show that every entropy value of a one-dimensional regular language can be obtained as an entropy value of a 2d transducer language.
14;Gheorghe Păun;;Spiking Neural P Systems Used as Acceptors and Transducers;The study of spiking neural P systems is a branch of membrane computing (comprehensive information about this area of natural computing can be found in [24], [9], or at the web page [31]) initiated in [18]. The goal is to build a model of the way the neurons cooperate in (large) neural nets, communicating by means of spikes, electrical impulses of identical shapes. “Computing by spiking” is a vivid research area in neural computing, which promises to lead to a neural computing “of the third generation” - see [12], [22], etc.
14;Moshe Y. Vardi;;Linear-Time Model Checking: Automata Theory in Practice;In automata-theoretic model checking we compose the design under verification with a Büchi automaton that accepts traces violating the specification. We then use graph algorithms to search for a counterexample trace. The basic theory of this approach was worked out in the 1980s, and the basic algorithms were developed during the 1990s. Both explicit and symbolic implementations, such as SPIN and and SMV, are widely used. It turns out, however, that there are still many gaps in our understanding of the algorithmic issues involved in automata-theoretic model checking. This paper covers the fundamentals of automata-theoretic model checking. The conference talk also reviews the reduction of the theory to practice and outlines areas that require further research.
14;Cyril Allauzen;Michael Riley, Johan Schalkwyk, Wojciech Skut, Mehryar Mohri;OpenFst: A General and Efficient Weighted Finite-State Transducer Library;We describe OpenFst, an open-source library for weighted finite-state transducers (WFSTs). OpenFst consists of a C++ template library with efficient WFST representations and over twenty-five operations for constructing, combining, optimizing, and searching them. At the shell-command level, there are corresponding transducer file representations and programs that operate on them. OpenFst is designed to be both very efficient in time and space and to scale to very large problems.
14;Michael Riley;Cyril Allauzen, Johan Schalkwyk, Wojciech Skut, Mehryar Mohri;OpenFst: A General and Efficient Weighted Finite-State Transducer Library;We describe OpenFst, an open-source library for weighted finite-state transducers (WFSTs). OpenFst consists of a C++ template library with efficient WFST representations and over twenty-five operations for constructing, combining, optimizing, and searching them. At the shell-command level, there are corresponding transducer file representations and programs that operate on them. OpenFst is designed to be both very efficient in time and space and to scale to very large problems.
14;Johan Schalkwyk;Cyril Allauzen, Michael Riley, Wojciech Skut, Mehryar Mohri;OpenFst: A General and Efficient Weighted Finite-State Transducer Library;We describe OpenFst, an open-source library for weighted finite-state transducers (WFSTs). OpenFst consists of a C++ template library with efficient WFST representations and over twenty-five operations for constructing, combining, optimizing, and searching them. At the shell-command level, there are corresponding transducer file representations and programs that operate on them. OpenFst is designed to be both very efficient in time and space and to scale to very large problems.
14;Wojciech Skut;Cyril Allauzen, Michael Riley, Johan Schalkwyk, Mehryar Mohri;OpenFst: A General and Efficient Weighted Finite-State Transducer Library;We describe OpenFst, an open-source library for weighted finite-state transducers (WFSTs). OpenFst consists of a C++ template library with efficient WFST representations and over twenty-five operations for constructing, combining, optimizing, and searching them. At the shell-command level, there are corresponding transducer file representations and programs that operate on them. OpenFst is designed to be both very efficient in time and space and to scale to very large problems.
14;Mehryar Mohri;Cyril Allauzen, Michael Riley, Johan Schalkwyk, Wojciech Skut;OpenFst: A General and Efficient Weighted Finite-State Transducer Library;We describe OpenFst, an open-source library for weighted finite-state transducers (WFSTs). OpenFst consists of a C++ template library with efficient WFST representations and over twenty-five operations for constructing, combining, optimizing, and searching them. At the shell-command level, there are corresponding transducer file representations and programs that operate on them. OpenFst is designed to be both very efficient in time and space and to scale to very large problems.
14;Bruce W. Watson;;Automata Applications in Chip-Design Software;In this paper, I present several new automata applications in software for electronic design automation (EDA) — chip design. EDA software has typically been implemented by and for microelectronic engineers, and the associated algorithmics remains underdeveloped. In several cases, overly complex algorithms have been used whereas automata could have been applied after abstracting from the problem details.
14;Mikhail V. Volkov;;Synchronizing Automata Preserving a Chain of Partial Orders;We present a new class of automata which strictly contains the class of aperiodic automata and shares with the latter certain synchronization properties. In particular, every strongly connected automaton in this new class is synchronizing and has a reset word of length \(\left\lfloor\frac{n(n+1)}6\right\rfloor\) where n is the number of states of the automaton.
14;Jean-Marc Champarnaud;Franck Guingne, Jacques Farré;Reducing Acyclic Cover Transducers;Finite languages and finite subsequential functions can be represented by possibly cyclic finite machines, respectively called cover automata and cover transducers. In general, reduced cover machines have much fewer states than the corresponding minimal machines, yielding a compact representation for lexicons or dictionaries. We present here a new algorithm for reducing the number of states of an acyclic transducer.
14;Franck Guingne;Jean-Marc Champarnaud, Jacques Farré;Reducing Acyclic Cover Transducers;Finite languages and finite subsequential functions can be represented by possibly cyclic finite machines, respectively called cover automata and cover transducers. In general, reduced cover machines have much fewer states than the corresponding minimal machines, yielding a compact representation for lexicons or dictionaries. We present here a new algorithm for reducing the number of states of an acyclic transducer.
14;Jacques Farré;Jean-Marc Champarnaud, Franck Guingne;Reducing Acyclic Cover Transducers;Finite languages and finite subsequential functions can be represented by possibly cyclic finite machines, respectively called cover automata and cover transducers. In general, reduced cover machines have much fewer states than the corresponding minimal machines, yielding a compact representation for lexicons or dictionaries. We present here a new algorithm for reducing the number of states of an acyclic transducer.
14;Joachim Klein;Christel Baier;On-the-Fly Stuttering in the Construction of Deterministic ω-Automata;We propose to use the knowledge that an ω-regular property is stutter insensitive to construct potentially smaller deterministic ω-automata for such a property, e.g. using Safra’s determinization construction. This knowledge allows us to skip states that are redundant under stuttering, which can reduce the size of the generated automaton. In order to use this technique even for automata that are not completely insensitive to stuttering, we introduce the notion of partial stutter insensitiveness and apply our construction only on the subset of symbols for which stuttering is allowed. We evaluate the benefits of this heuristic in practice using multiple sets of benchmark formulas.
14;Christel Baier;Joachim Klein;On-the-Fly Stuttering in the Construction of Deterministic ω-Automata;We propose to use the knowledge that an ω-regular property is stutter insensitive to construct potentially smaller deterministic ω-automata for such a property, e.g. using Safra’s determinization construction. This knowledge allows us to skip states that are redundant under stuttering, which can reduce the size of the generated automaton. In order to use this technique even for automata that are not completely insensitive to stuttering, we introduce the notion of partial stutter insensitiveness and apply our construction only on the subset of symbols for which stuttering is allowed. We evaluate the benefits of this heuristic in practice using multiple sets of benchmark formulas.
14;Massimiliano Goldwurm;Roberto Radicioni;Average Value and Variance of Pattern Statistics in Rational Models;We study the pattern statistics representing the number of occurrences of a given string in a word of length n generated at random by rational stochastic models, defined by means of weighted finite automata. We get asymptotic estimations for the mean value and the variance of these statistics under the hypothesis that the matrix of all transition weights is primitive. Our results extend previous evaluations obtained by assuming ergodic stationary Markovian sources and they yield a general framework to determine analogous estimations under several stochastic models. In particular they show the role of the stationarity hypothesis in such models.
14;Roberto Radicioni;Massimiliano Goldwurm;Average Value and Variance of Pattern Statistics in Rational Models;We study the pattern statistics representing the number of occurrences of a given string in a word of length n generated at random by rational stochastic models, defined by means of weighted finite automata. We get asymptotic estimations for the mean value and the variance of these statistics under the hypothesis that the matrix of all transition weights is primitive. Our results extend previous evaluations obtained by assuming ergodic stationary Markovian sources and they yield a general framework to determine analogous estimations under several stochastic models. In particular they show the role of the stationarity hypothesis in such models.
14;Manfred Droste;George Rahonis;Weighted Automata and Weighted Logics with Discounting;We introduce a weighted logic with discounting and we establish Büchi’s and Elgot’s theorem for weighted automata over finite words and arbitrary commutative semirings. Then we investigate Büchi and Muller automata with discounting over the max-plus and the min-plus semiring. We show their expressive equivalence with weighted MSO-sentences with discounting. In this case our logic has a purely syntactic definition. For the finite case, we obtain a purely syntactically defined weighted logic if the underlying semiring is additively locally finite.
14;George Rahonis;Manfred Droste;Weighted Automata and Weighted Logics with Discounting;We introduce a weighted logic with discounting and we establish Büchi’s and Elgot’s theorem for weighted automata over finite words and arbitrary commutative semirings. Then we investigate Büchi and Muller automata with discounting over the max-plus and the min-plus semiring. We show their expressive equivalence with weighted MSO-sentences with discounting. In this case our logic has a purely syntactic definition. For the finite case, we obtain a purely syntactically defined weighted logic if the underlying semiring is additively locally finite.
14;Martin Kutrib;Andreas Malcher, Larissa Werlein;Regulated Nondeterminism in Pushdown Automata;A generalization of pushdown automata towards regulated nondeterminism is studied. The nondeterminism is governed in such a way that the decision, whether or not a nondeterministic rule is applied, depends on the whole content of the stack. More precisely, the content of the stack is considered as a word over the stack alphabet, and the pushdown automaton is allowed to act nondeterministically, if this word belongs to some given set R of control words. Otherwise its behavior is deterministic. The computational capacity of such R -PDAs depends on the complexity of R. It turns out that non-context-free languages are accepted even if R is a linear, deterministic context-free language. On the other hand, regular control sets R do not increase the computational capacity of nondeterministic pushdown automata. This raises the natural question for the relations between the structure and complexity of regular sets R on one hand and the computational capacity of the corresponding R -PDA on the other hand. Clearly, if R is empty, the deterministic context-free languages are characterized. For R = {a,b}* one obtains all context-free languages. Furthermore, if R is finite, then the regular closure of the deterministic context-free languages is described. We investigate these questions, and discuss closure properties of the language classes in question under AFL operations.
14;Andreas Malcher;Martin Kutrib, Larissa Werlein;Regulated Nondeterminism in Pushdown Automata;A generalization of pushdown automata towards regulated nondeterminism is studied. The nondeterminism is governed in such a way that the decision, whether or not a nondeterministic rule is applied, depends on the whole content of the stack. More precisely, the content of the stack is considered as a word over the stack alphabet, and the pushdown automaton is allowed to act nondeterministically, if this word belongs to some given set R of control words. Otherwise its behavior is deterministic. The computational capacity of such R -PDAs depends on the complexity of R. It turns out that non-context-free languages are accepted even if R is a linear, deterministic context-free language. On the other hand, regular control sets R do not increase the computational capacity of nondeterministic pushdown automata. This raises the natural question for the relations between the structure and complexity of regular sets R on one hand and the computational capacity of the corresponding R -PDA on the other hand. Clearly, if R is empty, the deterministic context-free languages are characterized. For R = {a,b}* one obtains all context-free languages. Furthermore, if R is finite, then the regular closure of the deterministic context-free languages is described. We investigate these questions, and discuss closure properties of the language classes in question under AFL operations.
14;Larissa Werlein;Martin Kutrib, Andreas Malcher;Regulated Nondeterminism in Pushdown Automata;A generalization of pushdown automata towards regulated nondeterminism is studied. The nondeterminism is governed in such a way that the decision, whether or not a nondeterministic rule is applied, depends on the whole content of the stack. More precisely, the content of the stack is considered as a word over the stack alphabet, and the pushdown automaton is allowed to act nondeterministically, if this word belongs to some given set R of control words. Otherwise its behavior is deterministic. The computational capacity of such R -PDAs depends on the complexity of R. It turns out that non-context-free languages are accepted even if R is a linear, deterministic context-free language. On the other hand, regular control sets R do not increase the computational capacity of nondeterministic pushdown automata. This raises the natural question for the relations between the structure and complexity of regular sets R on one hand and the computational capacity of the corresponding R -PDA on the other hand. Clearly, if R is empty, the deterministic context-free languages are characterized. For R = {a,b}* one obtains all context-free languages. Furthermore, if R is finite, then the regular closure of the deterministic context-free languages is described. We investigate these questions, and discuss closure properties of the language classes in question under AFL operations.
14;Kai Salomaa;Sheng Yu, Jinfeng Zan;Deterministic Caterpillar Expressions;Caterpillar expressions have been introduced by Brüggemann-Klein and Wood for applications in markup languages. A caterpillar expression can be implemented as a tree walking automaton operating on unranked trees. Here we give a formal definition of determinism of caterpillar expressions that is based on the language of instruction sequences defined by the expression. We show that determinism of caterpillar expressions can be decided in polynomial time.
14;Sheng Yu;Kai Salomaa, Jinfeng Zan;Deterministic Caterpillar Expressions;Caterpillar expressions have been introduced by Brüggemann-Klein and Wood for applications in markup languages. A caterpillar expression can be implemented as a tree walking automaton operating on unranked trees. Here we give a formal definition of determinism of caterpillar expressions that is based on the language of instruction sequences defined by the expression. We show that determinism of caterpillar expressions can be decided in polynomial time.
14;Jinfeng Zan;Kai Salomaa, Sheng Yu;Deterministic Caterpillar Expressions;Caterpillar expressions have been introduced by Brüggemann-Klein and Wood for applications in markup languages. A caterpillar expression can be implemented as a tree walking automaton operating on unranked trees. Here we give a formal definition of determinism of caterpillar expressions that is based on the language of instruction sequences defined by the expression. We show that determinism of caterpillar expressions can be decided in polynomial time.
14;Johanna Högberg;Andreas Maletti, Jonathan May;Backward and Forward Bisimulation Minimisation of Tree Automata;We improve an existing bisimulation minimisation algorithm for tree automata by introducing backward and forward bisimulations and developing minimisation algorithms for them. Minimisation via forward bisimulation is also effective for deterministic automata and faster than the previous algorithm. Minimisation via backward bisimulation generalises the previous algorithm and is thus more effective but just as fast. We demonstrate implementations of these algorithms on a typical task in natural language processing.
14;Andreas Maletti;Johanna Högberg, Jonathan May;Backward and Forward Bisimulation Minimisation of Tree Automata;We improve an existing bisimulation minimisation algorithm for tree automata by introducing backward and forward bisimulations and developing minimisation algorithms for them. Minimisation via forward bisimulation is also effective for deterministic automata and faster than the previous algorithm. Minimisation via backward bisimulation generalises the previous algorithm and is thus more effective but just as fast. We demonstrate implementations of these algorithms on a typical task in natural language processing.
14;Jonathan May;Johanna Högberg, Andreas Maletti;Backward and Forward Bisimulation Minimisation of Tree Automata;We improve an existing bisimulation minimisation algorithm for tree automata by introducing backward and forward bisimulations and developing minimisation algorithms for them. Minimisation via forward bisimulation is also effective for deterministic automata and faster than the previous algorithm. Minimisation via backward bisimulation generalises the previous algorithm and is thus more effective but just as fast. We demonstrate implementations of these algorithms on a typical task in natural language processing.
14;Rafael C. Carrasco;Jan Daciuk, Mikel L. Forcada;An Implementation of Deterministic Tree Automata Minimization;A frontier-to-root deterministic finite-state tree automaton (DTA) can be used as a compact data structure to store collections of unranked ordered trees. DTAs are usually sparser than string automata, as most transitions are undefined and therefore, special care must be taken in order to minimize them efficiently. However, it is difficult to find simple and detailed descriptions of the minimization procedure in the published literature. Here, we fully describe a simple implementation of the standard minimization algorithm that needs a time in \(\mathcal{O}(|A|^2)\), with |A| being the size of the DTA.
14;Jan Daciuk;Rafael C. Carrasco, Mikel L. Forcada;An Implementation of Deterministic Tree Automata Minimization;A frontier-to-root deterministic finite-state tree automaton (DTA) can be used as a compact data structure to store collections of unranked ordered trees. DTAs are usually sparser than string automata, as most transitions are undefined and therefore, special care must be taken in order to minimize them efficiently. However, it is difficult to find simple and detailed descriptions of the minimization procedure in the published literature. Here, we fully describe a simple implementation of the standard minimization algorithm that needs a time in \(\mathcal{O}(|A|^2)\), with |A| being the size of the DTA.
14;Mikel L. Forcada;Rafael C. Carrasco, Jan Daciuk;An Implementation of Deterministic Tree Automata Minimization;A frontier-to-root deterministic finite-state tree automaton (DTA) can be used as a compact data structure to store collections of unranked ordered trees. DTAs are usually sparser than string automata, as most transitions are undefined and therefore, special care must be taken in order to minimize them efficiently. However, it is difficult to find simple and detailed descriptions of the minimization procedure in the published literature. Here, we fully describe a simple implementation of the standard minimization algorithm that needs a time in \(\mathcal{O}(|A|^2)\), with |A| being the size of the DTA.
14;Shmuel T. Klein;Miri Kopel Ben-Nissan;Accelerating Boyer Moore Searches on Binary Texts;The Boyer and Moore (BM) pattern matching algorithm is considered as one of the best, but its performance is reduced on binary data. Yet, searching in binary texts has important applications, such as compressed matching. The paper shows how, by means of some pre-computed tables, one may implement the BM algorithm also for the binary case without referring to bits, and processing only entire blocks such as bytes or words, thereby significantly reducing the number of comparisons. Empirical comparisons show that the new variant performs better than regular binary BM and even than BDM.
14;Miri Kopel Ben-Nissan;Shmuel T. Klein;Accelerating Boyer Moore Searches on Binary Texts;The Boyer and Moore (BM) pattern matching algorithm is considered as one of the best, but its performance is reduced on binary data. Yet, searching in binary texts has important applications, such as compressed matching. The paper shows how, by means of some pre-computed tables, one may implement the BM algorithm also for the binary case without referring to bits, and processing only entire blocks such as bytes or words, thereby significantly reducing the number of comparisons. Empirical comparisons show that the new variant performs better than regular binary BM and even than BDM.
14;Maxime Crochemore;Chiara Epifanio, Alessandra Gabriele, Filippo Mignosi;On the Suffix Automaton with Mismatches;In this paper we focus on the construction of the minimal deterministic finite automaton Sk that recognizes the set of suffixes of a word w up to k errors. We present an algorithm that makes use of Sk in order to accept in an efficient way the language of all suffixes of w up to k errors in every window of size r, where r is the value of the repetition index of w. Moreover, we give some experimental results on some well-known words, like prefixes of Fibonacci and Thue-Morse words, and we make a conjecture on the size of the suffix automaton with mismatches.
14;Chiara Epifanio;Maxime Crochemore, Alessandra Gabriele, Filippo Mignosi;On the Suffix Automaton with Mismatches;In this paper we focus on the construction of the minimal deterministic finite automaton Sk that recognizes the set of suffixes of a word w up to k errors. We present an algorithm that makes use of Sk in order to accept in an efficient way the language of all suffixes of w up to k errors in every window of size r, where r is the value of the repetition index of w. Moreover, we give some experimental results on some well-known words, like prefixes of Fibonacci and Thue-Morse words, and we make a conjecture on the size of the suffix automaton with mismatches.
14;Alessandra Gabriele;Maxime Crochemore, Chiara Epifanio, Filippo Mignosi;On the Suffix Automaton with Mismatches;In this paper we focus on the construction of the minimal deterministic finite automaton Sk that recognizes the set of suffixes of a word w up to k errors. We present an algorithm that makes use of Sk in order to accept in an efficient way the language of all suffixes of w up to k errors in every window of size r, where r is the value of the repetition index of w. Moreover, we give some experimental results on some well-known words, like prefixes of Fibonacci and Thue-Morse words, and we make a conjecture on the size of the suffix automaton with mismatches.
14;Filippo Mignosi;Maxime Crochemore, Chiara Epifanio, Alessandra Gabriele;On the Suffix Automaton with Mismatches;In this paper we focus on the construction of the minimal deterministic finite automaton Sk that recognizes the set of suffixes of a word w up to k errors. We present an algorithm that makes use of Sk in order to accept in an efficient way the language of all suffixes of w up to k errors in every window of size r, where r is the value of the repetition index of w. Moreover, we give some experimental results on some well-known words, like prefixes of Fibonacci and Thue-Morse words, and we make a conjecture on the size of the suffix automaton with mismatches.
14;Hannu Peltola;Jorma Tarhio;On String Matching in Chunked Texts;We study exact string matching in special texts, which consist of consecutive fixed-length chunks where each position of a chunk has a character distribution of its own. This kind of setting can also be interpreted so that a chunk represents a character of a larger alphabet. If texts and patterns are of this kind, it may ruin the efficiency of common algorithms. We examine anomalies related to the Horspool and Sunday algorithms in this setting. In addition we present two new algorithms.
14;Jorma Tarhio;Hannu Peltola;On String Matching in Chunked Texts;We study exact string matching in special texts, which consist of consecutive fixed-length chunks where each position of a chunk has a character distribution of its own. This kind of setting can also be interpreted so that a chunk represents a character of a larger alphabet. If texts and patterns are of this kind, it may ruin the efficiency of common algorithms. We examine anomalies related to the Horspool and Sunday algorithms in this setting. In addition we present two new algorithms.
14;Mehryar Mohri;Pedro Moreno, Eugene Weinstein;Factor Automata of Automata and Applications;An efficient data structure for representing the full index of a set of strings is the factor automaton, the minimal deterministic automaton representing the set of all factors or substrings of these strings. This paper presents a novel analysis of the size of the factor automaton of an automaton, that is the minimal deterministic automaton accepting the set of factors of a finite set of strings, itself represented by a finite automaton. It shows that the factor automaton of a set of strings U has at most 2|Q| − 2 states, where Q is the number of nodes of a prefix-tree representing the strings in U, a bound that significantly improves over 2 ||U||− 1, the bound given by Blumer et al. (1987), where ||U|| is the sum of the lengths of all strings in U. It also gives novel and general bounds for the size of the factor automaton of an automaton as a function of the size of the original automaton and the maximal length of a suffix shared by the strings it accepts. Our analysis suggests that the use of factor automata of automata can be practical for large-scale applications, a fact that is further supported by the results of our experiments applying factor automata to a music identification task with more than 15,000 songs.
14;Pedro Moreno;Mehryar Mohri, Eugene Weinstein;Factor Automata of Automata and Applications;An efficient data structure for representing the full index of a set of strings is the factor automaton, the minimal deterministic automaton representing the set of all factors or substrings of these strings. This paper presents a novel analysis of the size of the factor automaton of an automaton, that is the minimal deterministic automaton accepting the set of factors of a finite set of strings, itself represented by a finite automaton. It shows that the factor automaton of a set of strings U has at most 2|Q| − 2 states, where Q is the number of nodes of a prefix-tree representing the strings in U, a bound that significantly improves over 2 ||U||− 1, the bound given by Blumer et al. (1987), where ||U|| is the sum of the lengths of all strings in U. It also gives novel and general bounds for the size of the factor automaton of an automaton as a function of the size of the original automaton and the maximal length of a suffix shared by the strings it accepts. Our analysis suggests that the use of factor automata of automata can be practical for large-scale applications, a fact that is further supported by the results of our experiments applying factor automata to a music identification task with more than 15,000 songs.
14;Eugene Weinstein;Mehryar Mohri, Pedro Moreno;Factor Automata of Automata and Applications;An efficient data structure for representing the full index of a set of strings is the factor automaton, the minimal deterministic automaton representing the set of all factors or substrings of these strings. This paper presents a novel analysis of the size of the factor automaton of an automaton, that is the minimal deterministic automaton accepting the set of factors of a finite set of strings, itself represented by a finite automaton. It shows that the factor automaton of a set of strings U has at most 2|Q| − 2 states, where Q is the number of nodes of a prefix-tree representing the strings in U, a bound that significantly improves over 2 ||U||− 1, the bound given by Blumer et al. (1987), where ||U|| is the sum of the lengths of all strings in U. It also gives novel and general bounds for the size of the factor automaton of an automaton as a function of the size of the original automaton and the maximal length of a suffix shared by the strings it accepts. Our analysis suggests that the use of factor automata of automata can be practical for large-scale applications, a fact that is further supported by the results of our experiments applying factor automata to a music identification task with more than 15,000 songs.
14;Gregory Kucherov;Laurent Noé, Mikhail Roytberg;Subset Seed Automaton;We study the pattern matching automaton introduced in [1] for the purpose of seed-based similarity search. We show that our definition provides a compact automaton, much smaller than the one obtained by applying the Aho-Corasick construction. We study properties of this automaton and present an efficient implementation of the automaton construction. We also present some experimental results and show that this automaton can be successfully applied to more general situations.
14;Laurent Noé;Gregory Kucherov, Mikhail Roytberg;Subset Seed Automaton;We study the pattern matching automaton introduced in [1] for the purpose of seed-based similarity search. We show that our definition provides a compact automaton, much smaller than the one obtained by applying the Aho-Corasick construction. We study properties of this automaton and present an efficient implementation of the automaton construction. We also present some experimental results and show that this automaton can be successfully applied to more general situations.
14;Mikhail Roytberg;Gregory Kucherov, Laurent Noé;Subset Seed Automaton;We study the pattern matching automaton introduced in [1] for the purpose of seed-based similarity search. We show that our definition provides a compact automaton, much smaller than the one obtained by applying the Aho-Corasick construction. We study properties of this automaton and present an efficient implementation of the automaton construction. We also present some experimental results and show that this automaton can be successfully applied to more general situations.
14;František Mráz;Martin Plátek, Friedrich Otto;A Measure for the Degree of Nondeterminism of Context-Free Languages;Restarting automata can be seen as analytical variants of classical automata as well as of regulated rewriting systems. We study some measures for the degree of nondeterminism of (context-free) languages in terms of lexicalized deterministic restarting automata. These measures are based on the number of auxiliary symbols (categories) used for recognizing a language as the projection of its characteristic language onto its input alphabet. This type of recognition is typical for analysis by reduction, a method used in linguistics for the creation and verification of formal descriptions of natural languages. Our main results establish a two-dimensional hierarchy of classes of (context-free) languages based on the expansion factor of a language and on the number of different auxiliary symbols available in the underlying characteristic language.
14;Martin Plátek;František Mráz, Friedrich Otto;A Measure for the Degree of Nondeterminism of Context-Free Languages;Restarting automata can be seen as analytical variants of classical automata as well as of regulated rewriting systems. We study some measures for the degree of nondeterminism of (context-free) languages in terms of lexicalized deterministic restarting automata. These measures are based on the number of auxiliary symbols (categories) used for recognizing a language as the projection of its characteristic language onto its input alphabet. This type of recognition is typical for analysis by reduction, a method used in linguistics for the creation and verification of formal descriptions of natural languages. Our main results establish a two-dimensional hierarchy of classes of (context-free) languages based on the expansion factor of a language and on the number of different auxiliary symbols available in the underlying characteristic language.
14;Friedrich Otto;František Mráz, Martin Plátek;A Measure for the Degree of Nondeterminism of Context-Free Languages;Restarting automata can be seen as analytical variants of classical automata as well as of regulated rewriting systems. We study some measures for the degree of nondeterminism of (context-free) languages in terms of lexicalized deterministic restarting automata. These measures are based on the number of auxiliary symbols (categories) used for recognizing a language as the projection of its characteristic language onto its input alphabet. This type of recognition is typical for analysis by reduction, a method used in linguistics for the creation and verification of formal descriptions of natural languages. Our main results establish a two-dimensional hierarchy of classes of (context-free) languages based on the expansion factor of a language and on the number of different auxiliary symbols available in the underlying characteristic language.
15;Ming Li;;Information Distance and Its Applications;We summarize the recent developments of a general theory of information distance and its applications in whole genome phylogeny, document comparison, internet query-answer systems, and many other data mining tasks. We also solve an open problem regarding the universality of the normalized information distance.
15;Grzegorz Rozenberg;;Theory Inspired by Gene Assembly in Ciliates;Ciliates (ciliated protozoa) are unicellular organisms with an evolutionary history that extends back perhaps two billion (2 x 109) years. The unique extraordinary feature of ciliates is that they posses two kinds of nuclei within the same cell: macronucleus containing genes that provide the genetic information needed to maintain the structure and function of the cell, and micronucleus that does not contribute to the maintainance, growth and proliferation of the cell – it is reserved for the sexual exchange of DNA between two mating cells.
15;Sheng Yu;;On the State Complexity of Combined Operations;The state complexity of combined operations is studied. We show that the state complexity of a combined operation can be very different from the composition of the state complexities of the participating individual operations. However, the estimate through individual nondeterministic state complexities for each of the combined operations being considered is very similar to the actual state complexity. Several open problems related to state complexity are also proposed.
15;Mathieu Giraud;Philippe Veber, Dominique Lavenier;Path-Equivalent Removals of ε-transitions in a Genomic Weighted Finite Automaton;Weighted finite automata (WFA) are used with accelerating hardware to scan large genomic banks. Hardwiring such automata raise surface area and clock frequency constraints, requiring efficient ε-transitions-removal techniques. In this paper, we present new bounds on the number of new transitions for several ε-transitions-removal problems. We study the case of acyclic WFA. We introduce a new problem, the partial removal of ε-transitions while accepting short chains of ε-transitions.
15;Philippe Veber;Mathieu Giraud, Dominique Lavenier;Path-Equivalent Removals of ε-transitions in a Genomic Weighted Finite Automaton;Weighted finite automata (WFA) are used with accelerating hardware to scan large genomic banks. Hardwiring such automata raise surface area and clock frequency constraints, requiring efficient ε-transitions-removal techniques. In this paper, we present new bounds on the number of new transitions for several ε-transitions-removal problems. We study the case of acyclic WFA. We introduce a new problem, the partial removal of ε-transitions while accepting short chains of ε-transitions.
15;Dominique Lavenier;Mathieu Giraud, Philippe Veber;Path-Equivalent Removals of ε-transitions in a Genomic Weighted Finite Automaton;Weighted finite automata (WFA) are used with accelerating hardware to scan large genomic banks. Hardwiring such automata raise surface area and clock frequency constraints, requiring efficient ε-transitions-removal techniques. In this paper, we present new bounds on the number of new transitions for several ε-transitions-removal problems. We study the case of acyclic WFA. We introduce a new problem, the partial removal of ε-transitions while accepting short chains of ε-transitions.
15;Henning Bordihn;Markus Holzer, Martin Kutrib;Hybrid Extended Finite Automata;Extended finite automata are finite state automata equipped with the additional ability to apply an operation on the currently remaining input word, depending on the current state. Hybrid extended finite automata can choose from a finite set of such operations. In this paper, five word operations are taken into consideration which always yield letter-equivalent results, namely reversal and shift operations. The computational power of those machines is investigated, locating the corresponding families of languages in the Chomsky hierarchy. Furthermore, different types of hybrid extended finite automata, defined by the set of operations they are allowed to apply, are compared with each other, demonstrating that there exist dependencies and independencies between the input manipulating operations.
15;Markus Holzer;Henning Bordihn, Martin Kutrib;Hybrid Extended Finite Automata;Extended finite automata are finite state automata equipped with the additional ability to apply an operation on the currently remaining input word, depending on the current state. Hybrid extended finite automata can choose from a finite set of such operations. In this paper, five word operations are taken into consideration which always yield letter-equivalent results, namely reversal and shift operations. The computational power of those machines is investigated, locating the corresponding families of languages in the Chomsky hierarchy. Furthermore, different types of hybrid extended finite automata, defined by the set of operations they are allowed to apply, are compared with each other, demonstrating that there exist dependencies and independencies between the input manipulating operations.
15;Martin Kutrib;Henning Bordihn, Markus Holzer;Hybrid Extended Finite Automata;Extended finite automata are finite state automata equipped with the additional ability to apply an operation on the currently remaining input word, depending on the current state. Hybrid extended finite automata can choose from a finite set of such operations. In this paper, five word operations are taken into consideration which always yield letter-equivalent results, namely reversal and shift operations. The computational power of those machines is investigated, locating the corresponding families of languages in the Chomsky hierarchy. Furthermore, different types of hybrid extended finite automata, defined by the set of operations they are allowed to apply, are compared with each other, demonstrating that there exist dependencies and independencies between the input manipulating operations.
15;German Tischler;;Refinement of Near Random Access Video Coding with Weighted Finite Automata;Random access video compression is mostly implemented without any reduction of temporal redundancy. Standard video compression systems like MPEG (1,2 and 4) are heavily based on motion compensation, which to some extent makes random access at single frame level impossible. We present a method for near random access video compression of low-motion video that is based on the discrete cosine transform and vector quantization and refine this system using weighted finite automata while keeping the random access property and using some reduction of temporal redundancy.
15;Martin Šimůnek;Bořivoj Melichar;Borders and Finite Automata;A border of a string is a prefix of the string that is simultaneously its suffix. It is one of the basic stringology keystones used as a part of many algorithms in pattern matching, molecular biology, computer-assisted music analysis and others. The paper discusses automata-theoretical background of Iliopoulos’s ALL_BORDERS algorithm that finds all borders of a string with don’t care symbols. We show that ALL_BORDERS algorithm is a simulator of a finite automaton together with explaining the function of the automaton. We show that the simulated automaton accepts intersection of sets of prefixes and suffixes (and thus a set of borders) of the input string. Last but not least we define approximate borders. Based on the knowledge of the automata background of ALL_BORDERS algorithm we offer an automata-based algorithm that finds approximate borders with Hamming distance. We discuss conditions under which the same principle can be used for other distance measures for which an approximate searching automaton can be constructed.
15;Bořivoj Melichar;Martin Šimůnek;Borders and Finite Automata;A border of a string is a prefix of the string that is simultaneously its suffix. It is one of the basic stringology keystones used as a part of many algorithms in pattern matching, molecular biology, computer-assisted music analysis and others. The paper discusses automata-theoretical background of Iliopoulos’s ALL_BORDERS algorithm that finds all borders of a string with don’t care symbols. We show that ALL_BORDERS algorithm is a simulator of a finite automaton together with explaining the function of the automaton. We show that the simulated automaton accepts intersection of sets of prefixes and suffixes (and thus a set of borders) of the input string. Last but not least we define approximate borders. Based on the knowledge of the automata background of ALL_BORDERS algorithm we offer an automata-based algorithm that finds approximate borders with Hamming distance. We discuss conditions under which the same principle can be used for other distance measures for which an approximate searching automaton can be constructed.
15;Pavlos Antoniou;Jan Holub, Costas S. Iliopoulos, Bořivoj Melichar, Pierre Peterlongo;Finding Common Motifs with Gaps Using Finite Automata;We present an algorithm that uses finite automata to find the common motifs with gaps occurring in all strings belonging to a finite set S = {S1,S2,...,Sr}. In order to find these common motifs we must first identify the factors that exist in each string. Therefore the algorithm begins by constructing a factor automaton for each string Si. To find the common factors of all the strings, the algorithm needs to gather all the factors from the strings together in one data structure and this is achieved by computing an automaton that accepts the union of the above-mentioned automata. Using this automaton we are able to create a new factor alphabet. Based on this factor alphabet a finite automaton is created for each string Si that accepts sequences of all non overlapping factors residing in each string. The intersection of the latter automata produces the finite automaton which accepts all the common subsequences with gaps over the factor alphabet that are present in all the strings of the set S = {S1,S2,...,Sr}. These common subsequences are the common motifs of the strings.
15;Jan Holub;Pavlos Antoniou, Costas S. Iliopoulos, Bořivoj Melichar, Pierre Peterlongo;Finding Common Motifs with Gaps Using Finite Automata;We present an algorithm that uses finite automata to find the common motifs with gaps occurring in all strings belonging to a finite set S = {S1,S2,...,Sr}. In order to find these common motifs we must first identify the factors that exist in each string. Therefore the algorithm begins by constructing a factor automaton for each string Si. To find the common factors of all the strings, the algorithm needs to gather all the factors from the strings together in one data structure and this is achieved by computing an automaton that accepts the union of the above-mentioned automata. Using this automaton we are able to create a new factor alphabet. Based on this factor alphabet a finite automaton is created for each string Si that accepts sequences of all non overlapping factors residing in each string. The intersection of the latter automata produces the finite automaton which accepts all the common subsequences with gaps over the factor alphabet that are present in all the strings of the set S = {S1,S2,...,Sr}. These common subsequences are the common motifs of the strings.
15;Costas S. Iliopoulos;Pavlos Antoniou, Jan Holub, Bořivoj Melichar, Pierre Peterlongo;Finding Common Motifs with Gaps Using Finite Automata;We present an algorithm that uses finite automata to find the common motifs with gaps occurring in all strings belonging to a finite set S = {S1,S2,...,Sr}. In order to find these common motifs we must first identify the factors that exist in each string. Therefore the algorithm begins by constructing a factor automaton for each string Si. To find the common factors of all the strings, the algorithm needs to gather all the factors from the strings together in one data structure and this is achieved by computing an automaton that accepts the union of the above-mentioned automata. Using this automaton we are able to create a new factor alphabet. Based on this factor alphabet a finite automaton is created for each string Si that accepts sequences of all non overlapping factors residing in each string. The intersection of the latter automata produces the finite automaton which accepts all the common subsequences with gaps over the factor alphabet that are present in all the strings of the set S = {S1,S2,...,Sr}. These common subsequences are the common motifs of the strings.
15;Bořivoj Melichar;Pavlos Antoniou, Jan Holub, Costas S. Iliopoulos, Pierre Peterlongo;Finding Common Motifs with Gaps Using Finite Automata;We present an algorithm that uses finite automata to find the common motifs with gaps occurring in all strings belonging to a finite set S = {S1,S2,...,Sr}. In order to find these common motifs we must first identify the factors that exist in each string. Therefore the algorithm begins by constructing a factor automaton for each string Si. To find the common factors of all the strings, the algorithm needs to gather all the factors from the strings together in one data structure and this is achieved by computing an automaton that accepts the union of the above-mentioned automata. Using this automaton we are able to create a new factor alphabet. Based on this factor alphabet a finite automaton is created for each string Si that accepts sequences of all non overlapping factors residing in each string. The intersection of the latter automata produces the finite automaton which accepts all the common subsequences with gaps over the factor alphabet that are present in all the strings of the set S = {S1,S2,...,Sr}. These common subsequences are the common motifs of the strings.
15;Pierre Peterlongo;Pavlos Antoniou, Jan Holub, Costas S. Iliopoulos, Bořivoj Melichar;Finding Common Motifs with Gaps Using Finite Automata;We present an algorithm that uses finite automata to find the common motifs with gaps occurring in all strings belonging to a finite set S = {S1,S2,...,Sr}. In order to find these common motifs we must first identify the factors that exist in each string. Therefore the algorithm begins by constructing a factor automaton for each string Si. To find the common factors of all the strings, the algorithm needs to gather all the factors from the strings together in one data structure and this is achieved by computing an automaton that accepts the union of the above-mentioned automata. Using this automaton we are able to create a new factor alphabet. Based on this factor alphabet a finite automaton is created for each string Si that accepts sequences of all non overlapping factors residing in each string. The intersection of the latter automata produces the finite automaton which accepts all the common subsequences with gaps over the factor alphabet that are present in all the strings of the set S = {S1,S2,...,Sr}. These common subsequences are the common motifs of the strings.
15;Maxime Crochemore;Lucian Ilie, Emine Seid-Hilmi;Factor Oracles;The factor oracle is a relatively new data structure for the set of factors of a string which has been introduced by Allauzen, Crochemore, and Raffinot in 1999. It may recognize non-factors (hence the name “oracle”) but its implementational simplicity and experimental behaviour are stunning. factor oracle based string matching has been conjectured optimal on average. However, its structure is not well understood. We take important steps in clarifying its structure by explaining how it can be obtained as a quotient of the trie for the set of factors. When seen this way, all known properties of the factor oracle become simple observations. Also, we introduce a framework where various oracles can be compared. The factor oracle is better than several natural ones.
15;Lucian Ilie;Maxime Crochemore, Emine Seid-Hilmi;Factor Oracles;The factor oracle is a relatively new data structure for the set of factors of a string which has been introduced by Allauzen, Crochemore, and Raffinot in 1999. It may recognize non-factors (hence the name “oracle”) but its implementational simplicity and experimental behaviour are stunning. factor oracle based string matching has been conjectured optimal on average. However, its structure is not well understood. We take important steps in clarifying its structure by explaining how it can be obtained as a quotient of the trie for the set of factors. When seen this way, all known properties of the factor oracle become simple observations. Also, we introduce a framework where various oracles can be compared. The factor oracle is better than several natural ones.
15;Emine Seid-Hilmi;Maxime Crochemore, Lucian Ilie;Factor Oracles;The factor oracle is a relatively new data structure for the set of factors of a string which has been introduced by Allauzen, Crochemore, and Raffinot in 1999. It may recognize non-factors (hence the name “oracle”) but its implementational simplicity and experimental behaviour are stunning. factor oracle based string matching has been conjectured optimal on average. However, its structure is not well understood. We take important steps in clarifying its structure by explaining how it can be obtained as a quotient of the trie for the set of factors. When seen this way, all known properties of the factor oracle become simple observations. Also, we introduce a framework where various oracles can be compared. The factor oracle is better than several natural ones.
15;Cédric Bastien;Jurek Czyzowicz, Wojciech Fraczak, Wojciech Rytter;Reducing Simple Grammars: Exponential Against Highly-Polynomial Time in Practice;The simple grammar reduction is an important component in the implementation of Concatenation State Machines (a hardware version of stateless pushdown automata designed for wire-speed network packet classification). We present a comparison and experimental analysis of the best-known algorithms for the grammar reduction. There are two classes of algorithms: the ones that process compressed strings without decompression (polynomial time) and the ones which process strings explicitely. The second category, though exponential time in pessimistic case, is more efficient in the considered practical scenario. There are two approaches to this problem: one processing compressed strings without decompression and another one which processes strings explicitely. It turns out that the second approach is more efficient in the considered practical scenario despite having worst-case exponential time complexity (while the first one is polynomial). The study has been conducted in the context of network packet classification, where simple grammars are used for representing the classification policies.
15;Jurek Czyzowicz;Cédric Bastien, Wojciech Fraczak, Wojciech Rytter;Reducing Simple Grammars: Exponential Against Highly-Polynomial Time in Practice;The simple grammar reduction is an important component in the implementation of Concatenation State Machines (a hardware version of stateless pushdown automata designed for wire-speed network packet classification). We present a comparison and experimental analysis of the best-known algorithms for the grammar reduction. There are two classes of algorithms: the ones that process compressed strings without decompression (polynomial time) and the ones which process strings explicitely. The second category, though exponential time in pessimistic case, is more efficient in the considered practical scenario. There are two approaches to this problem: one processing compressed strings without decompression and another one which processes strings explicitely. It turns out that the second approach is more efficient in the considered practical scenario despite having worst-case exponential time complexity (while the first one is polynomial). The study has been conducted in the context of network packet classification, where simple grammars are used for representing the classification policies.
15;Wojciech Fraczak;Cédric Bastien, Jurek Czyzowicz, Wojciech Rytter;Reducing Simple Grammars: Exponential Against Highly-Polynomial Time in Practice;The simple grammar reduction is an important component in the implementation of Concatenation State Machines (a hardware version of stateless pushdown automata designed for wire-speed network packet classification). We present a comparison and experimental analysis of the best-known algorithms for the grammar reduction. There are two classes of algorithms: the ones that process compressed strings without decompression (polynomial time) and the ones which process strings explicitely. The second category, though exponential time in pessimistic case, is more efficient in the considered practical scenario. There are two approaches to this problem: one processing compressed strings without decompression and another one which processes strings explicitely. It turns out that the second approach is more efficient in the considered practical scenario despite having worst-case exponential time complexity (while the first one is polynomial). The study has been conducted in the context of network packet classification, where simple grammars are used for representing the classification policies.
15;Wojciech Rytter;Cédric Bastien, Jurek Czyzowicz, Wojciech Fraczak;Reducing Simple Grammars: Exponential Against Highly-Polynomial Time in Practice;The simple grammar reduction is an important component in the implementation of Concatenation State Machines (a hardware version of stateless pushdown automata designed for wire-speed network packet classification). We present a comparison and experimental analysis of the best-known algorithms for the grammar reduction. There are two classes of algorithms: the ones that process compressed strings without decompression (polynomial time) and the ones which process strings explicitely. The second category, though exponential time in pessimistic case, is more efficient in the considered practical scenario. There are two approaches to this problem: one processing compressed strings without decompression and another one which processes strings explicitely. It turns out that the second approach is more efficient in the considered practical scenario despite having worst-case exponential time complexity (while the first one is polynomial). The study has been conducted in the context of network packet classification, where simple grammars are used for representing the classification policies.
15;Jonathan May;Kevin Knight;Tiburon: A Weighted Tree Automata Toolkit;The availability of weighted finite-state string automata toolkits made possible great advances in natural language processing. However, recent advances in syntax-based NLP model design are unsuitable for these toolkits. To combat this problem, we introduce a weighted finite-state tree automata toolkit, which incorporates recent developments in weighted tree automata theory and is useful for natural language applications such as machine translation, sentence compression, question answering, and many more.
15;Kevin Knight;Jonathan May;Tiburon: A Weighted Tree Automata Toolkit;The availability of weighted finite-state string automata toolkits made possible great advances in natural language processing. However, recent advances in syntax-based NLP model design are unsuitable for these toolkits. To combat this problem, we introduce a weighted finite-state tree automata toolkit, which incorporates recent developments in weighted tree automata theory and is useful for natural language applications such as machine translation, sentence compression, question answering, and many more.
15;Manuel Baclet;Claire Pagetti;Around Hopcroft’s Algorithm;In this paper, a reflection is made on an indeterminism inherent to Hopcroft’s minimization algorithm: the splitter choice. We have implemented two natural policies (FIFO and FILO) for managing the set of splitters for which we obtain the following practical results: the FILO strategy performs better than the FIFO strategy, in the case of a one letter alphabet, the practical complexity in the FILO case never exceeds a linear one and our implementation is more efficient than the minimization algorithm of the FSM tool. This implementation is being integrated in a finite automata library, the Dash library. Thus, we present an efficient manner to manipulate automata by using canonical minimal automata.
15;Claire Pagetti;Manuel Baclet;Around Hopcroft’s Algorithm;In this paper, a reflection is made on an indeterminism inherent to Hopcroft’s minimization algorithm: the splitter choice. We have implemented two natural policies (FIFO and FILO) for managing the set of splitters for which we obtain the following practical results: the FILO strategy performs better than the FIFO strategy, in the case of a one letter alphabet, the practical complexity in the FILO case never exceeds a linear one and our implementation is more efficient than the minimization algorithm of the FSM tool. This implementation is being integrated in a finite automata library, the Dash library. Thus, we present an efficient manner to manipulate automata by using canonical minimal automata.
15;F. Nicart;J. -M. Champarnaud, T. Csáki, T. Gaál, A. Kempe;Multi-tape Automata with Symbol Classes;We propose a new model of finite state machine: multi-tape automata with symbol classes and identity and non-identity constraints (in short MASCIN). This model generalizes both classical single or multi-tape machines, and machines with extended alphabet. We define this model in terms of a constraint satisfaction problem and discuss a problem occurring when projection is used on the model. Finally, we describe its implementation and results of a performance test.
15;J. -M. Champarnaud;F. Nicart, T. Csáki, T. Gaál, A. Kempe;Multi-tape Automata with Symbol Classes;We propose a new model of finite state machine: multi-tape automata with symbol classes and identity and non-identity constraints (in short MASCIN). This model generalizes both classical single or multi-tape machines, and machines with extended alphabet. We define this model in terms of a constraint satisfaction problem and discuss a problem occurring when projection is used on the model. Finally, we describe its implementation and results of a performance test.
15;T. Csáki;F. Nicart, J. -M. Champarnaud, T. Gaál, A. Kempe;Multi-tape Automata with Symbol Classes;We propose a new model of finite state machine: multi-tape automata with symbol classes and identity and non-identity constraints (in short MASCIN). This model generalizes both classical single or multi-tape machines, and machines with extended alphabet. We define this model in terms of a constraint satisfaction problem and discuss a problem occurring when projection is used on the model. Finally, we describe its implementation and results of a performance test.
15;T. Gaál;F. Nicart, J. -M. Champarnaud, T. Csáki, A. Kempe;Multi-tape Automata with Symbol Classes;We propose a new model of finite state machine: multi-tape automata with symbol classes and identity and non-identity constraints (in short MASCIN). This model generalizes both classical single or multi-tape machines, and machines with extended alphabet. We define this model in terms of a constraint satisfaction problem and discuss a problem occurring when projection is used on the model. Finally, we describe its implementation and results of a performance test.
15;A. Kempe;F. Nicart, J. -M. Champarnaud, T. Csáki, T. Gaál;Multi-tape Automata with Symbol Classes;We propose a new model of finite state machine: multi-tape automata with symbol classes and identity and non-identity constraints (in short MASCIN). This model generalizes both classical single or multi-tape machines, and machines with extended alphabet. We define this model in terms of a constraint satisfaction problem and discuss a problem occurring when projection is used on the model. Finally, we describe its implementation and results of a performance test.
15;Corinna Cortes;Mehryar Mohri, Ashish Rastogi;On the Computation of Some Standard Distances Between Probabilistic Automata;The problem of the computation of a distance between two probabilistic automata arises in a variety of statistical learning problems. This paper presents an exhaustive analysis of the problem of computing the Lp distance between two automata. We give efficient exact and approximate algorithms for computing these distances for p even and prove the problem to be NP-hard for all odd values of p, thereby completing previously known hardness results. We also give an efficient algorithm for computing the Hellinger distance between unambiguous probabilistic automata. Our results include a general algorithm for the computation of the norm of an unambiguous probabilistic automaton based on a monoid morphism and efficient algorithms for the specific case of the computation of the Lp norm. Finally, we also describe an efficient algorithm for testing the equivalence of two arbitrary probabilistic automata A1 and A2 based on Schützenberger’s standardization with a running time complexity of O(|Σ| (|A1| + |A2|)3), a significant improvement over the previously best algorithm reported for this problem.
15;Mehryar Mohri;Corinna Cortes, Ashish Rastogi;On the Computation of Some Standard Distances Between Probabilistic Automata;The problem of the computation of a distance between two probabilistic automata arises in a variety of statistical learning problems. This paper presents an exhaustive analysis of the problem of computing the Lp distance between two automata. We give efficient exact and approximate algorithms for computing these distances for p even and prove the problem to be NP-hard for all odd values of p, thereby completing previously known hardness results. We also give an efficient algorithm for computing the Hellinger distance between unambiguous probabilistic automata. Our results include a general algorithm for the computation of the norm of an unambiguous probabilistic automaton based on a monoid morphism and efficient algorithms for the specific case of the computation of the Lp norm. Finally, we also describe an efficient algorithm for testing the equivalence of two arbitrary probabilistic automata A1 and A2 based on Schützenberger’s standardization with a running time complexity of O(|Σ| (|A1| + |A2|)3), a significant improvement over the previously best algorithm reported for this problem.
15;Ashish Rastogi;Corinna Cortes, Mehryar Mohri;On the Computation of Some Standard Distances Between Probabilistic Automata;The problem of the computation of a distance between two probabilistic automata arises in a variety of statistical learning problems. This paper presents an exhaustive analysis of the problem of computing the Lp distance between two automata. We give efficient exact and approximate algorithms for computing these distances for p even and prove the problem to be NP-hard for all odd values of p, thereby completing previously known hardness results. We also give an efficient algorithm for computing the Hellinger distance between unambiguous probabilistic automata. Our results include a general algorithm for the computation of the norm of an unambiguous probabilistic automaton based on a monoid morphism and efficient algorithms for the specific case of the computation of the Lp norm. Finally, we also describe an efficient algorithm for testing the equivalence of two arbitrary probabilistic automata A1 and A2 based on Schützenberger’s standardization with a running time complexity of O(|Σ| (|A1| + |A2|)3), a significant improvement over the previously best algorithm reported for this problem.
15;Andreas Maletti;;Does o-Substitution Preserve Recognizability?;Substitution operations on tree series are at the basis of systems of equations (over tree series) and tree series transducers. Tree series transducers seem to be an interesting transformation device in syntactic pattern matching. In this contribution, it is shown that o-substitution preserves recognizable tree series provided that the target tree series is linear and the semiring is idempotent, commutative, and continuous. This result is applied to prove that the range of the o-t-ts transformation computed by a linear recognizable tree series transducer is pointwise recognizable.
15;H. Messerschmidt;F. Mráz, F. Otto, M. Plátek;Correctness Preservation and Complexity of Simple RL-Automata;Analysis by reduction is a method used in linguistics for checking the correctness of sentences of natural languages. This method can be modelled by restarting automata. Here we study a new type of restarting automaton, the so-called t-sRL-automaton, which is an RL-automaton that is rather restricted in that it has a window of size 1 only, and that it works under a minimal acceptance condition. On the other hand, it is allowed to perform up to t rewrite (that is, delete) steps per cycle. We study the correctness preservation of these automata on the one hand, and the complexity of these automata on the other hand, establishing a complexity measure that is based on the description of t-sRL-automata in terms of so-called meta-instructions. We present a hierarchy result and we show that the correctness preserving nondeterministic t-sRL-automata are not stronger than the deterministic t-sRL-automata.
15;F. Mráz;H. Messerschmidt, F. Otto, M. Plátek;Correctness Preservation and Complexity of Simple RL-Automata;Analysis by reduction is a method used in linguistics for checking the correctness of sentences of natural languages. This method can be modelled by restarting automata. Here we study a new type of restarting automaton, the so-called t-sRL-automaton, which is an RL-automaton that is rather restricted in that it has a window of size 1 only, and that it works under a minimal acceptance condition. On the other hand, it is allowed to perform up to t rewrite (that is, delete) steps per cycle. We study the correctness preservation of these automata on the one hand, and the complexity of these automata on the other hand, establishing a complexity measure that is based on the description of t-sRL-automata in terms of so-called meta-instructions. We present a hierarchy result and we show that the correctness preserving nondeterministic t-sRL-automata are not stronger than the deterministic t-sRL-automata.
15;F. Otto;H. Messerschmidt, F. Mráz, M. Plátek;Correctness Preservation and Complexity of Simple RL-Automata;Analysis by reduction is a method used in linguistics for checking the correctness of sentences of natural languages. This method can be modelled by restarting automata. Here we study a new type of restarting automaton, the so-called t-sRL-automaton, which is an RL-automaton that is rather restricted in that it has a window of size 1 only, and that it works under a minimal acceptance condition. On the other hand, it is allowed to perform up to t rewrite (that is, delete) steps per cycle. We study the correctness preservation of these automata on the one hand, and the complexity of these automata on the other hand, establishing a complexity measure that is based on the description of t-sRL-automata in terms of so-called meta-instructions. We present a hierarchy result and we show that the correctness preserving nondeterministic t-sRL-automata are not stronger than the deterministic t-sRL-automata.
15;M. Plátek;H. Messerschmidt, F. Mráz, F. Otto;Correctness Preservation and Complexity of Simple RL-Automata;Analysis by reduction is a method used in linguistics for checking the correctness of sentences of natural languages. This method can be modelled by restarting automata. Here we study a new type of restarting automaton, the so-called t-sRL-automaton, which is an RL-automaton that is rather restricted in that it has a window of size 1 only, and that it works under a minimal acceptance condition. On the other hand, it is allowed to perform up to t rewrite (that is, delete) steps per cycle. We study the correctness preservation of these automata on the one hand, and the complexity of these automata on the other hand, establishing a complexity measure that is based on the description of t-sRL-automata in terms of so-called meta-instructions. We present a hierarchy result and we show that the correctness preserving nondeterministic t-sRL-automata are not stronger than the deterministic t-sRL-automata.
15;Parosh Aziz Abdulla;Lisa Kaati, Johanna Högberg;Bisimulation Minimization of Tree Automata;We extend an algorithm by Paige and Tarjan that solves the coarsest stable refinement problem to the domain of trees. The algorithm is used to minimize non-deterministic tree automata (NTA) with respect to bisimulation. We show that our algorithm has an overall complexity of \(O(\hat{r}m \log n)\), where \(\hat{r}\) is the maximum rank of the input alphabet, m is the total size of the transition table, and n is the number of states.
15;Lisa Kaati;Parosh Aziz Abdulla, Johanna Högberg;Bisimulation Minimization of Tree Automata;We extend an algorithm by Paige and Tarjan that solves the coarsest stable refinement problem to the domain of trees. The algorithm is used to minimize non-deterministic tree automata (NTA) with respect to bisimulation. We show that our algorithm has an overall complexity of \(O(\hat{r}m \log n)\), where \(\hat{r}\) is the maximum rank of the input alphabet, m is the total size of the transition table, and n is the number of states.
15;Johanna Högberg;Parosh Aziz Abdulla, Lisa Kaati;Bisimulation Minimization of Tree Automata;We extend an algorithm by Paige and Tarjan that solves the coarsest stable refinement problem to the domain of trees. The algorithm is used to minimize non-deterministic tree automata (NTA) with respect to bisimulation. We show that our algorithm has an overall complexity of \(O(\hat{r}m \log n)\), where \(\hat{r}\) is the maximum rank of the input alphabet, m is the total size of the transition table, and n is the number of states.
15;Jens Glöckler;;Forgetting Automata and Unary Languages;We consider forgetting automata, i.e., linear bounded automata which can only use the operations ‘move’, ‘erase’ (rewrite with a blank symbol) and ‘delete’ (remove completely). A classification of the families of languages corresponding to the possible combinations of operations has been given in [1], here we address some of the problems left open. Furthermore the unary case is being investigated.
15;Hing Leung;;Structurally Unambiguous Finite Automata;We define a structurally unambiguous finite automaton (SUFA) to be a nondeterministic finite automaton (NFA) with one starting state q0 such that for all input strings w and for any state q, there is at most one path from q0 to q that consumes w. The definition of SUFA differs from the usual definition of an unambiguous finite automaton (UFA) in that the new definition is defined in terms of the transition logic of the finite automaton, and is independent of the choice of final states. We show that SUFA can be exponentially more succinct in the number of states than UFA and MDFA (deterministic finite automata with multiple initial states). Some interesting examples of SUFA are given. We argue that SUFA is a meaningful concept, and can have practical importance as it can implemented efficiently on synchronous models of parallel computation.
16;Rūsiņš Freivalds;;Languages Recognizable by Quantum Finite Automata;There are several nonequivalent definitions of quantum finite automata. Nearly all of them recognize only regular languages but not all regular languages. On the other hand, for all these definitions there is a result showing that there is a language l such that the size of the quantum automaton recognizing L is essentially smaller than the size of the minimal deterministic automaton recognizing L.
16;Jacques Sakarovitch;;The Language, the Expression, and the (Small) Automaton;This survey paper reviews the means that allow to go from one representation of the languages to the other and how, and to what extend, one can keep them small. Some emphasis is put on the comparison between the expressions that can be computed from a given automaton and on the construction of the derived term automaton of an expression.
16;Parosh Aziz Abdulla;Johann Deneux, Lisa Kaati, Marcus Nilsson;Minimization of Non-deterministic Automata with Large Alphabets;There has been several attempts over the years to solve the bisimulation minimization problem for finite automata. One of the most famous algorithms is the one suggested by Paige and Tarjan. The algorithm has a complexity of \(\mathcal O\)(m log n) where m is the number of edges and n is the number of states in the automaton. A bottleneck in the application of the algorithm is often the number of labels which may appear on the edges of the automaton. In this paper we adapt the Paige-Tarjan algorithm to the case where the labels are symbolically represented using Binary Decision Diagrams (BDDs). We show that our algorithm has an overall complexity of \({\mathcal O}(l \cdot m \cdot log{n})\) where ℓ is the size of the alphabet. This means that our algorithm will have the same worst case behavior as other algorithms. However, as shown by our prototype implementation, we get a vast improvement in performance due to the compact representation provided by the BDDs.
16;Johann Deneux;Parosh Aziz Abdulla, Lisa Kaati, Marcus Nilsson;Minimization of Non-deterministic Automata with Large Alphabets;There has been several attempts over the years to solve the bisimulation minimization problem for finite automata. One of the most famous algorithms is the one suggested by Paige and Tarjan. The algorithm has a complexity of \(\mathcal O\)(m log n) where m is the number of edges and n is the number of states in the automaton. A bottleneck in the application of the algorithm is often the number of labels which may appear on the edges of the automaton. In this paper we adapt the Paige-Tarjan algorithm to the case where the labels are symbolically represented using Binary Decision Diagrams (BDDs). We show that our algorithm has an overall complexity of \({\mathcal O}(l \cdot m \cdot log{n})\) where ℓ is the size of the alphabet. This means that our algorithm will have the same worst case behavior as other algorithms. However, as shown by our prototype implementation, we get a vast improvement in performance due to the compact representation provided by the BDDs.
16;Lisa Kaati;Parosh Aziz Abdulla, Johann Deneux, Marcus Nilsson;Minimization of Non-deterministic Automata with Large Alphabets;There has been several attempts over the years to solve the bisimulation minimization problem for finite automata. One of the most famous algorithms is the one suggested by Paige and Tarjan. The algorithm has a complexity of \(\mathcal O\)(m log n) where m is the number of edges and n is the number of states in the automaton. A bottleneck in the application of the algorithm is often the number of labels which may appear on the edges of the automaton. In this paper we adapt the Paige-Tarjan algorithm to the case where the labels are symbolically represented using Binary Decision Diagrams (BDDs). We show that our algorithm has an overall complexity of \({\mathcal O}(l \cdot m \cdot log{n})\) where ℓ is the size of the alphabet. This means that our algorithm will have the same worst case behavior as other algorithms. However, as shown by our prototype implementation, we get a vast improvement in performance due to the compact representation provided by the BDDs.
16;Marcus Nilsson;Parosh Aziz Abdulla, Johann Deneux, Lisa Kaati;Minimization of Non-deterministic Automata with Large Alphabets;There has been several attempts over the years to solve the bisimulation minimization problem for finite automata. One of the most famous algorithms is the one suggested by Paige and Tarjan. The algorithm has a complexity of \(\mathcal O\)(m log n) where m is the number of edges and n is the number of states in the automaton. A bottleneck in the application of the algorithm is often the number of labels which may appear on the edges of the automaton. In this paper we adapt the Paige-Tarjan algorithm to the case where the labels are symbolically represented using Binary Decision Diagrams (BDDs). We show that our algorithm has an overall complexity of \({\mathcal O}(l \cdot m \cdot log{n})\) where ℓ is the size of the alphabet. This means that our algorithm will have the same worst case behavior as other algorithms. However, as shown by our prototype implementation, we get a vast improvement in performance due to the compact representation provided by the BDDs.
16;Marcella Anselmo;Maria Madonia;Simulating Two-Dimensional Recognizability by Pushdown and Queue Automata ;The aim of this paper is to investigate sequential models to describe two-dimensional languages. The intent is to add more capabilities to 4NFA in order to encompass a wider class of languages. We show that any (tiling) recognizable language can be simulated by a 4NFA with an extra queue whose size is bounded by the minimum of the two dimensions of a picture. and that 2NFA (i.e. automata moving only in two directions) with an analogous queue are sufficient when the alphabet is unary. A special class of recognizable languages can be simulated also by 4-way pushdown automata with a stack of size bounded by the sum of the two dimensions of the picture. Such a class is also characterized by a recursive definition involving the operations of union, intersection and a new diagonal overlapping operation applied to languages recognized by 2NFA.
16;Maria Madonia;Marcella Anselmo;Simulating Two-Dimensional Recognizability by Pushdown and Queue Automata ;The aim of this paper is to investigate sequential models to describe two-dimensional languages. The intent is to add more capabilities to 4NFA in order to encompass a wider class of languages. We show that any (tiling) recognizable language can be simulated by a 4NFA with an extra queue whose size is bounded by the minimum of the two dimensions of a picture. and that 2NFA (i.e. automata moving only in two directions) with an analogous queue are sufficient when the alphabet is unary. A special class of recognizable languages can be simulated also by 4-way pushdown automata with a stack of size bounded by the sum of the two dimensions of the picture. Such a class is also characterized by a recursive definition involving the operations of union, intersection and a new diagonal overlapping operation applied to languages recognized by 2NFA.
16;Arnaud Bailly;Mireille Clerbout, Isabelle Simplot-Ryl;Component Composition Preserving Behavioural Contracts Based on Communication Traces;This paper investigates the compositional properties of reusable software components defined with explicit dependencies and behavioural contracts expressing rely-guarantee specifications in the form of communication traces. In this setting, connection of components through their matching ports is indeed compositional and yields a new component or composite that respects its constituents’ contracts. Thus the behaviour of the composite is computed from the behaviours of its constituents and is known to conform to the contracts without any new proof.
16;Mireille Clerbout;Arnaud Bailly, Isabelle Simplot-Ryl;Component Composition Preserving Behavioural Contracts Based on Communication Traces;This paper investigates the compositional properties of reusable software components defined with explicit dependencies and behavioural contracts expressing rely-guarantee specifications in the form of communication traces. In this setting, connection of components through their matching ports is indeed compositional and yields a new component or composite that respects its constituents’ contracts. Thus the behaviour of the composite is computed from the behaviours of its constituents and is known to conform to the contracts without any new proof.
16;Isabelle Simplot-Ryl;Arnaud Bailly, Mireille Clerbout;Component Composition Preserving Behavioural Contracts Based on Communication Traces;This paper investigates the compositional properties of reusable software components defined with explicit dependencies and behavioural contracts expressing rely-guarantee specifications in the form of communication traces. In this setting, connection of components through their matching ports is indeed compositional and yields a new component or composite that respects its constituents’ contracts. Thus the behaviour of the composite is computed from the behaviours of its constituents and is known to conform to the contracts without any new proof.
16;Miklós Bartha;;Strong Retiming Equivalence of Synchronous Schemes;Strong retiming equivalence is the join of two basic equivalence relations of synchronous schemes: strong equivalence and retiming equivalence, which play an important role in the optimization of synchronous systems. Each of these equivalences is characterized separately in an algebraic/category theoretic framework, and the characterization is carried over to the join of them. Tree-reducible schemes are introduced to facilitate the proof that strong retiming equivalence is decidable.
16;Cédric Bastien;Jurek Czyzowicz, Wojciech Fraczak, Wojciech Rytter;Prime Normal Form and Equivalence of Simple Grammars;A prefix-free language is a prime if it cannot be decomposed into a concatenation of two prefix-free languages. We show that we can check in polynomial time if a language generated by a simple context-free grammar is a prime. Our algorithm computes a canonical representation of a simple language, converting its arbitrary simple grammar into Prime Normal Form (PNF). a simple grammar is in PNF if all its nonterminals define primes. We also improve the complexity of testing the equivalence of simple grammars. The best previously known algorithm for this problem worked in O(n13) time. We improve it to O(n7 log2n) and O(n5 polylog v) deterministic time, and O(n4 polylog n) randomized time, where n is the total size of the grammars involved, and v is the length of a shortest string derivable from a nonterminal, maximized over all nonterminals. Our improvement is based on a version of Caucal’s algorithm from [1].
16;Jurek Czyzowicz;Cédric Bastien, Wojciech Fraczak, Wojciech Rytter;Prime Normal Form and Equivalence of Simple Grammars;A prefix-free language is a prime if it cannot be decomposed into a concatenation of two prefix-free languages. We show that we can check in polynomial time if a language generated by a simple context-free grammar is a prime. Our algorithm computes a canonical representation of a simple language, converting its arbitrary simple grammar into Prime Normal Form (PNF). a simple grammar is in PNF if all its nonterminals define primes. We also improve the complexity of testing the equivalence of simple grammars. The best previously known algorithm for this problem worked in O(n13) time. We improve it to O(n7 log2n) and O(n5 polylog v) deterministic time, and O(n4 polylog n) randomized time, where n is the total size of the grammars involved, and v is the length of a shortest string derivable from a nonterminal, maximized over all nonterminals. Our improvement is based on a version of Caucal’s algorithm from [1].
16;Wojciech Fraczak;Cédric Bastien, Jurek Czyzowicz, Wojciech Rytter;Prime Normal Form and Equivalence of Simple Grammars;A prefix-free language is a prime if it cannot be decomposed into a concatenation of two prefix-free languages. We show that we can check in polynomial time if a language generated by a simple context-free grammar is a prime. Our algorithm computes a canonical representation of a simple language, converting its arbitrary simple grammar into Prime Normal Form (PNF). a simple grammar is in PNF if all its nonterminals define primes. We also improve the complexity of testing the equivalence of simple grammars. The best previously known algorithm for this problem worked in O(n13) time. We improve it to O(n7 log2n) and O(n5 polylog v) deterministic time, and O(n4 polylog n) randomized time, where n is the total size of the grammars involved, and v is the length of a shortest string derivable from a nonterminal, maximized over all nonterminals. Our improvement is based on a version of Caucal’s algorithm from [1].
16;Wojciech Rytter;Cédric Bastien, Jurek Czyzowicz, Wojciech Fraczak;Prime Normal Form and Equivalence of Simple Grammars;A prefix-free language is a prime if it cannot be decomposed into a concatenation of two prefix-free languages. We show that we can check in polynomial time if a language generated by a simple context-free grammar is a prime. Our algorithm computes a canonical representation of a simple language, converting its arbitrary simple grammar into Prime Normal Form (PNF). a simple grammar is in PNF if all its nonterminals define primes. We also improve the complexity of testing the equivalence of simple grammars. The best previously known algorithm for this problem worked in O(n13) time. We improve it to O(n7 log2n) and O(n5 polylog v) deterministic time, and O(n4 polylog n) randomized time, where n is the total size of the grammars involved, and v is the length of a shortest string derivable from a nonterminal, maximized over all nonterminals. Our improvement is based on a version of Caucal’s algorithm from [1].
16;Cezar Câmpeanu;Andrei Păun, Jason R. Smith;An Incremental Algorithm for Constructing Minimal Deterministic Finite Cover Automata;We present a fast incremental algorithm for constructing minimal DFCA for a given language. Since it was shown that the DFCA for a language L can have less states than the DFA for L, this technique seems to be the best choice for incrementally building the automaton for a large language, especially when the number of states in the DFCA is significantly less than the number of states in the corresponding minimal DFA. We have implemented the proposed algorithm and have tested it against the best known DFCA minimization technique.
16;Andrei Păun;Cezar Câmpeanu, Jason R. Smith;An Incremental Algorithm for Constructing Minimal Deterministic Finite Cover Automata;We present a fast incremental algorithm for constructing minimal DFCA for a given language. Since it was shown that the DFCA for a language L can have less states than the DFA for L, this technique seems to be the best choice for incrementally building the automaton for a large language, especially when the number of states in the DFCA is significantly less than the number of states in the corresponding minimal DFA. We have implemented the proposed algorithm and have tested it against the best known DFCA minimization technique.
16;Jason R. Smith;Cezar Câmpeanu, Andrei Păun;An Incremental Algorithm for Constructing Minimal Deterministic Finite Cover Automata;We present a fast incremental algorithm for constructing minimal DFCA for a given language. Since it was shown that the DFCA for a language L can have less states than the DFA for L, this technique seems to be the best choice for incrementally building the automaton for a large language, especially when the number of states in the DFCA is significantly less than the number of states in the corresponding minimal DFA. We have implemented the proposed algorithm and have tested it against the best known DFCA minimization technique.
16;Antonio Cano;Pedro García;Finite Automata and Unions of Regular Patterns with Bounded Constant Segments;The class of unbounded unions of regular pattern languages with bounded constant segments is identifiable from positive data in the limit [1]. Otherwise, no efficient algorithm that performs the inference of this class of languages is known. We propose a solution to this problem using the existing connexion between the positive variety of languages of dot depth 1/2, \({\mathcal LJ}^+\) [2] and the class of unbounded union of pattern languages \({\mathcal RP}^+{\mathcal L}\).
16;Pedro García;Antonio Cano;Finite Automata and Unions of Regular Patterns with Bounded Constant Segments;The class of unbounded unions of regular pattern languages with bounded constant segments is identifiable from positive data in the limit [1]. Otherwise, no efficient algorithm that performs the inference of this class of languages is known. We propose a solution to this problem using the existing connexion between the positive variety of languages of dot depth 1/2, \({\mathcal LJ}^+\) [2] and the class of unbounded union of pattern languages \({\mathcal RP}^+{\mathcal L}\).
16;Thomas Claveirole;Sylvain Lombardy, Sarah O’Connor, Louis-Noël Pouchet, Jacques Sakarovitch;Inside Vaucanson;This paper presents some features of the Vaucanson platform. We describe some original algorithms on weighted automata and transducers (computation of the quotient, conversion of a regular expression into a weighted automaton, and composition). We explain how complex declarations due to the generic programming are masked from the user and finally we present a proposal for an XML format that allows implicit descriptions for simple types of automata.
16;Sylvain Lombardy;Thomas Claveirole, Sarah O’Connor, Louis-Noël Pouchet, Jacques Sakarovitch;Inside Vaucanson;This paper presents some features of the Vaucanson platform. We describe some original algorithms on weighted automata and transducers (computation of the quotient, conversion of a regular expression into a weighted automaton, and composition). We explain how complex declarations due to the generic programming are masked from the user and finally we present a proposal for an XML format that allows implicit descriptions for simple types of automata.
16;Sarah O’Connor;Thomas Claveirole, Sylvain Lombardy, Louis-Noël Pouchet, Jacques Sakarovitch;Inside Vaucanson;This paper presents some features of the Vaucanson platform. We describe some original algorithms on weighted automata and transducers (computation of the quotient, conversion of a regular expression into a weighted automaton, and composition). We explain how complex declarations due to the generic programming are masked from the user and finally we present a proposal for an XML format that allows implicit descriptions for simple types of automata.
16;Louis-Noël Pouchet;Thomas Claveirole, Sylvain Lombardy, Sarah O’Connor, Jacques Sakarovitch;Inside Vaucanson;This paper presents some features of the Vaucanson platform. We describe some original algorithms on weighted automata and transducers (computation of the quotient, conversion of a regular expression into a weighted automaton, and composition). We explain how complex declarations due to the generic programming are masked from the user and finally we present a proposal for an XML format that allows implicit descriptions for simple types of automata.
16;Jacques Sakarovitch;Thomas Claveirole, Sylvain Lombardy, Sarah O’Connor, Louis-Noël Pouchet;Inside Vaucanson;This paper presents some features of the Vaucanson platform. We describe some original algorithms on weighted automata and transducers (computation of the quotient, conversion of a regular expression into a weighted automaton, and composition). We explain how complex declarations due to the generic programming are masked from the user and finally we present a proposal for an XML format that allows implicit descriptions for simple types of automata.
16;Akio Fujiyoshi;Ikuo Kawaharada;Deterministic Recognition of Trees Accepted by a Linear Pushdown Tree Automaton;In this paper, a deterministic recognition algorithm for the class of tree languages accepted by (nondeterministic) linear pushdown tree automata (L-PDTAs) is proposed. L-PDTAs accept an important class of tree languages since the class of their yield languages coincides with the class of yield languages generated by tree adjoining grammars (TAGs). The proposed algorithm is obtained by combining a bottom-up parsing procedure on trees with the CKY (Cocke-Kasami-Younger) algorithm. The running time of the algorithm is O(n4), where n is the number of nodes of an input tree.
16;Ikuo Kawaharada;Akio Fujiyoshi;Deterministic Recognition of Trees Accepted by a Linear Pushdown Tree Automaton;In this paper, a deterministic recognition algorithm for the class of tree languages accepted by (nondeterministic) linear pushdown tree automata (L-PDTAs) is proposed. L-PDTAs accept an important class of tree languages since the class of their yield languages coincides with the class of yield languages generated by tree adjoining grammars (TAGs). The proposed algorithm is obtained by combining a bottom-up parsing procedure on trees with the CKY (Cocke-Kasami-Younger) algorithm. The running time of the algorithm is O(n4), where n is the number of nodes of an input tree.
16;Yo-Sub Han;Derick Wood;Shorter Regular Expressions from Finite-State Automata;We consider the use of state elimination to construct shorter regular expressions from finite-state automata. Although state elimination is an intuitive method for computing regular expressions from finite-state automata, the resulting regular expressions are often very long and complicated. We examine the minimization of finite-state automata to obtain shorter expressions first. Then, we introduce vertical chopping based on bridge states and horizontal chopping based on the structural properties of given finite-state automata. We prove that we should not eliminate bridge states until we eliminate all non-bridge states to obtain shorter regular expressions. In addition, we suggest heuristics for state elimination that lead to shorter regular expressions based on vertical chopping and horizontal chopping.
16;Derick Wood;Yo-Sub Han;Shorter Regular Expressions from Finite-State Automata;We consider the use of state elimination to construct shorter regular expressions from finite-state automata. Although state elimination is an intuitive method for computing regular expressions from finite-state automata, the resulting regular expressions are often very long and complicated. We examine the minimization of finite-state automata to obtain shorter expressions first. Then, we introduce vertical chopping based on bridge states and horizontal chopping based on the structural properties of given finite-state automata. We prove that we should not eliminate bridge states until we eliminate all non-bridge states to obtain shorter regular expressions. In addition, we suggest heuristics for state elimination that lead to shorter regular expressions based on vertical chopping and horizontal chopping.
16;Johanna Högberg;;Wind in the Willows – Generating Music by Means of Tree Transducers;We implement a rule-based system for algorithmic composition. This system, that we call Willow, resides in the Treebag environment and consists of a sequence of formal devices, familiar from the field of tree grammars and tree transducers. Since these devices are well studied, we can apply known results to derive the descriptive complexity of the system as a whole.
16;Oscar H. Ibarra;Hsu-Chun Yen;On Deterministic Catalytic Systems;We look at a 1-membrane catalytic P system with evolution rules of the form Ca →Cv or a →v, where C is a catalyst, a is a noncatalyst symbol, and v is a (possibly null) string representing a multiset of noncatalyst symbols. (Note that we are only interested in the multiplicities of the symbols.) A catalytic system can be regarded as a language acceptor in the following sense. Given an input alphabet Σ consisting of noncatalyst symbols, the system starts with an initial configuration wz, where w is a fixed string of catalysts and noncatalysts not containing any symbol in z, and \(z = a_1^{n_1} \ldots a_k^{n_k}\) for some nonnegative integers n1, ..., nk, with { a1 ...ak } ⊆ ∑. At each step, a maximal multiset of rules is nondeterministically selected and applied in parallel to the current configuration to derive the next configuration (note that the next configuration is not unique, in general). The string z is accepted if the system eventually halts.
16;Hsu-Chun Yen;Oscar H. Ibarra;On Deterministic Catalytic Systems;We look at a 1-membrane catalytic P system with evolution rules of the form Ca →Cv or a →v, where C is a catalyst, a is a noncatalyst symbol, and v is a (possibly null) string representing a multiset of noncatalyst symbols. (Note that we are only interested in the multiplicities of the symbols.) A catalytic system can be regarded as a language acceptor in the following sense. Given an input alphabet Σ consisting of noncatalyst symbols, the system starts with an initial configuration wz, where w is a fixed string of catalysts and noncatalysts not containing any symbol in z, and \(z = a_1^{n_1} \ldots a_k^{n_k}\) for some nonnegative integers n1, ..., nk, with { a1 ...ak } ⊆ ∑. At each step, a maximal multiset of rules is nondeterministically selected and applied in parallel to the current configuration to derive the next configuration (note that the next configuration is not unique, in general). The string z is accepted if the system eventually halts.
16;Tomasz Jurdziński;Friedrich Otto;Restricting the Use of Auxiliary Symbols for Restarting Automata;The most general models of restarting automata make use of auxiliary symbols in their rewrite operations. Here we put restrictions on the way in which restarting automata use auxiliary symbols, and we investigate the influence of these restrictions on their expressive power. In fact, we consider two types of restrictions. First, we consider the number of auxiliary symbols in the tape alphabet of a restarting automaton as a measure of its descriptional complexity. Secondly, we consider the number of occurrences of auxiliary symbols on the tape as a dynamic complexity measure. We establish some lower and upper bounds with respect to these complexity measures concerning the ability of restarting automata to recognize the (deterministic) context-free languages and some of their subclasses.
16;Friedrich Otto;Tomasz Jurdziński;Restricting the Use of Auxiliary Symbols for Restarting Automata;The most general models of restarting automata make use of auxiliary symbols in their rewrite operations. Here we put restrictions on the way in which restarting automata use auxiliary symbols, and we investigate the influence of these restrictions on their expressive power. In fact, we consider two types of restrictions. First, we consider the number of auxiliary symbols in the tape alphabet of a restarting automaton as a measure of its descriptional complexity. Secondly, we consider the number of occurrences of auxiliary symbols on the tape as a dynamic complexity measure. We establish some lower and upper bounds with respect to these complexity measures concerning the ability of restarting automata to recognize the (deterministic) context-free languages and some of their subclasses.
16;André Kempe;Jean-Marc Champarnaud, Jason Eisner, Franck Guingne, Florent Nicart;A Class of Rational n-WFSM Auto-intersections;Weighted finite-state machines with n tapes describe n-ary rational string relations. The join n-ary relation is very important in applications. It is shown how to compute it via a more simple operation, the auto-intersection. Join and auto-intersection generally do not preserve rationality. We define a class of triples 〈A, i, j〉 such that the auto-intersection of the machine A on tapes i and j can be computed by a delay-based algorithm. We point out how to extend this class and hope that it is sufficient for many practical applications.
16;Jean-Marc Champarnaud;André Kempe, Jason Eisner, Franck Guingne, Florent Nicart;A Class of Rational n-WFSM Auto-intersections;Weighted finite-state machines with n tapes describe n-ary rational string relations. The join n-ary relation is very important in applications. It is shown how to compute it via a more simple operation, the auto-intersection. Join and auto-intersection generally do not preserve rationality. We define a class of triples 〈A, i, j〉 such that the auto-intersection of the machine A on tapes i and j can be computed by a delay-based algorithm. We point out how to extend this class and hope that it is sufficient for many practical applications.
16;Jason Eisner;André Kempe, Jean-Marc Champarnaud, Franck Guingne, Florent Nicart;A Class of Rational n-WFSM Auto-intersections;Weighted finite-state machines with n tapes describe n-ary rational string relations. The join n-ary relation is very important in applications. It is shown how to compute it via a more simple operation, the auto-intersection. Join and auto-intersection generally do not preserve rationality. We define a class of triples 〈A, i, j〉 such that the auto-intersection of the machine A on tapes i and j can be computed by a delay-based algorithm. We point out how to extend this class and hope that it is sufficient for many practical applications.
16;Franck Guingne;André Kempe, Jean-Marc Champarnaud, Jason Eisner, Florent Nicart;A Class of Rational n-WFSM Auto-intersections;Weighted finite-state machines with n tapes describe n-ary rational string relations. The join n-ary relation is very important in applications. It is shown how to compute it via a more simple operation, the auto-intersection. Join and auto-intersection generally do not preserve rationality. We define a class of triples 〈A, i, j〉 such that the auto-intersection of the machine A on tapes i and j can be computed by a delay-based algorithm. We point out how to extend this class and hope that it is sufficient for many practical applications.
16;Florent Nicart;André Kempe, Jean-Marc Champarnaud, Jason Eisner, Franck Guingne;A Class of Rational n-WFSM Auto-intersections;Weighted finite-state machines with n tapes describe n-ary rational string relations. The join n-ary relation is very important in applications. It is shown how to compute it via a more simple operation, the auto-intersection. Join and auto-intersection generally do not preserve rationality. We define a class of triples 〈A, i, j〉 such that the auto-intersection of the machine A on tapes i and j can be computed by a delay-based algorithm. We point out how to extend this class and hope that it is sufficient for many practical applications.
16;Joachim Klein;Christel Baier;Experiments with Deterministic ω-Automata for Formulas of Linear Temporal Logic;This paper addresses the problem of generating deterministic ω-automata for formulas of linear temporal logic, which can be solved by applying well-known algorithms to construct a nondeterministic Büchi automaton for the given formula on which we then apply a determinization algorithm. We study here in detail Safra’s determinization algorithm, present several heuristics that attempt to decrease the size of the resulting automata and report on experimental results.
16;Christel Baier;Joachim Klein;Experiments with Deterministic ω-Automata for Formulas of Linear Temporal Logic;This paper addresses the problem of generating deterministic ω-automata for formulas of linear temporal logic, which can be solved by applying well-known algorithms to construct a nondeterministic Büchi automaton for the given formula on which we then apply a determinization algorithm. We study here in detail Safra’s determinization algorithm, present several heuristics that attempt to decrease the size of the resulting automata and report on experimental results.
16;Louis Latour;;Computing Affine Hulls over ${\mathbb Q}$ and ${\mathbb Z}$ from Sets Represented by Number Decision Diagrams;Number Decision Diagrams (NDD) are finite automata representing sets of integer vectors and have recently been proposed as an efficient data structure for representing sets definable in Presburger arithmetic. In this context, some work has been done in order to generate formulas or sets of generators from the NDDs. Taking another step in this direction, this paper present algorithms that takes as input an NDD and computes the affine hull over \({\mathbb Q}\) or over \({\mathbb Z}\) of the set represented by the NDD, i.e., the smallest set defined by a conjunction of equations or by a conjunction of equations and congruence relations that includes the set represented by the NDD. Our algorithms run in time \({\mathcal O}(|{\mathcal Q}| \cdot |{\Sigma_r^n}| \cdot n )\) and \({\mathcal O}(|{\mathcal Q}^3| \cdot |{\Sigma_r^n}| \cdot {n^3} )\) respectively, where n is the number of components of the vectors represented by the NDD, and |Q| and Σ\(_{r}^{n}\) are the number of states and the alphabet of the NDD. On a prototype implementation, the computations of affine hulls of NDDs with more than 100000 states are done in seconds.
16;Markus Lohrey;Sebastian Maneth;Tree Automata and XPath on Compressed Trees;The complexity of various membership problems for tree automata on compressed trees is analyzed. Two compressed representations are considered: dags, which allow to share identical subtrees in a tree, and straight-line context-free tree grammars, which moreover allow to share identical intermediate parts of a tree. Several completeness results for the classes NL, P, and PSPACE are obtained. Finally, the complexity of the XPath evaluation problem on trees that are compressed via straight-line context-free tree grammars is investigated.
16;Sebastian Maneth;Markus Lohrey;Tree Automata and XPath on Compressed Trees;The complexity of various membership problems for tree automata on compressed trees is analyzed. Two compressed representations are considered: dags, which allow to share identical subtrees in a tree, and straight-line context-free tree grammars, which moreover allow to share identical intermediate parts of a tree. Several completeness results for the classes NL, P, and PSPACE are obtained. Finally, the complexity of the XPath evaluation problem on trees that are compressed via straight-line context-free tree grammars is investigated.
17;Thomas A. Henzinger;;Automata for Specifying Component Interfaces;R. Alur, T. A. Henzinger, O. Kupferman, and M.Y. Vardi. Alternating refinement relations. In CONCUR 98: Concurrency Theory, Lecture Notes in Computer Science 1466, pages 163–178. Springer-Verlag, 1998.
17;Juhani Karhumäki;;Automata on Words;Unable to display preview. Download preview PDF.
17;Nico Wallmeier;Patrick Hütten, Wolfgang Thomas;Symbolic Synthesis of Finite-State Controllers for Request-Response Specifications;We present a method to solve certain infinite games over finite state spaces and apply this for the automatic synthesis of finitestate controllers. A lift-controller problem serves as an example for which the implementation of our algorithm has been tested. The specifications consist of safety conditions and so-called “request-response-conditions” (which have the form “after visiting a state of P later a state of R is visited”). Many real-life problems can be modeled in this framework. We sketch the theoretical solution which synthesizes a finite-state controller for satisfiable specifications. The core of the implementation is a convenient input language (based on enriched Boolean logic) and a realization of the abstract algorithms with OBDD’s (ordered binary decision diagrams).
17;Patrick Hütten;Nico Wallmeier, Wolfgang Thomas;Symbolic Synthesis of Finite-State Controllers for Request-Response Specifications;We present a method to solve certain infinite games over finite state spaces and apply this for the automatic synthesis of finitestate controllers. A lift-controller problem serves as an example for which the implementation of our algorithm has been tested. The specifications consist of safety conditions and so-called “request-response-conditions” (which have the form “after visiting a state of P later a state of R is visited”). Many real-life problems can be modeled in this framework. We sketch the theoretical solution which synthesizes a finite-state controller for satisfiable specifications. The core of the implementation is a convenient input language (based on enriched Boolean logic) and a realization of the abstract algorithms with OBDD’s (ordered binary decision diagrams).
17;Wolfgang Thomas;Nico Wallmeier, Patrick Hütten;Symbolic Synthesis of Finite-State Controllers for Request-Response Specifications;We present a method to solve certain infinite games over finite state spaces and apply this for the automatic synthesis of finitestate controllers. A lift-controller problem serves as an example for which the implementation of our algorithm has been tested. The specifications consist of safety conditions and so-called “request-response-conditions” (which have the form “after visiting a state of P later a state of R is visited”). Many real-life problems can be modeled in this framework. We sketch the theoretical solution which synthesizes a finite-state controller for satisfiable specifications. The core of the implementation is a convenient input language (based on enriched Boolean logic) and a realization of the abstract algorithms with OBDD’s (ordered binary decision diagrams).
17;Farn Wang;Hsu-Chun Yen;Timing Parameter Characterization of Real-Time Systems;We investigate the problem of characterizing the solution spaces for timed automata augmented by unknown timing parameters (called timing parameter automata (TPA)). The main contribution of this paper is that we identify three non-trivial subclasses of TPAs, namely, upper-bound, lower-bound and bipartite TPAs, and analyze how hard it is to characterize the solution space. As it turns out, we are able to give complexity bounds for the sizes of the minimal (resp., maximal) elements which completely characterize the upward-closed (resp., downward-closed) solution spaces of upper-bound (resp., lower-bound) TPAs. For bipartite TPAs, it is shown that their solution spaces are not semilinear in general. We also extend our analysis to TPAs equipped with counters without zero-test capabilities.
17;Hsu-Chun Yen;Farn Wang;Timing Parameter Characterization of Real-Time Systems;We investigate the problem of characterizing the solution spaces for timed automata augmented by unknown timing parameters (called timing parameter automata (TPA)). The main contribution of this paper is that we identify three non-trivial subclasses of TPAs, namely, upper-bound, lower-bound and bipartite TPAs, and analyze how hard it is to characterize the solution space. As it turns out, we are able to give complexity bounds for the sizes of the minimal (resp., maximal) elements which completely characterize the upward-closed (resp., downward-closed) solution spaces of upper-bound (resp., lower-bound) TPAs. For bipartite TPAs, it is shown that their solution spaces are not semilinear in general. We also extend our analysis to TPAs equipped with counters without zero-test capabilities.
17;Carsten Fritz;;Constructing Büchi Automata from Linear Temporal Logic Using Simulation Relations for Alternating Büchi Automata;We present a new procedure for the translation of propositional linear-time temporal logic (LTL) formulas to equivalent nondeterministic Büchi automata. Our procedure is based on simulation relations for alternating Büchi automata. Whereas most of the procedures that have been described in the past compute simulation relations in the last step of the translation (after a nondeterministic Büchi automaton has already been constructed), our procedure computes simulation relations for alternating Büchi automata in an early stage and uses them in an on-the- fly fashion. This decreases the time and space consumption without sacrificing the potential of simulation relations.
17;Jean-Marc Champarnaud;Éric Laugerotte, Faissal Ouardi, Djelloul Ziadi;From Regular Weighted Expressions to Finite Automata;In this article we generalize the concepts of position automaton and ZPC structure to the regular \( \mathbb{K} \)-expressions. We show that the ZPC structure can be built in linear time in the size of the expression and that the associated position automaton can be deduced from it in quadratic time.
17;Éric Laugerotte;Jean-Marc Champarnaud, Faissal Ouardi, Djelloul Ziadi;From Regular Weighted Expressions to Finite Automata;In this article we generalize the concepts of position automaton and ZPC structure to the regular \( \mathbb{K} \)-expressions. We show that the ZPC structure can be built in linear time in the size of the expression and that the associated position automaton can be deduced from it in quadratic time.
17;Faissal Ouardi;Jean-Marc Champarnaud, Éric Laugerotte, Djelloul Ziadi;From Regular Weighted Expressions to Finite Automata;In this article we generalize the concepts of position automaton and ZPC structure to the regular \( \mathbb{K} \)-expressions. We show that the ZPC structure can be built in linear time in the size of the expression and that the associated position automaton can be deduced from it in quadratic time.
17;Djelloul Ziadi;Jean-Marc Champarnaud, Éric Laugerotte, Faissal Ouardi;From Regular Weighted Expressions to Finite Automata;In this article we generalize the concepts of position automaton and ZPC structure to the regular \( \mathbb{K} \)-expressions. We show that the ZPC structure can be built in linear time in the size of the expression and that the associated position automaton can be deduced from it in quadratic time.
17;Hellis Tamm;Esko Ukkonen;Bideterministic Automata and Minimal Representations of Regular Languages;Bideterministic automata are deterministic automata with the property of their reversal automata also being deterministic. It has been known that a bideterministic automaton is the minimal deterministic automaton accepting its language. This paper shows that any bideterministic automaton is the unique minimal automaton among all (including nondeterministic) automata accepting the same language. We also present a more general result that shows that under certain conditions a minimal deterministic automaton accepting some language or the reversal of the minimal deterministic automaton of the reversal language is a minimal automaton representation of the language. These conditions can be checked in polynomial time.
17;Esko Ukkonen;Hellis Tamm;Bideterministic Automata and Minimal Representations of Regular Languages;Bideterministic automata are deterministic automata with the property of their reversal automata also being deterministic. It has been known that a bideterministic automaton is the minimal deterministic automaton accepting its language. This paper shows that any bideterministic automaton is the unique minimal automaton among all (including nondeterministic) automata accepting the same language. We also present a more general result that shows that under certain conditions a minimal deterministic automaton accepting some language or the reversal of the minimal deterministic automaton of the reversal language is a minimal automaton representation of the language. These conditions can be checked in polynomial time.
17;Lynette van Zijl;;Succinct Descriptions of Regular Languages with Binary ⊕-NFAs;Champarnaud [1] analyzed the number of states obtained from a binary ⊕-NFA during the subset construction. We extend this work to an experimental analysis of the size of the minimal DFAs obtained from binary ⊕-NFAs.We then consider the number of distinct languages accepted by binary ⊕-NFAs, and compare that to Domaratzki’s results [2] for (traditional) binary NFAs. We also show that there are certain regular languages which are accepted by succinct ⊕-NFAs, but for which no succinct traditional NFA exists.
17;Cyril Allauzen;Mehryar Mohri;An Efficient Pre-determinization Algorithm;We present a general algorithm, pre-determinization, that makes an arbitrary weighted transducer over the tropical semiring or an arbitrary unambiguous weighted transducer over a cancellative commutative semiring determinizable by inserting in it transitions labeled with special symbols. After determinization, the special symbols can be removed or replaced with ε-transitions. The resulting transducer can be significantly more efficient to use. We report empirical results showing that our algorithm leads to a substantial speed-up in large-vocabulary speech recognition. Our pre-determinization algorithm makes use of an efficient algorithm for testing a general twins property, a sufficient condition for the determinizability of all weighted transducers over the tropical semiring and unambiguous weighted transducers over cancellative commutative semirings. It inserts new transitions just when needed to guarantee that the resulting transducer has the twins property and thus is determinizable. It also uses a single-source shortest-paths algorithm over the min-max semiring for carefully selecting the positions for insertion of new transitions to benefit from the subsequent application of determinization. These positions are proved to be optimal in a sense that we describe.
17;Mehryar Mohri;Cyril Allauzen;An Efficient Pre-determinization Algorithm;We present a general algorithm, pre-determinization, that makes an arbitrary weighted transducer over the tropical semiring or an arbitrary unambiguous weighted transducer over a cancellative commutative semiring determinizable by inserting in it transitions labeled with special symbols. After determinization, the special symbols can be removed or replaced with ε-transitions. The resulting transducer can be significantly more efficient to use. We report empirical results showing that our algorithm leads to a substantial speed-up in large-vocabulary speech recognition. Our pre-determinization algorithm makes use of an efficient algorithm for testing a general twins property, a sufficient condition for the determinizability of all weighted transducers over the tropical semiring and unambiguous weighted transducers over cancellative commutative semirings. It inserts new transitions just when needed to guarantee that the resulting transducer has the twins property and thus is determinizable. It also uses a single-source shortest-paths algorithm over the min-max semiring for carefully selecting the positions for insertion of new transitions to benefit from the subsequent application of determinization. These positions are proved to be optimal in a sense that we describe.
17;Sylvain Lombardy;Raphaël Poss, Yann Régis-Gianas, Jacques Sakarovitch;Introducing Vaucanson ;This paper reports on a new software platform called Vaucanson and dedicated to the computation with automata and transducers. Its main feature is the capacity of dealing with automata whose labels may belong to various algebraic structures.
17;Raphaël Poss;Sylvain Lombardy, Yann Régis-Gianas, Jacques Sakarovitch;Introducing Vaucanson ;This paper reports on a new software platform called Vaucanson and dedicated to the computation with automata and transducers. Its main feature is the capacity of dealing with automata whose labels may belong to various algebraic structures.
17;Yann Régis-Gianas;Sylvain Lombardy, Raphaël Poss, Jacques Sakarovitch;Introducing Vaucanson ;This paper reports on a new software platform called Vaucanson and dedicated to the computation with automata and transducers. Its main feature is the capacity of dealing with automata whose labels may belong to various algebraic structures.
17;Jacques Sakarovitch;Sylvain Lombardy, Raphaël Poss, Yann Régis-Gianas;Introducing Vaucanson ;This paper reports on a new software platform called Vaucanson and dedicated to the computation with automata and transducers. Its main feature is the capacity of dealing with automata whose labels may belong to various algebraic structures.
17;André Kempe;Christof Baeijs, Tamás Gaál, Franck Guingne, Florent Nicart;WFSC — A New Weighted Finite State Compiler;This article presents a new tool, WFSC, for creating, manipulating, and applying weighted finite state automata. It inherits some powerful features from Xerox’s non-weighted XFST tool and represents a continuation of Xerox’s work in the field of finite state automata over two decades. The design is generic: algorithms work on abstract components of automata and on a generic abstract semiring, and are independent of their concrete realizations. Applications can access WFSC’s functions through an API or create automata through an end-user interface, either from an enumeration of their states and transitions or from rational expressions.
17;Christof Baeijs;André Kempe, Tamás Gaál, Franck Guingne, Florent Nicart;WFSC — A New Weighted Finite State Compiler;This article presents a new tool, WFSC, for creating, manipulating, and applying weighted finite state automata. It inherits some powerful features from Xerox’s non-weighted XFST tool and represents a continuation of Xerox’s work in the field of finite state automata over two decades. The design is generic: algorithms work on abstract components of automata and on a generic abstract semiring, and are independent of their concrete realizations. Applications can access WFSC’s functions through an API or create automata through an end-user interface, either from an enumeration of their states and transitions or from rational expressions.
17;Tamás Gaál;André Kempe, Christof Baeijs, Franck Guingne, Florent Nicart;WFSC — A New Weighted Finite State Compiler;This article presents a new tool, WFSC, for creating, manipulating, and applying weighted finite state automata. It inherits some powerful features from Xerox’s non-weighted XFST tool and represents a continuation of Xerox’s work in the field of finite state automata over two decades. The design is generic: algorithms work on abstract components of automata and on a generic abstract semiring, and are independent of their concrete realizations. Applications can access WFSC’s functions through an API or create automata through an end-user interface, either from an enumeration of their states and transitions or from rational expressions.
17;Franck Guingne;André Kempe, Christof Baeijs, Tamás Gaál, Florent Nicart;WFSC — A New Weighted Finite State Compiler;This article presents a new tool, WFSC, for creating, manipulating, and applying weighted finite state automata. It inherits some powerful features from Xerox’s non-weighted XFST tool and represents a continuation of Xerox’s work in the field of finite state automata over two decades. The design is generic: algorithms work on abstract components of automata and on a generic abstract semiring, and are independent of their concrete realizations. Applications can access WFSC’s functions through an API or create automata through an end-user interface, either from an enumeration of their states and transitions or from rational expressions.
17;Florent Nicart;André Kempe, Christof Baeijs, Tamás Gaál, Franck Guingne;WFSC — A New Weighted Finite State Compiler;This article presents a new tool, WFSC, for creating, manipulating, and applying weighted finite state automata. It inherits some powerful features from Xerox’s non-weighted XFST tool and represents a continuation of Xerox’s work in the field of finite state automata over two decades. The design is generic: algorithms work on abstract components of automata and on a generic abstract semiring, and are independent of their concrete realizations. Applications can access WFSC’s functions through an API or create automata through an end-user interface, either from an enumeration of their states and transitions or from rational expressions.
17;Satoru Miyamoto;Shunsuke Inenaga, Masayuki Takeda, Ayumi Shinohara;Ternary Directed Acyclic Word Graphs;Given a set S of strings, a DFA accepting S offers a very time-efficient solution to the pattern matching problem over S. The key is how to implement such a DFA in the trade-off between time and space, and especially the choice of how to implement the transitions of each state is critical. Bentley and Sedgewick proposed an effective tree structure called ternary trees. The idea of ternary trees is to ‘implant’ the process of binary search for transitions into the structure of the trees themselves. This way the process of binary search becomes visible, and the implementation of the trees becomes quite easy. The directed acyclic word graph (DAWG) of a string w is the smallest DFA that accepts all suffixes of w, and requires only linear space. We apply the scheme of ternary trees to DAWGs, introducing a new data structure named ternary DAWGs (TDAWGs). We perform some experiments that show the efficiency of TDAWGs, compared to DAWGs in which transitions are implemented by tables and linked lists.
17;Shunsuke Inenaga;Satoru Miyamoto, Masayuki Takeda, Ayumi Shinohara;Ternary Directed Acyclic Word Graphs;Given a set S of strings, a DFA accepting S offers a very time-efficient solution to the pattern matching problem over S. The key is how to implement such a DFA in the trade-off between time and space, and especially the choice of how to implement the transitions of each state is critical. Bentley and Sedgewick proposed an effective tree structure called ternary trees. The idea of ternary trees is to ‘implant’ the process of binary search for transitions into the structure of the trees themselves. This way the process of binary search becomes visible, and the implementation of the trees becomes quite easy. The directed acyclic word graph (DAWG) of a string w is the smallest DFA that accepts all suffixes of w, and requires only linear space. We apply the scheme of ternary trees to DAWGs, introducing a new data structure named ternary DAWGs (TDAWGs). We perform some experiments that show the efficiency of TDAWGs, compared to DAWGs in which transitions are implemented by tables and linked lists.
17;Masayuki Takeda;Satoru Miyamoto, Shunsuke Inenaga, Ayumi Shinohara;Ternary Directed Acyclic Word Graphs;Given a set S of strings, a DFA accepting S offers a very time-efficient solution to the pattern matching problem over S. The key is how to implement such a DFA in the trade-off between time and space, and especially the choice of how to implement the transitions of each state is critical. Bentley and Sedgewick proposed an effective tree structure called ternary trees. The idea of ternary trees is to ‘implant’ the process of binary search for transitions into the structure of the trees themselves. This way the process of binary search becomes visible, and the implementation of the trees becomes quite easy. The directed acyclic word graph (DAWG) of a string w is the smallest DFA that accepts all suffixes of w, and requires only linear space. We apply the scheme of ternary trees to DAWGs, introducing a new data structure named ternary DAWGs (TDAWGs). We perform some experiments that show the efficiency of TDAWGs, compared to DAWGs in which transitions are implemented by tables and linked lists.
17;Ayumi Shinohara;Satoru Miyamoto, Shunsuke Inenaga, Masayuki Takeda;Ternary Directed Acyclic Word Graphs;Given a set S of strings, a DFA accepting S offers a very time-efficient solution to the pattern matching problem over S. The key is how to implement such a DFA in the trade-off between time and space, and especially the choice of how to implement the transitions of each state is critical. Bentley and Sedgewick proposed an effective tree structure called ternary trees. The idea of ternary trees is to ‘implant’ the process of binary search for transitions into the structure of the trees themselves. This way the process of binary search becomes visible, and the implementation of the trees becomes quite easy. The directed acyclic word graph (DAWG) of a string w is the smallest DFA that accepts all suffixes of w, and requires only linear space. We apply the scheme of ternary trees to DAWGs, introducing a new data structure named ternary DAWGs (TDAWGs). We perform some experiments that show the efficiency of TDAWGs, compared to DAWGs in which transitions are implemented by tables and linked lists.
17;Franck Guingne;André Kempe, Florent Nicart;Running Time Complexity of Printing an Acyclic Automaton;This article estimates the worst-case running time complexity for traversing and printing all successful paths of a normalized trim acyclic automaton. First, we show that the worst-case structure is a festoon with distribution of arcs on states as uniform as possible. Then, we prove that the complexity is maximum when we have a distribution of e (Napier constant) outgoing arcs per state on average, and that it can be exponential in the number of arcs.
17;André Kempe;Franck Guingne, Florent Nicart;Running Time Complexity of Printing an Acyclic Automaton;This article estimates the worst-case running time complexity for traversing and printing all successful paths of a normalized trim acyclic automaton. First, we show that the worst-case structure is a festoon with distribution of arcs on states as uniform as possible. Then, we prove that the complexity is maximum when we have a distribution of e (Napier constant) outgoing arcs per state on average, and that it can be exponential in the number of arcs.
17;Florent Nicart;Franck Guingne, André Kempe;Running Time Complexity of Printing an Acyclic Automaton;This article estimates the worst-case running time complexity for traversing and printing all successful paths of a normalized trim acyclic automaton. First, we show that the worst-case structure is a festoon with distribution of arcs on states as uniform as possible. Then, we prove that the complexity is maximum when we have a distribution of e (Napier constant) outgoing arcs per state on average, and that it can be exponential in the number of arcs.
17;Avraham Trakhtman;;Reducing the Time Complexity of Testing for Local Threshold Testability;A locally threshold testable language L is a language with the property that for some nonnegative integers k and l, whether or not a word u is in the language L depends on (1) the prefix and suf- fix of the word u of length k − 1 and (2) the set of intermediate substrings of length k of the word u where the sets of substrings occurring at least j times are the same, for j ≤ l. For given k and l the language is called l-threshold k-testable. A finite deterministic automaton is called threshold locally testable if the automaton accepts a l-threshold ktestable language for some l and k.
17;Dietrich Kuske;Ingmar Meinecke;Branching Automata with Costs — A Way of Reflecting Parallelism in Costs;Extending work by Lodaya and Weil, we propose a model of branching automata with costs in which the calculation of the cost of a parallel composition is handled differently from the calculation of the cost of a sequential composition. Our main result characterizes the behavior of these automata in the spirit of Kleene’s and Schützenberger’s theorems.
17;Ingmar Meinecke;Dietrich Kuske;Branching Automata with Costs — A Way of Reflecting Parallelism in Costs;Extending work by Lodaya and Weil, we propose a model of branching automata with costs in which the calculation of the cost of a parallel composition is handled differently from the calculation of the cost of a sequential composition. Our main result characterizes the behavior of these automata in the spirit of Kleene’s and Schützenberger’s theorems.
17;Gaoyan Xie;Cheng Li, Zhe Dang;New Complexity Results for Some Linear Counting Problems Using Minimal Solutions to Linear Diophantine Equations;The linear reachability problem is to decide whether there is an execution path in a given finite state transition system such that the counts of labels on the path satisfy a given linear constraint. Using results on minimal solutions (in nonnegative integers) for linear Diophantine systems, we obtain new complexity results for the problem, as well as for other linear counting problems of finite state transition systems and timed automata. In contrast to previously known results, the complexity bounds obtained in this paper are polynomial in the size of the transition system in consideration, when the linear constraint is fixed.
17;Cheng Li;Gaoyan Xie, Zhe Dang;New Complexity Results for Some Linear Counting Problems Using Minimal Solutions to Linear Diophantine Equations;The linear reachability problem is to decide whether there is an execution path in a given finite state transition system such that the counts of labels on the path satisfy a given linear constraint. Using results on minimal solutions (in nonnegative integers) for linear Diophantine systems, we obtain new complexity results for the problem, as well as for other linear counting problems of finite state transition systems and timed automata. In contrast to previously known results, the complexity bounds obtained in this paper are polynomial in the size of the transition system in consideration, when the linear constraint is fixed.
17;Zhe Dang;Gaoyan Xie, Cheng Li;New Complexity Results for Some Linear Counting Problems Using Minimal Solutions to Linear Diophantine Equations;The linear reachability problem is to decide whether there is an execution path in a given finite state transition system such that the counts of labels on the path satisfy a given linear constraint. Using results on minimal solutions (in nonnegative integers) for linear Diophantine systems, we obtain new complexity results for the problem, as well as for other linear counting problems of finite state transition systems and timed automata. In contrast to previously known results, the complexity bounds obtained in this paper are polynomial in the size of the transition system in consideration, when the linear constraint is fixed.
17;Farn Wang;Geng-Dian Hwang, Fang Yu;TCTL Inevitability Analysis of Dense-Time Systems;Inevitability properties in branching temporal logics are of the syntax ∀◊φ, where φ is an arbitrary (timed) CTL formula. Such inevitability properties in dense-time logics can be analyzed with greatest fixpoint calculation. We present algorithms to model-check inevitability properties both with and without non-Zeno computation requirement. We discuss a technique for early decision on greatest fixpoint calculation. Our algorithms come with a d-parameter for the measurement of time-progress. We have experimented with various issues, which may affect the performance of TCTL inevitability analysis. Specifically, we report the performance of our implementation w.r.t. various d-parameter values and with or without the non-Zeno computation requirement in the evaluation of greatest fixpoints. We have also experimented with safe abstration techniques for model-checking TCTL inevitability properties. Analysis of experiment data helps clarify how various techniques can be used to improve verification of inevitability properties.
17;Geng-Dian Hwang;Farn Wang, Fang Yu;TCTL Inevitability Analysis of Dense-Time Systems;Inevitability properties in branching temporal logics are of the syntax ∀◊φ, where φ is an arbitrary (timed) CTL formula. Such inevitability properties in dense-time logics can be analyzed with greatest fixpoint calculation. We present algorithms to model-check inevitability properties both with and without non-Zeno computation requirement. We discuss a technique for early decision on greatest fixpoint calculation. Our algorithms come with a d-parameter for the measurement of time-progress. We have experimented with various issues, which may affect the performance of TCTL inevitability analysis. Specifically, we report the performance of our implementation w.r.t. various d-parameter values and with or without the non-Zeno computation requirement in the evaluation of greatest fixpoints. We have also experimented with safe abstration techniques for model-checking TCTL inevitability properties. Analysis of experiment data helps clarify how various techniques can be used to improve verification of inevitability properties.
17;Fang Yu;Farn Wang, Geng-Dian Hwang;TCTL Inevitability Analysis of Dense-Time Systems;Inevitability properties in branching temporal logics are of the syntax ∀◊φ, where φ is an arbitrary (timed) CTL formula. Such inevitability properties in dense-time logics can be analyzed with greatest fixpoint calculation. We present algorithms to model-check inevitability properties both with and without non-Zeno computation requirement. We discuss a technique for early decision on greatest fixpoint calculation. Our algorithms come with a d-parameter for the measurement of time-progress. We have experimented with various issues, which may affect the performance of TCTL inevitability analysis. Specifically, we report the performance of our implementation w.r.t. various d-parameter values and with or without the non-Zeno computation requirement in the evaluation of greatest fixpoints. We have also experimented with safe abstration techniques for model-checking TCTL inevitability properties. Analysis of experiment data helps clarify how various techniques can be used to improve verification of inevitability properties.
17;Xiang Fu;Tevfik Bultan, Jianwen Su;Conversation Protocols: A Formalism for Specification and Verification of Reactive Electronic Services;This paper focuses on the realizability problem of a framework for modeling and specifying the global behavior of reactive electronicservices (e-services). In this framework, Web accessible programs (peers) communicate by asynchronous message passing, and a virtual global watcher listens silently to the network. The global behavior is characterized by a conversation, which is the infinite sequence of messages observed by the watcher. We show that given a Büchi automaton specifying the desired set of conversations, called a conversation protocol, it is possible to implement it using a set of finite state peers if three realizability conditions are satisfied. In particular, the synthesized peers will conform to the protocol by generating only those conversations specified by the protocol. Our results enable a top-down verification strategy where: (1) A conversation protocol is specified by a realizable Büchi automaton, (2) The properties of the protocol are verified on the Büchi automaton specification, (3) The peer implementations are synthesized from the protocol via projection.
17;Tevfik Bultan;Xiang Fu, Jianwen Su;Conversation Protocols: A Formalism for Specification and Verification of Reactive Electronic Services;This paper focuses on the realizability problem of a framework for modeling and specifying the global behavior of reactive electronicservices (e-services). In this framework, Web accessible programs (peers) communicate by asynchronous message passing, and a virtual global watcher listens silently to the network. The global behavior is characterized by a conversation, which is the infinite sequence of messages observed by the watcher. We show that given a Büchi automaton specifying the desired set of conversations, called a conversation protocol, it is possible to implement it using a set of finite state peers if three realizability conditions are satisfied. In particular, the synthesized peers will conform to the protocol by generating only those conversations specified by the protocol. Our results enable a top-down verification strategy where: (1) A conversation protocol is specified by a realizable Büchi automaton, (2) The properties of the protocol are verified on the Büchi automaton specification, (3) The peer implementations are synthesized from the protocol via projection.
17;Jianwen Su;Xiang Fu, Tevfik Bultan;Conversation Protocols: A Formalism for Specification and Verification of Reactive Electronic Services;This paper focuses on the realizability problem of a framework for modeling and specifying the global behavior of reactive electronicservices (e-services). In this framework, Web accessible programs (peers) communicate by asynchronous message passing, and a virtual global watcher listens silently to the network. The global behavior is characterized by a conversation, which is the infinite sequence of messages observed by the watcher. We show that given a Büchi automaton specifying the desired set of conversations, called a conversation protocol, it is possible to implement it using a set of finite state peers if three realizability conditions are satisfied. In particular, the synthesized peers will conform to the protocol by generating only those conversations specified by the protocol. Our results enable a top-down verification strategy where: (1) A conversation protocol is specified by a realizable Büchi automaton, (2) The properties of the protocol are verified on the Büchi automaton specification, (3) The peer implementations are synthesized from the protocol via projection.
17;Haruo Hosoya;Makoto Murata;Boolean Operations for Attribute-Element Constraints;The history of schema languages for XML is an increase of expressiveness. While early schema languages mainly focused on the element structure, Clark first paid an equal attention to attributes by allowing both element and attribute constraints in a single regular expression. In this paper, we investigate an algorithmic aspect of Clark’s mechanism (called “attribute-element constraints”), namely, intersection and difference operations, which have been proved to be important in static typechecking for XML processing programs. The contributions here are (1) proofs of closure under intersection and difference and (2) algorithm formulations incorporating a “divide-and-conquer” strategy for avoiding an exponential blow-up for typical inputs.
17;Makoto Murata;Haruo Hosoya;Boolean Operations for Attribute-Element Constraints;The history of schema languages for XML is an increase of expressiveness. While early schema languages mainly focused on the element structure, Clark first paid an equal attention to attributes by allowing both element and attribute constraints in a single regular expression. In this paper, we investigate an algorithmic aspect of Clark’s mechanism (called “attribute-element constraints”), namely, intersection and difference operations, which have been proved to be important in static typechecking for XML processing programs. The contributions here are (1) proofs of closure under intersection and difference and (2) algorithm formulations incorporating a “divide-and-conquer” strategy for avoiding an exponential blow-up for typical inputs.
18;Mehryar Mohri;;Edit-Distance of Weighted Automata;The edit-distance of two strings is the minimal cost of a sequence of symbol insertions, deletions, or substitutions transforming one string into the other. The definition is used in various contexts to give a measure of the difference or similarity between two strings. This definition can be extended to measure the similarity between two sets of strings. In particular, when these sets are represented by automata, their edit-distance can be computed using the general algorithm of composition of weighted transducers combined with a single-source shortest-paths algorithm. More generally, in some applications such as speech recognition and computational biology, the strings may represent a range of alternative hypotheses with associated probabilities. Thus, we introduce the definition of the edit-distance of two distributions of strings given by two weighted automata. We show that general weighted automata algorithms over the appropriate semirings can be used to compute the edit-distance of two weighted automata exactly. The algorithm for computing exactly the edit-distance of weighted automata can be used to improve the word accuracy of automatic speech recognition systems. More generally, the algorithm can be extended to provide an edit-distance automaton useful for rescoring and other post-processing purposes in the context of large-vocabulary speech recognition. In the course of the presentation of our algorithm, we also introduce a new and general synchronization algorithm for weighted transducers which, combined with ∈-removal, can be used to normalize weighted transducers with bounded delays.
18;Cyril Allauzen;Mehryar Mohri;p-Subsequentiable Transducers;p-subsequential transducers are efficient finite-state transducers with p final outputs used in a variety of applications. Not all transducers admit equivalent p-subsequential transducers however. We briefly describe an existing generalized determinization algorithm for psubsequential transducers and give the first characterization of p-subsequentiable transducers, transducers that admit equivalent p-subsequential transducers. Our characterization shows the existence of an efficient algorithm for testing p-subsequentiability. We have fully implemented the generalized determinization algorithm and the algorithm for testing p- subsequentiability. We report experimental results showing that these algorithms are practical in large-vocabulary speech recognition applications. The theoretical formulation of our results is the equivalence of the following three properties for finite-state transducers: determinizability in the sense of the generalized algorithm, p-subsequentiability, and the twins property.
18;Mehryar Mohri;Cyril Allauzen;p-Subsequentiable Transducers;p-subsequential transducers are efficient finite-state transducers with p final outputs used in a variety of applications. Not all transducers admit equivalent p-subsequential transducers however. We briefly describe an existing generalized determinization algorithm for psubsequential transducers and give the first characterization of p-subsequentiable transducers, transducers that admit equivalent p-subsequential transducers. Our characterization shows the existence of an efficient algorithm for testing p-subsequentiability. We have fully implemented the generalized determinization algorithm and the algorithm for testing p- subsequentiability. We report experimental results showing that these algorithms are practical in large-vocabulary speech recognition applications. The theoretical formulation of our results is the equivalence of the following three properties for finite-state transducers: determinizability in the sense of the generalized algorithm, p-subsequentiability, and the twins property.
18;Miguel A. Alonso;Víctor J. Díaz, Manuel Vilares;Bidirectional Push Down Automata;We define a new model of automata for the description of bidirectional parsing strategies for context-free grammars and a tabulation mechanism that allow them to be executed in polynomial time. This new model of automata provides a modular way of defining bidirectional parsers, separating the description of a strategy from its execution.
18;Víctor J. Díaz;Miguel A. Alonso, Manuel Vilares;Bidirectional Push Down Automata;We define a new model of automata for the description of bidirectional parsing strategies for context-free grammars and a tabulation mechanism that allow them to be executed in polynomial time. This new model of automata provides a modular way of defining bidirectional parsers, separating the description of a strategy from its execution.
18;Manuel Vilares;Miguel A. Alonso, Víctor J. Díaz;Bidirectional Push Down Automata;We define a new model of automata for the description of bidirectional parsing strategies for context-free grammars and a tabulation mechanism that allow them to be executed in polynomial time. This new model of automata provides a modular way of defining bidirectional parsers, separating the description of a strategy from its execution.
18;Marcella Anselmo;Dora Giammarresi, Stefano Varricchio;Finite Automata and Non-self-Embedding Grammars;We consider non-self-embedding (NSE) context-free grammars as a representation of regular sets.We point out its advantages with respect to more classical representations by finite automata, in particular when considering the efficient realization of the rational operations. We give a characterization in terms of composition of regular grammars and state relationships between NSE grammars and push-down automata. Finally we show a polynomial algorithm to decide whether a context-free grammars is self-embedding or not.
18;Dora Giammarresi;Marcella Anselmo, Stefano Varricchio;Finite Automata and Non-self-Embedding Grammars;We consider non-self-embedding (NSE) context-free grammars as a representation of regular sets.We point out its advantages with respect to more classical representations by finite automata, in particular when considering the efficient realization of the rational operations. We give a characterization in terms of composition of regular grammars and state relationships between NSE grammars and push-down automata. Finally we show a polynomial algorithm to decide whether a context-free grammars is self-embedding or not.
18;Stefano Varricchio;Marcella Anselmo, Dora Giammarresi;Finite Automata and Non-self-Embedding Grammars;We consider non-self-embedding (NSE) context-free grammars as a representation of regular sets.We point out its advantages with respect to more classical representations by finite automata, in particular when considering the efficient realization of the rational operations. We give a characterization in terms of composition of regular grammars and state relationships between NSE grammars and push-down automata. Finally we show a polynomial algorithm to decide whether a context-free grammars is self-embedding or not.
18;Janusz Brzozowski;Mihaela Gheorghiu;Simulation of Gate Circuits in the Algebra of Transients;We study simulation of gate circuits in algebra C recently introduced by Brzozowski and Ésik.A transient is a word consisting of alternating 0s and 1s. it represents a changing signal. In C, gates process transients instead of 0s and 1s. Simulation in C is capable of counting signal changes, and detecting hazards.We study two simulation algorithms: a general one, A, that works with any state, and Ã, that applies if the initial state is stable.We show that the two algorithms agree in the stable case. We prove the sufficiency of the simulation: all signal changes occurring in binary analysis are also predicted by Algorithm A.
18;Mihaela Gheorghiu;Janusz Brzozowski;Simulation of Gate Circuits in the Algebra of Transients;We study simulation of gate circuits in algebra C recently introduced by Brzozowski and Ésik.A transient is a word consisting of alternating 0s and 1s. it represents a changing signal. In C, gates process transients instead of 0s and 1s. Simulation in C is capable of counting signal changes, and detecting hazards.We study two simulation algorithms: a general one, A, that works with any state, and Ã, that applies if the initial state is stable.We show that the two algorithms agree in the stable case. We prove the sufficiency of the simulation: all signal changes occurring in binary analysis are also predicted by Algorithm A.
18;Cezar Cămpeanu;Andrei Păun;The Number of Similarity Relations and the Number of Minimal Deterministic Finite Cover Automata;Finite Deterministic Cover Automata (DFCA) can be obtained from Deterministic Finite Automata (DFA) using the similarity relation. Since the similarity relation is not an equivalence relation, the minimal DFCA for a finite language is usually not unique. We count the number of minimal DFCA that can be obtained from a given minimal DFA with n states by merging the similar states in the given DFA. We compute an upper bound for this number and prove that in the worst case (for a non-unary alphabet) it is [4n-9+√8n+1!/8]/(2[4n-9+√8n+1/8] - n + 1)!
18;Andrei Păun;Cezar Cămpeanu;The Number of Similarity Relations and the Number of Minimal Deterministic Finite Cover Automata;Finite Deterministic Cover Automata (DFCA) can be obtained from Deterministic Finite Automata (DFA) using the similarity relation. Since the similarity relation is not an equivalence relation, the minimal DFCA for a finite language is usually not unique. We count the number of minimal DFCA that can be obtained from a given minimal DFA with n states by merging the similar states in the given DFA. We compute an upper bound for this number and prove that in the worst case (for a non-unary alphabet) it is [4n-9+√8n+1!/8]/(2[4n-9+√8n+1/8] - n + 1)!
18;Cezar Câmpeanu;Kai Salomaa, Sheng Yu;Regex and Extended Regex;Regex are used in many programs such as Perl, Awk, Python, egrep, vi, emacs etc. It is known that regex are different from regular expressions. In this paper, we give regex a formal treatment. We make a distinction between regex and extended regex. while regex present regular languages, extended regex present a family of languages larger than regular languages. We prove a pumping lemma for the languages expressed by extended regex. We show that the languages represented by extended regex are incomparable with context-free languages and a proper subset of context-sensitive languages.
18;Kai Salomaa;Cezar Câmpeanu, Sheng Yu;Regex and Extended Regex;Regex are used in many programs such as Perl, Awk, Python, egrep, vi, emacs etc. It is known that regex are different from regular expressions. In this paper, we give regex a formal treatment. We make a distinction between regex and extended regex. while regex present regular languages, extended regex present a family of languages larger than regular languages. We prove a pumping lemma for the languages expressed by extended regex. We show that the languages represented by extended regex are incomparable with context-free languages and a proper subset of context-sensitive languages.
18;Sheng Yu;Cezar Câmpeanu, Kai Salomaa;Regex and Extended Regex;Regex are used in many programs such as Perl, Awk, Python, egrep, vi, emacs etc. It is known that regex are different from regular expressions. In this paper, we give regex a formal treatment. We make a distinction between regex and extended regex. while regex present regular languages, extended regex present a family of languages larger than regular languages. We prove a pumping lemma for the languages expressed by extended regex. We show that the languages represented by extended regex are incomparable with context-free languages and a proper subset of context-sensitive languages.
18;Jurek Czyzowicz;Wojciech Fraczak, Andrzej Pelc, Wojciech Rytter;Prime Decompositions of Regular Prefix Codes;One of the new approaches to data classification uses finite state automata for representation of prefix codes. An important task driven by the need for the efficient storage of such automata in memory is the decomposition of prefix codes into prime factors. We investigate properties of such prefix code decompositions. A linear time algorithm is designed which finds the prime decomposition F1F2 . . . Fk of a regular prefix code F given by its minimal deterministic automaton.
18;Wojciech Fraczak;Jurek Czyzowicz, Andrzej Pelc, Wojciech Rytter;Prime Decompositions of Regular Prefix Codes;One of the new approaches to data classification uses finite state automata for representation of prefix codes. An important task driven by the need for the efficient storage of such automata in memory is the decomposition of prefix codes into prime factors. We investigate properties of such prefix code decompositions. A linear time algorithm is designed which finds the prime decomposition F1F2 . . . Fk of a regular prefix code F given by its minimal deterministic automaton.
18;Andrzej Pelc;Jurek Czyzowicz, Wojciech Fraczak, Wojciech Rytter;Prime Decompositions of Regular Prefix Codes;One of the new approaches to data classification uses finite state automata for representation of prefix codes. An important task driven by the need for the efficient storage of such automata in memory is the decomposition of prefix codes into prime factors. We investigate properties of such prefix code decompositions. A linear time algorithm is designed which finds the prime decomposition F1F2 . . . Fk of a regular prefix code F given by its minimal deterministic automaton.
18;Wojciech Rytter;Jurek Czyzowicz, Wojciech Fraczak, Andrzej Pelc;Prime Decompositions of Regular Prefix Codes;One of the new approaches to data classification uses finite state automata for representation of prefix codes. An important task driven by the need for the efficient storage of such automata in memory is the decomposition of prefix codes into prime factors. We investigate properties of such prefix code decompositions. A linear time algorithm is designed which finds the prime decomposition F1F2 . . . Fk of a regular prefix code F given by its minimal deterministic automaton.
18;Abolfazl Fatholahzadeh;;Implementation of Dictionaries via Automata and Decision Trees;Finite-state transducers can be used to map a language onto a set of values. This paper proposes an alternate representation method for such a mapping, consisting of associating a finite-state automaton accepting the input language with a decision tree representing the output values. The advantages of this approach are that it leads to more compact representations than transducers, and that decision trees can easily be synthesized by machine learning techniques.
18;Mihaela Gheorghiu;Janusz Brzozowski;Feedback-Free Circuits in the Algebra of Transients;An efficient simulation algorithm using an algebra of transients for gate circuits was proposed by Brzozowski and Ésik. This algorithm seems capable of predicting all the signal changes that can occur in a circuit under worst-case delay conditions. We verify this claim by comparing simulation with binary analysis. For any feedback-free circuit consisting of 1- and 2-input gates and started in a stable state, we prove that all signal changes predicted by simulation occur in binary analysis, provided that wire delays are taken into account. Two types of finite automata play an important role in our proof.
18;Janusz Brzozowski;Mihaela Gheorghiu;Feedback-Free Circuits in the Algebra of Transients;An efficient simulation algorithm using an algebra of transients for gate circuits was proposed by Brzozowski and Ésik. This algorithm seems capable of predicting all the signal changes that can occur in a circuit under worst-case delay conditions. We verify this claim by comparing simulation with binary analysis. For any feedback-free circuit consisting of 1- and 2-input gates and started in a stable state, we prove that all signal changes predicted by simulation occur in binary analysis, provided that wire delays are taken into account. Two types of finite automata play an important role in our proof.
18;Heiko Körner;;On Minimizing Cover Automata for Finite Languages in O(n log n) Time;A deterministic finite automaton (DFA) A is called a cover automaton (DFCA) for a finite language L over some alphabet σ if L = L(A) ∩ σ≤l, with l being the length of some longest word in L. Thus a word w ∈ σ* is in L if and only if ∣w∣ ≤ l and w ∈ L(A). The DFCA A is minimal if no DFCA for L has fewer states.
18;Jorge Graña;Gloria Andrade, Jesús Vilares;Compilation of Constraint-Based Contextual Rules for Part-of-Speech Tagging into Finite State Transducers;With the aim of removing the residuary errors made by pure stochastic disambiguation models, we put forward a hybrid system in which linguist users introduce high level contextual rules to be applied in combination with a tagger based on a Hidden Markov Model. The design of these rules is inspired in the Constraint Grammars formalism. In the present work, we review this formalism in order to propose a more intuitive syntax and semantics for rules, and we develop a strategy to compile the rules under the form of Finite State Transducers, thus guaranteeing an efficient execution framework.
18;Gloria Andrade;Jorge Graña, Jesús Vilares;Compilation of Constraint-Based Contextual Rules for Part-of-Speech Tagging into Finite State Transducers;With the aim of removing the residuary errors made by pure stochastic disambiguation models, we put forward a hybrid system in which linguist users introduce high level contextual rules to be applied in combination with a tagger based on a Hidden Markov Model. The design of these rules is inspired in the Constraint Grammars formalism. In the present work, we review this formalism in order to propose a more intuitive syntax and semantics for rules, and we develop a strategy to compile the rules under the form of Finite State Transducers, thus guaranteeing an efficient execution framework.
18;Jesús Vilares;Jorge Graña, Gloria Andrade;Compilation of Constraint-Based Contextual Rules for Part-of-Speech Tagging into Finite State Transducers;With the aim of removing the residuary errors made by pure stochastic disambiguation models, we put forward a hybrid system in which linguist users introduce high level contextual rules to be applied in combination with a tagger based on a Hidden Markov Model. The design of these rules is inspired in the Constraint Grammars formalism. In the present work, we review this formalism in order to propose a more intuitive syntax and semantics for rules, and we develop a strategy to compile the rules under the form of Finite State Transducers, thus guaranteeing an efficient execution framework.
18;Franck Guingne;Florent Nicart;Finite State Lazy Operations in NLP;Finite state networks can represent dictionaries and lexical relations. Traditional finite-state operations like composition can produce huge networks with prohibitive computation space and time. For a subset of finite state operations, these drawbacks can be avoided by using virtual networks, which rely on structures that are partially built on demand. This paper addresses the implementation of virtual network operations in xfst (XEROX Finite State Technology software). The example of “priority union” which is particularly useful in NLP, is developed.
18;Florent Nicart;Franck Guingne;Finite State Lazy Operations in NLP;Finite state networks can represent dictionaries and lexical relations. Traditional finite-state operations like composition can produce huge networks with prohibitive computation space and time. For a subset of finite state operations, these drawbacks can be avoided by using virtual networks, which rely on structures that are partially built on demand. This paper addresses the implementation of virtual network operations in xfst (XEROX Finite State Technology software). The example of “priority union” which is particularly useful in NLP, is developed.
18;Markus Holzer;Martin Kutrib;State Complexity of Basic Operations on Nondeterministic Finite Automata;The state complexities of basic operations on nondeterministic finite automata (NFA) are investigated. In particular, we consider Boolean operations, catenation operations - concatenation, iteration, λ- free iteration - and the reversal on NFAs that accept finite and infinite languages over arbitrary alphabets. Most of the shown bounds are tight in the exact number of states, i.e. the number is sufficient and necessary in the worst case. For the complementation tight bounds in the order of magnitude are proved. It turns out that the state complexities of operations on NFAs and deterministic .nite automata (DFA) are quite different. For example, the reversal and concatenation have exponential state complexity on DFAs but linear complexity on NFAs. Conversely, the complementation can be done with linear complexity on DFAs but needs exponentially many states on NFAs.
18;Martin Kutrib;Markus Holzer;State Complexity of Basic Operations on Nondeterministic Finite Automata;The state complexities of basic operations on nondeterministic finite automata (NFA) are investigated. In particular, we consider Boolean operations, catenation operations - concatenation, iteration, λ- free iteration - and the reversal on NFAs that accept finite and infinite languages over arbitrary alphabets. Most of the shown bounds are tight in the exact number of states, i.e. the number is sufficient and necessary in the worst case. For the complementation tight bounds in the order of magnitude are proved. It turns out that the state complexities of operations on NFAs and deterministic .nite automata (DFA) are quite different. For example, the reversal and concatenation have exponential state complexity on DFAs but linear complexity on NFAs. Conversely, the complementation can be done with linear complexity on DFAs but needs exponentially many states on NFAs.
18;João José Neto;César Bravo;Adaptive Automata - A Revisited Proposal;This paper impose further discipline to the use of adaptive automata [Jos94], [Iwa00] by restricting some of their features, in order to obtain devices that are easier to create and more readable, without loosing computational power. An improved notation is proposed as a first try towards a language for adaptive paradigm programming.
18;César Bravo;João José Neto;Adaptive Automata - A Revisited Proposal;This paper impose further discipline to the use of adaptive automata [Jos94], [Iwa00] by restricting some of their features, in order to obtain devices that are easier to create and more readable, without loosing computational power. An improved notation is proposed as a first try towards a language for adaptive paradigm programming.
18;Alexander Okhotin;;Efficient Automaton-Based Recognition for Linear Conjunctive Languages;This paper studies practical algorithms for dealing with a particular family of cellular automata, which has recently been proved computationally equivalent to linear conjunctive grammars. The relation between these grammars and these automata resembles that between regular expressions and finite automata: while the former are better suited for human use, the latter are considerably easier to implement. In this paper, an algorithm for converting an arbitrary linear conjunctive grammar to an equivalent automaton is proposed, and different techniques of reducing the size of existing automata are studied.
18;Libor Polák;;Syntactic Semiring and Language Equations;A classical construction assigns to any language its (ordered) syntactic monoid. Recently the author defined the so-called syntactic semiring of a language. We show here that elements of the syntactic semiring of L can be identified with transformations of a certain modification of the minimal automaton for L.
18;Klaus Sutner;;Reduced Power Automata;We describe a class of transitive semiautomata whose power automata are reduced: any two reachable sets of states have distinct behavior. These automata appear naturally in the study of one-dimensional cellular automata.
18;A.N. Trahtman;;A Polynomial Time Algorithm for Left [Right] Local Testability;A right [left] locally testable language S is a language with the property that for some nonnegative integer k two words u and v in alphabet S are equal in the semigroup if (1) the prefix and sufix of the words of length k -1 coincide, (2) the set of segments of length k of the words as well as 3) the order of the first appearance of these segments in prefixes [sufixes] coincide.
19;Iñaki Alegria;Maxux Aranzabe, Nerea Ezeiza, Aitzol Ezeiza, Ruben Urizar;Using Finite State Technology in Natural Language Processing of Basque;This paper describes the components used in the design and implementation of NLP tools for Basque. These components are based on finite state technology and are devoted to the morphological analysis of Basque, an agglutinative pre-Indo-European language. We think that our design can be interesting for the treatment of other languages. The main components developed are a general and robust morphological analyser/generator and a spelling checker/corrector for Basque named Xuxen. The analyser is a basic tool for current and future work on NLP of Basque, such as the lemmatiser/tagger Euslem, an Intranet search engine or an assistant for verse-making.
19;Maxux Aranzabe;Iñaki Alegria, Nerea Ezeiza, Aitzol Ezeiza, Ruben Urizar;Using Finite State Technology in Natural Language Processing of Basque;This paper describes the components used in the design and implementation of NLP tools for Basque. These components are based on finite state technology and are devoted to the morphological analysis of Basque, an agglutinative pre-Indo-European language. We think that our design can be interesting for the treatment of other languages. The main components developed are a general and robust morphological analyser/generator and a spelling checker/corrector for Basque named Xuxen. The analyser is a basic tool for current and future work on NLP of Basque, such as the lemmatiser/tagger Euslem, an Intranet search engine or an assistant for verse-making.
19;Nerea Ezeiza;Iñaki Alegria, Maxux Aranzabe, Aitzol Ezeiza, Ruben Urizar;Using Finite State Technology in Natural Language Processing of Basque;This paper describes the components used in the design and implementation of NLP tools for Basque. These components are based on finite state technology and are devoted to the morphological analysis of Basque, an agglutinative pre-Indo-European language. We think that our design can be interesting for the treatment of other languages. The main components developed are a general and robust morphological analyser/generator and a spelling checker/corrector for Basque named Xuxen. The analyser is a basic tool for current and future work on NLP of Basque, such as the lemmatiser/tagger Euslem, an Intranet search engine or an assistant for verse-making.
19;Aitzol Ezeiza;Iñaki Alegria, Maxux Aranzabe, Nerea Ezeiza, Ruben Urizar;Using Finite State Technology in Natural Language Processing of Basque;This paper describes the components used in the design and implementation of NLP tools for Basque. These components are based on finite state technology and are devoted to the morphological analysis of Basque, an agglutinative pre-Indo-European language. We think that our design can be interesting for the treatment of other languages. The main components developed are a general and robust morphological analyser/generator and a spelling checker/corrector for Basque named Xuxen. The analyser is a basic tool for current and future work on NLP of Basque, such as the lemmatiser/tagger Euslem, an Intranet search engine or an assistant for verse-making.
19;Ruben Urizar;Iñaki Alegria, Maxux Aranzabe, Nerea Ezeiza, Aitzol Ezeiza;Using Finite State Technology in Natural Language Processing of Basque;This paper describes the components used in the design and implementation of NLP tools for Basque. These components are based on finite state technology and are devoted to the morphological analysis of Basque, an agglutinative pre-Indo-European language. We think that our design can be interesting for the treatment of other languages. The main components developed are a general and robust morphological analyser/generator and a spelling checker/corrector for Basque named Xuxen. The analyser is a basic tool for current and future work on NLP of Basque, such as the lemmatiser/tagger Euslem, an Intranet search engine or an assistant for verse-making.
19;Anne Bergeron;Sylvie Hamel;Cascade Decompositions are Bit-Vector Algorithms;A vector algorithm is an algorithm that applies a bounded number of vector operations to an input vector, regardless of the length of the input. In this paper, we describe the links between the existence of vector algorithms and the cascade decompositions of counter-free automata.
19;Sylvie Hamel;Anne Bergeron;Cascade Decompositions are Bit-Vector Algorithms;A vector algorithm is an algorithm that applies a bounded number of vector operations to an input vector, regardless of the length of the input. In this paper, we describe the links between the existence of vector algorithms and the cascade decompositions of counter-free automata.
19;Gregor v. Bochmann;;Submodule Construction and Supervisory Control: A Generalization;We consider the following problem: For a system consisting of two submodules, the behavior of one submodule is known as well as the desired behavior S of the global system. What should be the behavior of the second submodule such that the behavior of the composition of the two submodules conforms to S? - This problem has also been called “equation solving”, and in the context of supervisory control, it is the problem of designing a suitable controller (second submodule) which controls a given system to be controlled (first submodule). Solutions to this problem have been described by different authors for various assumptions about the underlying communication mechanisms and conformance relations. We present a generalization of this problem and its solution using concepts from relational database theory. We also show that several of the existing solutions are special cases of our general formulation
19;Bernard Boigelot;Louis Latour;Counting the Solutions of Presburger Equations without Enumerating Them;The Number Decision Diagram (NDD) has recently been proposed as a powerful representation system for sets of integer vectors. In particular, NDDs can be used for representing the sets of solutions of arbitrary Presburger formulas, or the set of reachable states of some systems using unbounded integer variables. In this paper, we address the problem of counting the number of distinct elements in a set of vectors represented as an NDD. We give an algorithm that is able to perform an exact count without enumerating explicitly the vectors, which makes it capable of handling very large sets. As an auxiliary result, we also develop an efficient projection method that allows to construct efficiently NDDs from quantified formulas, and thus makes it possible to apply our counting technique to sets specified by formulas. Our algorithms have been implemented in the verification tool LASH, and applied successfully to various counting problems.
19;Louis Latour;Bernard Boigelot;Counting the Solutions of Presburger Equations without Enumerating Them;The Number Decision Diagram (NDD) has recently been proposed as a powerful representation system for sets of integer vectors. In particular, NDDs can be used for representing the sets of solutions of arbitrary Presburger formulas, or the set of reachable states of some systems using unbounded integer variables. In this paper, we address the problem of counting the number of distinct elements in a set of vectors represented as an NDD. We give an algorithm that is able to perform an exact count without enumerating explicitly the vectors, which makes it capable of handling very large sets. As an auxiliary result, we also develop an efficient projection method that allows to construct efficiently NDDs from quantified formulas, and thus makes it possible to apply our counting technique to sets specified by formulas. Our algorithms have been implemented in the verification tool LASH, and applied successfully to various counting problems.
19;Jean-Marc Champarnaud;Gérard Duchamp;Brzozowski’s Derivatives Extended to Multiplicities;Our aim is to study the set of K-rational expressions describing rational series. More precisely we are concerned with the definition of quotients of this set by coarser and coarser congruences which lead to an extension - in the case of multiplicities - of some classical results stated in the Boolean case. In particular, analogues of the well known theorems of Brzozowski and Antimirov are provided in this frame.
19;Gérard Duchamp;Jean-Marc Champarnaud;Brzozowski’s Derivatives Extended to Multiplicities;Our aim is to study the set of K-rational expressions describing rational series. More precisely we are concerned with the definition of quotients of this set by coarser and coarser congruences which lead to an extension - in the case of multiplicities - of some classical results stated in the Boolean case. In particular, analogues of the well known theorems of Brzozowski and Antimirov are provided in this frame.
19;Jan Daciuk;Gertjan van Noord;Finite Automata for Compact Representation of Language Models in NLP;A technique for compact representation of language models in Natural Language Processing is presented. After a brief review of the motivations for a more compact representation of such language models, it is shown how finite-state automata can be used to compactly represent such language models. The technique can be seen as an application and extension of perfect hashing by means of finite-state automata. Preliminary practical experiments indicate that the technique yields considerable and important space savings of up to 90% in practice.
19;Gertjan van Noord;Jan Daciuk;Finite Automata for Compact Representation of Language Models in NLP;A technique for compact representation of language models in Natural Language Processing is presented. After a brief review of the motivations for a more compact representation of such language models, it is shown how finite-state automata can be used to compactly represent such language models. The technique can be seen as an application and extension of perfect hashing by means of finite-state automata. Preliminary practical experiments indicate that the technique yields considerable and important space savings of up to 90% in practice.
19;Zhe Dang;Tevfik Bultan, Oscar H. Ibarra, Richard A. Kemmerer;Past Pushdown Timed Automata;We consider past pushdown timed automata that are discrete pushdown timed automata [15] with past-formulas as enabling conditions. Using past formulas allows a past pushdown timed automaton to access the past values of the finite state variables in the automaton. We prove that the reachability (i.e., the set of reachable configurations from an initial configuration) of a past pushdown timed automaton can be accepted by a nondeterministic reversal-bounded multicounter machine augmented with a pushdown stack (i.e., a reversal-bounded NPCM). Using the known fact that the emptiness problem for reversal-bounded NPCMs is decidable, we show that model-checking past pushdown timed automata against Presburger safety properties on discrete clocks and stack word counts is decidable. An example ASTRAL specification is presented to demonstrate the usefulness of the results.
19;Tevfik Bultan;Zhe Dang, Oscar H. Ibarra, Richard A. Kemmerer;Past Pushdown Timed Automata;We consider past pushdown timed automata that are discrete pushdown timed automata [15] with past-formulas as enabling conditions. Using past formulas allows a past pushdown timed automaton to access the past values of the finite state variables in the automaton. We prove that the reachability (i.e., the set of reachable configurations from an initial configuration) of a past pushdown timed automaton can be accepted by a nondeterministic reversal-bounded multicounter machine augmented with a pushdown stack (i.e., a reversal-bounded NPCM). Using the known fact that the emptiness problem for reversal-bounded NPCMs is decidable, we show that model-checking past pushdown timed automata against Presburger safety properties on discrete clocks and stack word counts is decidable. An example ASTRAL specification is presented to demonstrate the usefulness of the results.
19;Oscar H. Ibarra;Zhe Dang, Tevfik Bultan, Richard A. Kemmerer;Past Pushdown Timed Automata;We consider past pushdown timed automata that are discrete pushdown timed automata [15] with past-formulas as enabling conditions. Using past formulas allows a past pushdown timed automaton to access the past values of the finite state variables in the automaton. We prove that the reachability (i.e., the set of reachable configurations from an initial configuration) of a past pushdown timed automaton can be accepted by a nondeterministic reversal-bounded multicounter machine augmented with a pushdown stack (i.e., a reversal-bounded NPCM). Using the known fact that the emptiness problem for reversal-bounded NPCMs is decidable, we show that model-checking past pushdown timed automata against Presburger safety properties on discrete clocks and stack word counts is decidable. An example ASTRAL specification is presented to demonstrate the usefulness of the results.
19;Richard A. Kemmerer;Zhe Dang, Tevfik Bultan, Oscar H. Ibarra;Past Pushdown Timed Automata;We consider past pushdown timed automata that are discrete pushdown timed automata [15] with past-formulas as enabling conditions. Using past formulas allows a past pushdown timed automaton to access the past values of the finite state variables in the automaton. We prove that the reachability (i.e., the set of reachable configurations from an initial configuration) of a past pushdown timed automaton can be accepted by a nondeterministic reversal-bounded multicounter machine augmented with a pushdown stack (i.e., a reversal-bounded NPCM). Using the known fact that the emptiness problem for reversal-bounded NPCMs is decidable, we show that model-checking past pushdown timed automata against Presburger safety properties on discrete clocks and stack word counts is decidable. An example ASTRAL specification is presented to demonstrate the usefulness of the results.
19;Jean-Philippe Dubernard;Dominique Geniet;Scheduling Hard Sporadic Tasks by Means of Finite Automata and Generating Functions;In a previous work, we propose a technique to decide feasability of periodic hard real-time systems based on finite automata. Here, associating generating functions (whose role is “to predict the future”) to a finite automaton, we extend this technique to hard sporadic tasks, independent or interdependent with the periodic tasks.
19;Dominique Geniet;Jean-Philippe Dubernard;Scheduling Hard Sporadic Tasks by Means of Finite Automata and Generating Functions;In a previous work, we propose a technique to decide feasability of periodic hard real-time systems based on finite automata. Here, associating generating functions (whose role is “to predict the future”) to a finite automaton, we extend this technique to hard sporadic tasks, independent or interdependent with the periodic tasks.
19;Jacques Farré;José Fortes Gálvez;Bounded-Graph Construction for Noncanonical Discriminating-Reverse Parsers;We present a new approach for the construction of NDR parsers, which defines a new form of items and keeps track of bounded sequences of subgraph connections. This improves the precise recovery of conflicts’ right-hand contexts over the basic looping approach, and thus allows to extend the class of accepted grammars. Acceptance of at least all LALR(k) grammars, for a given k, is guaranteed. Moreover, the construction needs no subgraph copies. Since bounded-graph and basic looping constructions only differ in the accuracy of the conflicts’ right-hand contexts computation, the NDR parsing algorithm remains unchanged.
19;José Fortes Gálvez;Jacques Farré;Bounded-Graph Construction for Noncanonical Discriminating-Reverse Parsers;We present a new approach for the construction of NDR parsers, which defines a new form of items and keeps track of bounded sequences of subgraph connections. This improves the precise recovery of conflicts’ right-hand contexts over the basic looping approach, and thus allows to extend the class of accepted grammars. Acceptance of at least all LALR(k) grammars, for a given k, is guaranteed. Moreover, the construction needs no subgraph copies. Since bounded-graph and basic looping constructions only differ in the accuracy of the conflicts’ right-hand contexts computation, the NDR parsing algorithm remains unchanged.
19;Nathalie Friburger;1]Denis Maurel;Finite-State Transducer Cascade to Extract Proper Names in Texts;This article describes a finite-state cascade for the extraction of person names in texts in French. We extract these proper names in order to categorize and to cluster texts with them. After a finite-state pre-processing (division of the text in sentences, tagging with dictionaries, etc.), a series of finite-state transducers is applied one after the other to the text and locates left and right contexts that indicates the presence of a person name. An evaluation of the results of this extraction is presented.
19;1]Denis Maurel;Nathalie Friburger;Finite-State Transducer Cascade to Extract Proper Names in Texts;This article describes a finite-state cascade for the extraction of person names in texts in French. We extract these proper names in order to categorize and to cluster texts with them. After a finite-state pre-processing (division of the text in sentences, tagging with dictionaries, etc.), a series of finite-state transducers is applied one after the other to the text and locates left and right contexts that indicates the presence of a person name. An evaluation of the results of this extraction is presented.
19;Tamás Gaál;;Is this Finite-State Transducer Sequentiable?;Sequentiality is a desirable property of finite state transducers: such transducers are optimal for time efficiency. Not all transducers are sequentiable. Sequentialization algorithms of finite state transducers do not recognize whether a transducer is sequentiable or not and simply do not ever halt when it is not. Choffrut proved that sequentiality of finite state transducers is decidable. Béal et al. have proposed squaring to decide sequentiality. We propose a different procedure, which, with ε-closure extension, is able to handle letter transducers with arbitrary ε-ambiguities, too. Our algorithm is more economical than squaring, in terms of size. In different cases of non-sequentiability necessary and sufficient conditions of the ambiguity class of the transducer can be observed. These ambiguities can be mapped bijectively to particular basic patterns in the structure of the transducer. These patterns can be recognized, using finite state methods, in any transducer.
19;Jorge Graña;Fco. Mario Barcala, Miguel A. Alonso;Compilation Methods of Minimal Acyclic Finite-State Automata for Large Dictionaries;We present a reflection on the evolution of the different methods for constructing minimal deterministic acyclic finite-state automata from a finite set of words. We outline the most important methods, including the traditional ones (which consist of the combination of two phases: insertion of words and minimization of the partial automaton) and the incremental algorithms (which add new words one by one and minimize the resulting automaton on-the-fly, being much faster and having significantly lower memory requirements). We analyze their main features in order to provide some improvements for incremental constructions, and a general architecture that is needed to implement large dictionaries in natural language processing (NLP) applications.
19;Fco. Mario Barcala;Jorge Graña, Miguel A. Alonso;Compilation Methods of Minimal Acyclic Finite-State Automata for Large Dictionaries;We present a reflection on the evolution of the different methods for constructing minimal deterministic acyclic finite-state automata from a finite set of words. We outline the most important methods, including the traditional ones (which consist of the combination of two phases: insertion of words and minimization of the partial automaton) and the incremental algorithms (which add new words one by one and minimize the resulting automaton on-the-fly, being much faster and having significantly lower memory requirements). We analyze their main features in order to provide some improvements for incremental constructions, and a general architecture that is needed to implement large dictionaries in natural language processing (NLP) applications.
19;Miguel A. Alonso;Jorge Graña, Fco. Mario Barcala;Compilation Methods of Minimal Acyclic Finite-State Automata for Large Dictionaries;We present a reflection on the evolution of the different methods for constructing minimal deterministic acyclic finite-state automata from a finite set of words. We outline the most important methods, including the traditional ones (which consist of the combination of two phases: insertion of words and minimization of the partial automaton) and the incremental algorithms (which add new words one by one and minimize the resulting automaton on-the-fly, being much faster and having significantly lower memory requirements). We analyze their main features in order to provide some improvements for incremental constructions, and a general architecture that is needed to implement large dictionaries in natural language processing (NLP) applications.
19;Jan Holub;;Bit Parallelism - NFA Simulation;This paper deals with one of possibilities of use of nondeterministic finite automaton (NFA) — simulation of NFA using the method called bit parallelism. After a short presentation of the basic simulation method, the bit parallelism is presented on one of the pattern matching problems. Then a flexibility of the bit parallelism is demonstrated by a simulation of NFAs for other pattern matching problems.
19;Markus Holzer;Martin Kutrib;Improving Raster Image Run-Length Encoding Using Data Order;We examine the technique of run-length encoding in combination with data order, where our attention is focused on good performance of image operations such as, e.g., rotation, reflection, and zooming. To this end we develop a new type of data order that supports these operations well and allows to perform them on a variant of a double-queue automaton directly on the compressed data stream. Because of its shape we call this data order shamrock or S-order. To confirm our theoretical results on S-order we have performed some experiments on sample data using various data orderings that appear in the literature.
19;Martin Kutrib;Markus Holzer;Improving Raster Image Run-Length Encoding Using Data Order;We examine the technique of run-length encoding in combination with data order, where our attention is focused on good performance of image operations such as, e.g., rotation, reflection, and zooming. To this end we develop a new type of data order that supports these operations well and allows to perform them on a variant of a double-queue automaton directly on the compressed data stream. Because of its shape we call this data order shamrock or S-order. To confirm our theoretical results on S-order we have performed some experiments on sample data using various data orderings that appear in the literature.
19;Frank Katritzke;Wolfgang Merzenich, Michael Thomas;Enhancements of Partitioning Techniques for Image Compression Using Weighted Finite Automata;WFAs (weighted finite automata) are efficient structures for the storage of digital images. The choice of the image partitioning technique is important to achieve good compression results. In this paper we examine the fitness of various promising techniques by measuring the compression performance at well-known test images.
19;Wolfgang Merzenich;Frank Katritzke, Michael Thomas;Enhancements of Partitioning Techniques for Image Compression Using Weighted Finite Automata;WFAs (weighted finite automata) are efficient structures for the storage of digital images. The choice of the image partitioning technique is important to achieve good compression results. In this paper we examine the fitness of various promising techniques by measuring the compression performance at well-known test images.
19;Michael Thomas;Frank Katritzke, Wolfgang Merzenich;Enhancements of Partitioning Techniques for Image Compression Using Weighted Finite Automata;WFAs (weighted finite automata) are efficient structures for the storage of digital images. The choice of the image partitioning technique is important to achieve good compression results. In this paper we examine the fitness of various promising techniques by measuring the compression performance at well-known test images.
19;André Kempe;;Extraction of ε-Cycles from Finite-State Transducers;Much attention has been brought to determinization and ε-removal in previous work. This article describes an algorithm for extracting all ε-cycles, which are a special type of non-determinism, from an arbitrary finite-state transducer (FST). The algorithm factorizes (decomposes) the FST, T, into two FSTs, T1 and T2, such that T1 contains no ε-cycles and T2 contains all ε-cycles of T. Since ε-cycles are an obstacle for some algorithms such as the factorization of ambiguous FSTs, the proposed approach allows us to by-pass this problem. ε-cycles can be extracted before and re-inserted (by composition) after such algorithms.
19;Bořivoj Melichar;Jan Skryja;On the Size of Deterministic Finite Automata;The number of states of a deterministic finite automaton, which is equivalent to a nondeterministic finite automaton is bounded by 2n, where n is the number of states of the nondeterministic finite automaton. This bound is very pesimistic. Some subclasses of finite automata are shown, for which the complexity of determinization is far lower. On the base of pioneering idea of homogenous finite automata, two classes of finite automata are defined and the complexity of their determinization are shown. These classes are called generalized homogenous finite automata and semihomogenous finite automata.
19;Jan Skryja;Bořivoj Melichar;On the Size of Deterministic Finite Automata;The number of states of a deterministic finite automaton, which is equivalent to a nondeterministic finite automaton is bounded by 2n, where n is the number of states of the nondeterministic finite automaton. This bound is very pesimistic. Some subclasses of finite automata are shown, for which the complexity of determinization is far lower. On the base of pioneering idea of homogenous finite automata, two classes of finite automata are defined and the complexity of their determinization are shown. These classes are called generalized homogenous finite automata and semihomogenous finite automata.
19;Jim Morey;Kamran Sedig, Robert E. Mercer, Wayne Wilson;Crystal Lattice Automata;A description of crystal lattices in terms of automata is presented. The words of a language represented by an automata are mapped to points in R2 and R3 defining lattice points and their connections. These automata descriptions of crystal lattices reveal subtle properties that are difficult to see in other descriptions. A few applications of these automata are discussed.
19;Kamran Sedig;Jim Morey, Robert E. Mercer, Wayne Wilson;Crystal Lattice Automata;A description of crystal lattices in terms of automata is presented. The words of a language represented by an automata are mapped to points in R2 and R3 defining lattice points and their connections. These automata descriptions of crystal lattices reveal subtle properties that are difficult to see in other descriptions. A few applications of these automata are discussed.
19;Robert E. Mercer;Jim Morey, Kamran Sedig, Wayne Wilson;Crystal Lattice Automata;A description of crystal lattices in terms of automata is presented. The words of a language represented by an automata are mapped to points in R2 and R3 defining lattice points and their connections. These automata descriptions of crystal lattices reveal subtle properties that are difficult to see in other descriptions. A few applications of these automata are discussed.
19;Wayne Wilson;Jim Morey, Kamran Sedig, Robert E. Mercer;Crystal Lattice Automata;A description of crystal lattices in terms of automata is presented. The words of a language represented by an automata are mapped to points in R2 and R3 defining lattice points and their connections. These automata descriptions of crystal lattices reveal subtle properties that are difficult to see in other descriptions. A few applications of these automata are discussed.
19;Nadia Nedjah;Luiza de Macedo Mourelle;Minimal Adaptive Pattern-Matching Automata for Efficient Term Rewriting;In term rewriting systems, pattern-matching is performed according to a prescribed traversal order. By adapting the traversal order to suit the patterns of the rewriting system, it is often possible to obtain better matching automata in the sense that they have a smaller size and allow term matching in shorter time, compared with the left-to-right automaton. They may improve termination properties too. Space requirement is reduced further using a directed acyclic graph automaton that shares all the equivalent subautomata. This is done without altering either the matching time or termination properties. Isomorphic subautomata are duplicated in the tree-based automata. We discuss and develop an efficient approach to space requirement optimisation, matching time and termination properties improvement.
19;Luiza de Macedo Mourelle;Nadia Nedjah;Minimal Adaptive Pattern-Matching Automata for Efficient Term Rewriting;In term rewriting systems, pattern-matching is performed according to a prescribed traversal order. By adapting the traversal order to suit the patterns of the rewriting system, it is often possible to obtain better matching automata in the sense that they have a smaller size and allow term matching in shorter time, compared with the left-to-right automaton. They may improve termination properties too. Space requirement is reduced further using a directed acyclic graph automaton that shares all the equivalent subautomata. This is done without altering either the matching time or termination properties. Isomorphic subautomata are duplicated in the tree-based automata. We discuss and develop an efficient approach to space requirement optimisation, matching time and termination properties improvement.
20;David Harel;Hillel Kugler;Synthesizing State-Based Object Systems from LSC Specifications;Live sequence charts (LSCs) have been defined recently as an extension of message sequence charts (MSCs. or their UML variant, sequence diagrams) for rich inter-object specification. One of the main additions is the notion of universal charts and hot, mandatory behavior, which, among other things, enables one to specify forbidden scenarios. LSCs are thus essentially as expressive as statecharts. This paper deals with synthesis, which is the problem of deciding, given an LSC specification, if there exists a satisfying object system and, if so, to synthesize one automatically. The synthesis problem is crucial in the development of complex systems, since sequence diagrams serve as the manifestation of use cases — whether used formally or informally — and if synthesizable they could lead directly to implementation. Synthesis is considerably harder for LSCs than for MSCs, and we tackle it by defining consistency, showing that an entire LSC specification is consistent iff it is satisfiable by a state-based object system, and then synthesizing a satisfying system as a collection of finite state machines or statecharts.
20;Hillel Kugler;David Harel;Synthesizing State-Based Object Systems from LSC Specifications;Live sequence charts (LSCs) have been defined recently as an extension of message sequence charts (MSCs. or their UML variant, sequence diagrams) for rich inter-object specification. One of the main additions is the notion of universal charts and hot, mandatory behavior, which, among other things, enables one to specify forbidden scenarios. LSCs are thus essentially as expressive as statecharts. This paper deals with synthesis, which is the problem of deciding, given an LSC specification, if there exists a satisfying object system and, if so, to synthesize one automatically. The synthesis problem is crucial in the development of complex systems, since sequence diagrams serve as the manifestation of use cases — whether used formally or informally — and if synthesizable they could lead directly to implementation. Synthesis is considerably harder for LSCs than for MSCs, and we tackle it by defining consistency, showing that an entire LSC specification is consistent iff it is satisfiable by a state-based object system, and then synthesizing a satisfying system as a collection of finite state machines or statecharts.
20;Lauri Karttunen;;Applications of Finite-State Transducers in Natural Language Processing;This paper is a review of some of the major applications of finite-state transducers in Natural Language Processing ranging from morphological analysis to finite-state parsing. The analysis and generation of inflected word forms can be performed efficiently by means of lexical transducers. Such transducers can be compiled using an extended regular expression calculus with restriction and replacement operators. These operators facilitate the description of complex linguistic phenomena involving morphological alternations and syntactic patterns. Because regular languages and relations can be encoded as finite-automata, new languages and relations can be derived from them directly by the finite-state calculus. This is a fundamental advantage over higher-level linguistic formalisms.
20;Anne Bergeron;Sylvie Hamel;Fast Implementations of Automata Computations;In [6], G. Myers describes a bit-vector algorithm to compute the edit distance between strings. The algorithm converts an input sequence to an output sequence in a parallel way, using bit operations readily available in processors.
20;Sylvie Hamel;Anne Bergeron;Fast Implementations of Automata Computations;In [6], G. Myers describes a bit-vector algorithm to compute the edit distance between strings. The algorithm converts an input sequence to an output sequence in a parallel way, using bit operations readily available in processors.
20;Anne Brüggemann-Klein;Derick Wood;Regularly Extended Two-Way Nondeterministic Tree Automata;We establish that regularly extended two-way nondeterministic tree automata with unranked alphabets have the same expressive power as regularly extended nondeterministic tree automata with unranked alphabets. We obtain this result by establishing regularly extended versions of a congruence on trees and of a congruence on, so called, views. Our motivation for the study of these tree models is the Extensible Markup Language (XML), a metalanguage for defining document grammars. Such grammars have regular sets of right-hand sides for their productions and tree automata provide an alternative and useful modeling tool for them. In particular, we believe that they provide a useful computational model for what we call caterpillar expressions.
20;Derick Wood;Anne Brüggemann-Klein;Regularly Extended Two-Way Nondeterministic Tree Automata;We establish that regularly extended two-way nondeterministic tree automata with unranked alphabets have the same expressive power as regularly extended nondeterministic tree automata with unranked alphabets. We obtain this result by establishing regularly extended versions of a congruence on trees and of a congruence on, so called, views. Our motivation for the study of these tree models is the Extensible Markup Language (XML), a metalanguage for defining document grammars. Such grammars have regular sets of right-hand sides for their productions and tree automata provide an alternative and useful modeling tool for them. In particular, we believe that they provide a useful computational model for what we call caterpillar expressions.
20;Pascal Caron;Marianne Flouret;Glushkov Construction for Multiplicities;We present an extension to multiplicities of a classical algorithm for computing a boolean automaton from a regular expression. The Glushkov construction computes an automaton with n + 1 states from a regular expression with n occurences of letters. We show that the Glushkov algorithm still suits to the multiplicity case. Next, we give three equivalent extended step by step algorithm
20;Marianne Flouret;Pascal Caron;Glushkov Construction for Multiplicities;We present an extension to multiplicities of a classical algorithm for computing a boolean automaton from a regular expression. The Glushkov construction computes an automaton with n + 1 states from a regular expression with n occurences of letters. We show that the Glushkov algorithm still suits to the multiplicity case. Next, we give three equivalent extended step by step algorithm
20;Jean-Marc Champarnaud;;Implicit Structures to Implement NFA’s from Regular Expressions;The aim of this paper is to compare three efficient representations of the position automaton of a regular expression: the Thompson ε-automaton, the ZPC-structure and the F-structure, an optimization of the ZPC-structure. These representations are linear w.r.t. the sizes of the expression, since their construction is in O(s) space and time, as well as the computation of the set δ(X, a) of the targets of the transitions by a of any subset X of states. The comparison is based on the evaluation of the number of edges of the underlying graphs respectively created by the construction step or visited by the computation of a set δ(X, a).
20;Jean-Marc Champarnaud;D. Ziadi;New Finite Automaton Constructions Based on Canonical Derivatives;Two classical constructions to convert a regular expression into a finite non-deterministic automaton provide complementary advantages: the notion of position of a symbol in an expression, introduced by Glushkov and McNaugthon-Yamada, leads to an efficient computation of the position automaton (there exist quadratic space and time implementations w.r.t. the size of the expression), whereas the notion of derivative of an expression w.r.t. a word, due to Brzozowski, and generalized by Antimirov, yields a small automaton. The number of states of this automaton, called the equation automaton, is less than or equal to the number of states of the position automaton, and in practice it is generally much smaller. So far, algorithms to build the equation automaton, such as Mirkin’s or Antimirov’s ones, have a high space and time complexity. The aim of this paper is to present new theoretical results allowing to compute the equation automaton in quadratic space and time, improving by a cubic factor Antimirov’s construction. These results lay on the computation of a new kind of derivative, called canonical derivative, which makes it possible to connect the notion of continuation in a linear expression due to Berry and Sethi, and the notion of partial derivative of a regular expression due to Antimirov. A main interest of the notion of canonical derivative is that it leads to an efficient computation of the equation automaton via a specific reduction of the position automaton.
20;D. Ziadi;Jean-Marc Champarnaud;New Finite Automaton Constructions Based on Canonical Derivatives;Two classical constructions to convert a regular expression into a finite non-deterministic automaton provide complementary advantages: the notion of position of a symbol in an expression, introduced by Glushkov and McNaugthon-Yamada, leads to an efficient computation of the position automaton (there exist quadratic space and time implementations w.r.t. the size of the expression), whereas the notion of derivative of an expression w.r.t. a word, due to Brzozowski, and generalized by Antimirov, yields a small automaton. The number of states of this automaton, called the equation automaton, is less than or equal to the number of states of the position automaton, and in practice it is generally much smaller. So far, algorithms to build the equation automaton, such as Mirkin’s or Antimirov’s ones, have a high space and time complexity. The aim of this paper is to present new theoretical results allowing to compute the equation automaton in quadratic space and time, improving by a cubic factor Antimirov’s construction. These results lay on the computation of a new kind of derivative, called canonical derivative, which makes it possible to connect the notion of continuation in a linear expression due to Berry and Sethi, and the notion of partial derivative of a regular expression due to Antimirov. A main interest of the notion of canonical derivative is that it leads to an efficient computation of the equation automaton via a specific reduction of the position automaton.
20;Jan Daciuk;;Experiments with Automata Compression;Several compression methods of finite-state automata are presented and evaluated. Most compression methods used here are already described in the literature. However, their impact on the size of automata has not been described yet. We fill that gap, presenting results of experiments carried out on automata representing German, and Dutch morphological dictionaries.
20;Frank Drewes;Sigrid Ewert, Renate Klempien-Hinrichs, Hans-Jörg Kreowski;Computing Raster Images from Grid Picture Grammars;While a 2-dimensional grid picture grammar may generate pictures (defined as subsets of the unit square) with arbitrarily small details, only a finite number of them can be made visible as raster images for any given raster. We present an algorithm based on bottom-up tree automata which computes the set of all raster images of the pictures generated by a given grid picture grammar.
20;Sigrid Ewert;Frank Drewes, Renate Klempien-Hinrichs, Hans-Jörg Kreowski;Computing Raster Images from Grid Picture Grammars;While a 2-dimensional grid picture grammar may generate pictures (defined as subsets of the unit square) with arbitrarily small details, only a finite number of them can be made visible as raster images for any given raster. We present an algorithm based on bottom-up tree automata which computes the set of all raster images of the pictures generated by a given grid picture grammar.
20;Renate Klempien-Hinrichs;Frank Drewes, Sigrid Ewert, Hans-Jörg Kreowski;Computing Raster Images from Grid Picture Grammars;While a 2-dimensional grid picture grammar may generate pictures (defined as subsets of the unit square) with arbitrarily small details, only a finite number of them can be made visible as raster images for any given raster. We present an algorithm based on bottom-up tree automata which computes the set of all raster images of the pictures generated by a given grid picture grammar.
20;Hans-Jörg Kreowski;Frank Drewes, Sigrid Ewert, Renate Klempien-Hinrichs;Computing Raster Images from Grid Picture Grammars;While a 2-dimensional grid picture grammar may generate pictures (defined as subsets of the unit square) with arbitrarily small details, only a finite number of them can be made visible as raster images for any given raster. We present an algorithm based on bottom-up tree automata which computes the set of all raster images of the pictures generated by a given grid picture grammar.
20;Jacques Farré;José Fortes Gálvez;A Basis for Looping Extensions to Discriminating-Reverse Parsing;We present a noncanonical extension to the Discriminating Reverse parsing method, which accepts non-LR grammars. In cases of parsing conflict, actions are deferred and a mark is virtually pushed onto the parsing stack. Then, locally-canonical DR parsing resumes until sufficient right context is read to resolve the initial conflict. Marks code coverings of the right contexts that are compatible with the actions in conflict. A suboptimal solution for such a coding is proposed, which is computed from the DR automaton itself. The stack vocabulary is enlarged with the mark set, but no new state is added to the basic DR automaton. Moreover, conflict resolution basically uses the DR parser. The method determines at construction time whether all the conflicts can be resolved, and only produces deterministic parsers.
20;José Fortes Gálvez;Jacques Farré;A Basis for Looping Extensions to Discriminating-Reverse Parsing;We present a noncanonical extension to the Discriminating Reverse parsing method, which accepts non-LR grammars. In cases of parsing conflict, actions are deferred and a mark is virtually pushed onto the parsing stack. Then, locally-canonical DR parsing resumes until sufficient right context is read to resolve the initial conflict. Marks code coverings of the right contexts that are compatible with the actions in conflict. A suboptimal solution for such a coding is proposed, which is computed from the DR automaton itself. The stack vocabulary is enlarged with the mark set, but no new state is added to the basic DR automaton. Moreover, conflict resolution basically uses the DR parser. The method determines at construction time whether all the conflicts can be resolved, and only produces deterministic parsers.
20;Pierre-Cyrille Héam;;Automata for Pro-V Topologies;In this paper, we give an automata theoretic version of several algorithms dealing with profinite topologies. The profinite topology was first introduced for the free group by M. Hall, Jr. and by Reutenauer for the free monoid. It is the initial topology defined by all the monoid morphisms from the free monoid into a discrete finite group. For a variety of finite groups V, the pro-V topology is defined in the same way by replacing “group” by “group in V” in the definition. Recently, by a geometric approach, Steinberg developed an efficient algorithm to compute the closure, for some pro-V topologies (including the profinite one), of a rational language given by a finite automaton. In this paper we show that these algorithms can be obtained by an automata theoretic approach by using a result of Pin and Reutenauer. We also analyze precisely the complexity of these algorithms.
20;Oscar H. Ibarra;;Reachability and Safety in Queue Systems;We look at a model of a queue system M that consists of the following components:
20;Oscar H. Ibarra;Jianwen Su;Generalizing the Discrete Timed Automaton;We describe a general automata-theoretic approach for analyzing the verification problems (binary reachability, safety, etc.) of discrete timed automata augmented with various data structures. We give examples of such data structures and exhibit some new properties of discrete timed automata that can be verified. We also briefly consider reachability in discrete timed automata operating in parallel.
20;Jianwen Su;Oscar H. Ibarra;Generalizing the Discrete Timed Automaton;We describe a general automata-theoretic approach for analyzing the verification problems (binary reachability, safety, etc.) of discrete timed automata augmented with various data structures. We give examples of such data structures and exhibit some new properties of discrete timed automata that can be verified. We also briefly consider reachability in discrete timed automata operating in parallel.
20;André Kempe;;Factorization of Ambiguous Finite-State Transducers;This article describes an algorithm for factorizing a finitely ambiguous finite-state transducer (FST) into two FSTs, T1 and T2, such that T1 is functional and T2 retains the ambiguity of the original FST. The application of T2 to the output of T1 never leads to a state that does not provide a transition for the next input symbol, and always terminates in a final state. In other words, T2 contains no “failing paths” whereas T1 in general does. Since T1 is functional, it can be factorized into a left-sequential and a right-sequential FST that jointly constitute a bimachine. The described factorization can accelerate the processing of input because no failing paths are ever followed.
20;Nils Klarlund;Anders Møller, Michael I. Schwartzbach;MONA Implementation Secrets;The Mona tool provides an implementation of the decision procedures for the logics WS1S and WS2S. It has been used for numerous applications, and it is remarkably efficient in practice, even though it faces a theoretically non-elementary worst-case complexity. The implementation has matured over a period of six years. Compared to the first naive version, the present tool is faster by several orders of magnitude. This speedup is obtained from many different contributions working on all levels of the compilation and execution of formulas. We present a selection of implementation “secrets” that have been discovered and tested over the years, including formula reductions, DAGification, guided tree automata, three-valued logic, eager minimization, BDD-based automata representations, and cache-conscious data structures. We describe these techniques and quantify their respective effects by experimenting with separate versions of the Mona tool that in turn omit each of them.
20;Anders Møller;Nils Klarlund, Michael I. Schwartzbach;MONA Implementation Secrets;The Mona tool provides an implementation of the decision procedures for the logics WS1S and WS2S. It has been used for numerous applications, and it is remarkably efficient in practice, even though it faces a theoretically non-elementary worst-case complexity. The implementation has matured over a period of six years. Compared to the first naive version, the present tool is faster by several orders of magnitude. This speedup is obtained from many different contributions working on all levels of the compilation and execution of formulas. We present a selection of implementation “secrets” that have been discovered and tested over the years, including formula reductions, DAGification, guided tree automata, three-valued logic, eager minimization, BDD-based automata representations, and cache-conscious data structures. We describe these techniques and quantify their respective effects by experimenting with separate versions of the Mona tool that in turn omit each of them.
20;Michael I. Schwartzbach;Nils Klarlund, Anders Møller;MONA Implementation Secrets;The Mona tool provides an implementation of the decision procedures for the logics WS1S and WS2S. It has been used for numerous applications, and it is remarkably efficient in practice, even though it faces a theoretically non-elementary worst-case complexity. The implementation has matured over a period of six years. Compared to the first naive version, the present tool is faster by several orders of magnitude. This speedup is obtained from many different contributions working on all levels of the compilation and execution of formulas. We present a selection of implementation “secrets” that have been discovered and tested over the years, including formula reductions, DAGification, guided tree automata, three-valued logic, eager minimization, BDD-based automata representations, and cache-conscious data structures. We describe these techniques and quantify their respective effects by experimenting with separate versions of the Mona tool that in turn omit each of them.
20;Vincent Le Maout;;Cursors;The iterator concept is becoming the fundamental abstraction of reusable software and the key to modularity and clean code especially in object-oriented languages like C++ and Java. They serve as accessors to a sequence hiding the implementation details from the algorithm and their encapsulation power allows true generic programming. The Standard Template Library defines clearly their behavior on simple sequences like linked lists or vectors. In this paper, we define the concept of cursor which can be seen as a generalization of the iterator concept to more complex data structures than sequences, in this case acyclic automata. We show how elegant and efficient they can be on applications written in C++ and based on the Automaton Standard Template Library.
20;K. Lodaya;R. Ramanujam;An Automaton Model of User-Controlled Navigation on the Web;We present a simple theoretical model of web navigation, in which each WWW user creates style specifications which constrain web browsing, search and navigation using the user’s own judgement of the quality of visited sites. A finite state automaton is associated with each specification, which is presented in a two-level modal logic making up the acceptance condition for the automaton. We show that many interesting queries regarding the user’s web search can be answered using standard automata theory.
20;R. Ramanujam;K. Lodaya;An Automaton Model of User-Controlled Navigation on the Web;We present a simple theoretical model of web navigation, in which each WWW user creates style specifications which constrain web browsing, search and navigation using the user’s own judgement of the quality of visited sites. A finite state automaton is associated with each specification, which is presented in a two-level modal logic making up the acceptance condition for the automaton. We show that many interesting queries regarding the user’s web search can be answered using standard automata theory.
20;Stoyan Mihov;Denis Maurel;Direct Construction of Minimal Acyclic Subsequential Transducers;This paper presents an algorithm for direct building of minimal acyclic subsequential transducer, which represents a finite relation given as a sorted list of words with their outputs. The algorithm constructs the minimal transducer directly - without constructing intermediate tree-like or pseudo-minimal transducers. In NLP applications our algorithm provides significantly better efficiency than the other algorithms building minimal transducer for large-scale natural language dictionaries. Some experimental comparisons are presented at the end of the paper.
20;Denis Maurel;Stoyan Mihov;Direct Construction of Minimal Acyclic Subsequential Transducers;This paper presents an algorithm for direct building of minimal acyclic subsequential transducer, which represents a finite relation given as a sorted list of words with their outputs. The algorithm constructs the minimal transducer directly - without constructing intermediate tree-like or pseudo-minimal transducers. In NLP applications our algorithm provides significantly better efficiency than the other algorithms building minimal transducer for large-scale natural language dictionaries. Some experimental comparisons are presented at the end of the paper.
20;Mehryar Mohri;;Generic ε-Removal Algorithm for Weighted Automata;We present a new generic ε-removal algorithm for weighted automata and transducers defined over a semiring. The algorithm can be used with any semiring covered by our framework and works with any queue discipline adopted. It can be used in particular in the case of unweighted automata and transducers and weighted automata and transducers defined over the tropical semiring. It is based on a general shortest-distance algorithm that we briefly describe. We give a full description of the algorithm including its pseudocode and its running time complexity, discuss the more efficient case of acyclic automata, an on-the-fly implementation of the algorithm and an approximation algorithm in the case of the semirings not covered by our framework. We also illustrate the use of the algorithm with several semirings.
21;Jérôme Amilhastre;Philippe Janssen, Marie-Catherine Vilarem;FA Minimisation Heuristics for a Class of Finite Languages;In this paper, we deal with minimization of finite automata associated with finite languages all the words have the same length. This problem arises in the context of Constraint Satisfaction Problems, widely used in AI. We first give some complexity results which are based on the strong relationship with covering problems of bipartite graphs. We then use these coverings as a basic tool for the definition of minimization heuristics, and describe some experimental results.
21;Philippe Janssen;Jérôme Amilhastre, Marie-Catherine Vilarem;FA Minimisation Heuristics for a Class of Finite Languages;In this paper, we deal with minimization of finite automata associated with finite languages all the words have the same length. This problem arises in the context of Constraint Satisfaction Problems, widely used in AI. We first give some complexity results which are based on the strong relationship with covering problems of bipartite graphs. We then use these coverings as a basic tool for the definition of minimization heuristics, and describe some experimental results.
21;Marie-Catherine Vilarem;Jérôme Amilhastre, Philippe Janssen;FA Minimisation Heuristics for a Class of Finite Languages;In this paper, we deal with minimization of finite automata associated with finite languages all the words have the same length. This problem arises in the context of Constraint Satisfaction Problems, widely used in AI. We first give some complexity results which are based on the strong relationship with covering problems of bipartite graphs. We then use these coverings as a basic tool for the definition of minimization heuristics, and describe some experimental results.
21;Philippe Andary;Pascal Caron, Jean-Marc Champarnaud, Gérard Duchamp, Marianne Flouret, Éric Laugerotte;SEA: A Symbolic Environment for Automata Theory;We here present the system SEA which integrates manipulations over boolean and multiplicity automata. The system provides also self development facilities.
21;Pascal Caron;Philippe Andary, Jean-Marc Champarnaud, Gérard Duchamp, Marianne Flouret, Éric Laugerotte;SEA: A Symbolic Environment for Automata Theory;We here present the system SEA which integrates manipulations over boolean and multiplicity automata. The system provides also self development facilities.
21;Jean-Marc Champarnaud;Philippe Andary, Pascal Caron, Gérard Duchamp, Marianne Flouret, Éric Laugerotte;SEA: A Symbolic Environment for Automata Theory;We here present the system SEA which integrates manipulations over boolean and multiplicity automata. The system provides also self development facilities.
21;Gérard Duchamp;Philippe Andary, Pascal Caron, Jean-Marc Champarnaud, Marianne Flouret, Éric Laugerotte;SEA: A Symbolic Environment for Automata Theory;We here present the system SEA which integrates manipulations over boolean and multiplicity automata. The system provides also self development facilities.
21;Marianne Flouret;Philippe Andary, Pascal Caron, Jean-Marc Champarnaud, Gérard Duchamp, Éric Laugerotte;SEA: A Symbolic Environment for Automata Theory;We here present the system SEA which integrates manipulations over boolean and multiplicity automata. The system provides also self development facilities.
21;Éric Laugerotte;Philippe Andary, Pascal Caron, Jean-Marc Champarnaud, Gérard Duchamp, Marianne Flouret;SEA: A Symbolic Environment for Automata Theory;We here present the system SEA which integrates manipulations over boolean and multiplicity automata. The system provides also self development facilities.
21;Anne Bergeron;Riccardo Catalano;Analysis of Reactive Systems with n Timers;In this paper, we develop theoretical, as well as practical, tools for the synthesis and the verification of processes that contain n timers. Such tools are equally adapted to numerical calculations as to symbolical ones, thus allowing for parametric analysis. The results we have obtained rely on a simple and efficient representation of the states of an automaton that recognizes the behaviors of the process. This representation is based on a mechanical structure which helps us encode the states in a compact manner and leads to simple algorithms.
21;Riccardo Catalano;Anne Bergeron;Analysis of Reactive Systems with n Timers;In this paper, we develop theoretical, as well as practical, tools for the synthesis and the verification of processes that contain n timers. Such tools are equally adapted to numerical calculations as to symbolical ones, thus allowing for parametric analysis. The results we have obtained rely on a simple and efficient representation of the states of an automaton that recognizes the behaviors of the process. This representation is based on a mechanical structure which helps us encode the states in a compact manner and leads to simple algorithms.
21;Beatrix Braune;Stephan Diehl, Andreas Kerren, Reinhard Wilhelm;Animation of the Generation and Computation of Finite Automata for Learning Software;In computer science methods to aid learning are very important, because abstract models are used frequently. For this conventional teaching methods do not suffice. We have developed a learning software, that helps the learner to better understand principles of compiler construction, in particular lexical analysis. The software offers on the one hand an interactive introduction to the problems of lexical analysis, in which the most important definitions and algorithms are presented in graphically appealing form. Animations show how finite automata are created from regular expressions, as well as, how finite automata work. We discuss principles used throughout the design of the software and give some preliminary results of evaluations of the software and discuss related work.
21;Stephan Diehl;Beatrix Braune, Andreas Kerren, Reinhard Wilhelm;Animation of the Generation and Computation of Finite Automata for Learning Software;In computer science methods to aid learning are very important, because abstract models are used frequently. For this conventional teaching methods do not suffice. We have developed a learning software, that helps the learner to better understand principles of compiler construction, in particular lexical analysis. The software offers on the one hand an interactive introduction to the problems of lexical analysis, in which the most important definitions and algorithms are presented in graphically appealing form. Animations show how finite automata are created from regular expressions, as well as, how finite automata work. We discuss principles used throughout the design of the software and give some preliminary results of evaluations of the software and discuss related work.
21;Andreas Kerren;Beatrix Braune, Stephan Diehl, Reinhard Wilhelm;Animation of the Generation and Computation of Finite Automata for Learning Software;In computer science methods to aid learning are very important, because abstract models are used frequently. For this conventional teaching methods do not suffice. We have developed a learning software, that helps the learner to better understand principles of compiler construction, in particular lexical analysis. The software offers on the one hand an interactive introduction to the problems of lexical analysis, in which the most important definitions and algorithms are presented in graphically appealing form. Animations show how finite automata are created from regular expressions, as well as, how finite automata work. We discuss principles used throughout the design of the software and give some preliminary results of evaluations of the software and discuss related work.
21;Reinhard Wilhelm;Beatrix Braune, Stephan Diehl, Andreas Kerren;Animation of the Generation and Computation of Finite Automata for Learning Software;In computer science methods to aid learning are very important, because abstract models are used frequently. For this conventional teaching methods do not suffice. We have developed a learning software, that helps the learner to better understand principles of compiler construction, in particular lexical analysis. The software offers on the one hand an interactive introduction to the problems of lexical analysis, in which the most important definitions and algorithms are presented in graphically appealing form. Animations show how finite automata are created from regular expressions, as well as, how finite automata work. We discuss principles used throughout the design of the software and give some preliminary results of evaluations of the software and discuss related work.
21;Cristian S. Calude;Kai Salomaa, Sheng Yu;Metric Lexical Analysis;We study automata-theoretic properties of distances and quasi-distances between words. We show that every additive distance is finite. We also show that every additive quasi-distance is regularitypreserving, that is, the neighborhood of any radius of a regular language with respect to an additive quasi-distance is regular. As an application we present a simple algorithm that constructs a metric (fault-tolerant) lexical analyzer for any given lexical analyzer and desired radius (faulttolerance index).
21;Kai Salomaa;Cristian S. Calude, Sheng Yu;Metric Lexical Analysis;We study automata-theoretic properties of distances and quasi-distances between words. We show that every additive distance is finite. We also show that every additive quasi-distance is regularitypreserving, that is, the neighborhood of any radius of a regular language with respect to an additive quasi-distance is regular. As an application we present a simple algorithm that constructs a metric (fault-tolerant) lexical analyzer for any given lexical analyzer and desired radius (faulttolerance index).
21;Sheng Yu;Cristian S. Calude, Kai Salomaa;Metric Lexical Analysis;We study automata-theoretic properties of distances and quasi-distances between words. We show that every additive distance is finite. We also show that every additive quasi-distance is regularitypreserving, that is, the neighborhood of any radius of a regular language with respect to an additive quasi-distance is regular. As an application we present a simple algorithm that constructs a metric (fault-tolerant) lexical analyzer for any given lexical analyzer and desired radius (faulttolerance index).
21;C. Câmpeanu;K. Culik II, Kai Salomaa, Sheng Yu;State Complexity of Basic Operations on Finite Languages;The state complexity of basic operations on regular languages has been studied in [9],[10],[11]. Here we focus on finite languages. We show that the catenation of two finite languages accepted by an mstate and an n-state DFA, respectively, with m &gt. n is accepted by a DFA of (m − n + 3)2n−2 − 1 states in the two-letter alphabet case, and this bound is shown to be reachable. We also show that the tight upperbounds for the number of states of a DFA that accepts the star of an n-state finite language is 2n−3 + 2n−4 in the two-letter alphabet case. The same bound for reversal is 3 · 2p−1 − 1 when n is even and 2p − 1 when n is odd. Results for alphabets of an arbitrary size are also obtained. These upper-bounds for finite languages are strictly lower than the corresponding ones for general regular languages.
21;K. Culik II;C. Câmpeanu, Kai Salomaa, Sheng Yu;State Complexity of Basic Operations on Finite Languages;The state complexity of basic operations on regular languages has been studied in [9],[10],[11]. Here we focus on finite languages. We show that the catenation of two finite languages accepted by an mstate and an n-state DFA, respectively, with m &gt. n is accepted by a DFA of (m − n + 3)2n−2 − 1 states in the two-letter alphabet case, and this bound is shown to be reachable. We also show that the tight upperbounds for the number of states of a DFA that accepts the star of an n-state finite language is 2n−3 + 2n−4 in the two-letter alphabet case. The same bound for reversal is 3 · 2p−1 − 1 when n is even and 2p − 1 when n is odd. Results for alphabets of an arbitrary size are also obtained. These upper-bounds for finite languages are strictly lower than the corresponding ones for general regular languages.
21;Kai Salomaa;C. Câmpeanu, K. Culik II, Sheng Yu;State Complexity of Basic Operations on Finite Languages;The state complexity of basic operations on regular languages has been studied in [9],[10],[11]. Here we focus on finite languages. We show that the catenation of two finite languages accepted by an mstate and an n-state DFA, respectively, with m &gt. n is accepted by a DFA of (m − n + 3)2n−2 − 1 states in the two-letter alphabet case, and this bound is shown to be reachable. We also show that the tight upperbounds for the number of states of a DFA that accepts the star of an n-state finite language is 2n−3 + 2n−4 in the two-letter alphabet case. The same bound for reversal is 3 · 2p−1 − 1 when n is even and 2p − 1 when n is odd. Results for alphabets of an arbitrary size are also obtained. These upper-bounds for finite languages are strictly lower than the corresponding ones for general regular languages.
21;Sheng Yu;C. Câmpeanu, K. Culik II, Kai Salomaa;State Complexity of Basic Operations on Finite Languages;The state complexity of basic operations on regular languages has been studied in [9],[10],[11]. Here we focus on finite languages. We show that the catenation of two finite languages accepted by an mstate and an n-state DFA, respectively, with m &gt. n is accepted by a DFA of (m − n + 3)2n−2 − 1 states in the two-letter alphabet case, and this bound is shown to be reachable. We also show that the tight upperbounds for the number of states of a DFA that accepts the star of an n-state finite language is 2n−3 + 2n−4 in the two-letter alphabet case. The same bound for reversal is 3 · 2p−1 − 1 when n is even and 2p − 1 when n is odd. Results for alphabets of an arbitrary size are also obtained. These upper-bounds for finite languages are strictly lower than the corresponding ones for general regular languages.
21;Jan Daciuk;;Treatment of Unknown Words;Words not present in the dictionary are almost always found in unrestricted texts. However, there is a need to obtain their likely base forms (in lemmatization), or morphological categories (in tagging), or both. Some of them find their ways into dictionaries, and it would be nice to predict what their entries should look like. Humans can perform those tasks using endings of words (sometimes prefixes and infixes as well), and so can do computers. Previous approaches used manually constructed lists of endings and associated information. Brill proposed transformation-based learning from corpora, and Mikheev used Brill’s approach on data for a morphological lexicon. However, both Brill’s algorithm, and Mikheev’s algorithm that is derived from Brill’s one, lack speed, both in the rule acquisition phase, and in the rule application phase. Their algorithms handle only the case of tagging, although an extension to other tasks seems possible. We propose a very fast finite-state method that handles all of the tasks described above, and that achieves similar quality of guessing.
21;Mark G. Eramian;;Computing Entropy Maps of Finite-Automaton-Encoded Binary Images;Finite automata are being used to encode images. Applications of this technique include image compression, and extraction of self similarity information and Hausdorff dimension of the encoded image. Jürgensen and Staiger [7] proposed a method by which the local Hausdorff dimension of the encoded image could be effectively computed. This paper describes the first implementation of this procedure and presents some experimental results showing local entropy maps computed from images represented by finite automata.
21;Dora Giammarresi;Jean-Luc Ponty, Derick Wood;Thompson Digraphs: A Characterization;A finite-state machine is called a Thompson machine if it can be constructed from a regular expression using Thompson’s construction. We call the underlying digraph of a Thompson machine a Thompson digraph. We establish and prove a characterization of Thompson digraphs. As one application of the characterization, we give an algorithm that generates an equivalent regular expression from a Thompson machine in time linear in the number of states.
21;Jean-Luc Ponty;Dora Giammarresi, Derick Wood;Thompson Digraphs: A Characterization;A finite-state machine is called a Thompson machine if it can be constructed from a regular expression using Thompson’s construction. We call the underlying digraph of a Thompson machine a Thompson digraph. We establish and prove a characterization of Thompson digraphs. As one application of the characterization, we give an algorithm that generates an equivalent regular expression from a Thompson machine in time linear in the number of states.
21;Derick Wood;Dora Giammarresi, Jean-Luc Ponty;Thompson Digraphs: A Characterization;A finite-state machine is called a Thompson machine if it can be constructed from a regular expression using Thompson’s construction. We call the underlying digraph of a Thompson machine a Thompson digraph. We establish and prove a characterization of Thompson digraphs. As one application of the characterization, we give an algorithm that generates an equivalent regular expression from a Thompson machine in time linear in the number of states.
21;Helmut Jürgensen;Ludwig Staiger;Finite Automata Encoding Geometric Figures;Finite automata are used for the encoding and compression of images. For black-and-white images, for instance, using the quad-tree representation, the black points correspond to ω-words defining the corresponding paths in the tree that lead to them. If the ω-language consisting of the set of all these words is accepted by a deterministic finite automaton then the image is said to be encodable as a finite automaton. For grey-level images and colour images similar representations by automata are in use.
21;Ludwig Staiger;Helmut Jürgensen;Finite Automata Encoding Geometric Figures;Finite automata are used for the encoding and compression of images. For black-and-white images, for instance, using the quad-tree representation, the black points correspond to ω-words defining the corresponding paths in the tree that lead to them. If the ω-language consisting of the set of all these words is accepted by a deterministic finite automaton then the image is said to be encodable as a finite automaton. For grey-level images and colour images similar representations by automata are in use.
21;George Anton Kiraz;;Compressed Storage of Sparse Finite-State Transducers;This paper presents an eclectic approach for compressing weighted finite-state automata and transducers, with minimal impact on performance. The approach is eclectic in the sense that various complementary methods have been employed: row-indexed storage of sparse matrices, dictionary compression, bit manipulation, and lossless omission of data. The compression rate is over 83% with respect to the current Bell Labs finite-state library.
21;Gertjan van Noord;Dale Gerdemann;An Extendible Regular Expression Compiler for Finite-State Approaches in Natural Language Processing;Finite-state techniques are widely used in various areas of Natural Language Processing (NLP).As Kaplan and Kay [12] have argued, regular expressions are the appropriate level of abstraction for thinking about finite-state languages and finite-state relations.More complex finite-state operations (such as contexted replacement) are defined on the basis of basic operations (such as Kleene closure, complementation, composition).
21;Dale Gerdemann;Gertjan van Noord;An Extendible Regular Expression Compiler for Finite-State Approaches in Natural Language Processing;Finite-state techniques are widely used in various areas of Natural Language Processing (NLP).As Kaplan and Kay [12] have argued, regular expressions are the appropriate level of abstraction for thinking about finite-state languages and finite-state relations.More complex finite-state operations (such as contexted replacement) are defined on the basis of basic operations (such as Kleene closure, complementation, composition).
21;Gheorghe Păun;Gabriel Thierrin;Multiset Processing by Means of Systems of Finite State Transducers;We introduce a computing mechanism of a biochemical inspiration (similar to a P system from the area of Computing with Membranes) which consists of a multiset of symbol-objects and a set of finite state transducers. The transducers process symbols in the current multiset in the usual manner. A computation starts in an initial configuration and ends in a halting configuration. The power of these mechanisms is investigated, as well as the closure properties of the obtained family. The main results say that (1) systems with two components and an unbounded number of states in each component generate all gsm images of all permutation closures of recursively enumerable languages, while (2) systems with two states in each component but an unbounded number of components can generate the permutation closures of all recursively enumerable languages, and (3) the obtained family is a full AFL. Result (2) is related to a possible (speculative) implementation of our systems in biochemical media.
21;Gabriel Thierrin;Gheorghe Păun;Multiset Processing by Means of Systems of Finite State Transducers;We introduce a computing mechanism of a biochemical inspiration (similar to a P system from the area of Computing with Membranes) which consists of a multiset of symbol-objects and a set of finite state transducers. The transducers process symbols in the current multiset in the usual manner. A computation starts in an initial configuration and ends in a halting configuration. The power of these mechanisms is investigated, as well as the closure properties of the obtained family. The main results say that (1) systems with two components and an unbounded number of states in each component generate all gsm images of all permutation closures of recursively enumerable languages, while (2) systems with two states in each component but an unbounded number of components can generate the permutation closures of all recursively enumerable languages, and (3) the obtained family is a full AFL. Result (2) is related to a possible (speculative) implementation of our systems in biochemical media.
21;M. Seuring;M. Gössel;A Structural Method for Output Compaction of Sequential Automata Implemented as Circuits;In this paper output space compaction for sequential circuits is considered for the first time. Based on simple estimates for the probabilities of the existence of sensitized paths from the signal lines to the circuit outputs, optimal output partitions can be determined without fault simulation. The outputs are partitioned in such a way that internal stuck-at faults influence at most one of the outputs of a group with high probability. The proposed method is primarily developed for concurrent checking. On average with less than 4 compacted groups of outputs an error detection probability of 98% can be achieved. As the experimental results show, the method is also effectively applicable in pseudo-random test mode. On average for three groups of compacted outputs there is no reduction of the fault coverage for a pseudo-random off-line test. Since the proposed algorithm is of linear complexity with respect to the number of circuit lines and of quadratic complexity with respect to the number of primary circuit outputs large automata can be efficiently processed.
21;M. Gössel;M. Seuring;A Structural Method for Output Compaction of Sequential Automata Implemented as Circuits;In this paper output space compaction for sequential circuits is considered for the first time. Based on simple estimates for the probabilities of the existence of sensitized paths from the signal lines to the circuit outputs, optimal output partitions can be determined without fault simulation. The outputs are partitioned in such a way that internal stuck-at faults influence at most one of the outputs of a group with high probability. The proposed method is primarily developed for concurrent checking. On average with less than 4 compacted groups of outputs an error detection probability of 98% can be achieved. As the experimental results show, the method is also effectively applicable in pseudo-random test mode. On average for three groups of compacted outputs there is no reduction of the fault coverage for a pseudo-random off-line test. Since the proposed algorithm is of linear complexity with respect to the number of circuit lines and of quadratic complexity with respect to the number of primary circuit outputs large automata can be efficiently processed.
21;A.N. Trahtman;;An Algorithm to Verify Local Threshold Testability of Deterministic Finite Automata;A locally threshold testable language L is a language with the property that for some nonnegative integers k and l, whether or not a word u is in the language L depends on (1) the prefix and suffix of the word u of length k-1 and (2) the set of intermediate substrings of length k of the word u where the sets of substrings occurring at least j times are the same, for j ≤ l. For given k and l the language is called l-threshold ktestable. A finite deterministic automaton is called l-threshold k-testable
21;Bruce W. Watson;;A Taxonomy of Algorithms for Constructing Minimal Acyclic Deterministic Finite Automata;In this paper, we present a taxonomy of algorithms for constructing minimal acyclic deterministic finite automata (MADFAs).Suc h automata represent finite languages and are therefore useful in applications such as storing words for spell-checking, computer and biological virus searching, text indexing and XML tag lookup.In such applications, the automata can grow extremely large (with more than 106 states) and are difficult to store without compression or minimization.
22;Jürgen Albert;Dora Giammaressi, Derick Wood;Extended Context-Free Grammars and Normal Form Algorithms;We investigate the complexity of a variety of normal-form transformations for extended context-free grammars, where by extended we mean that the set of right-hand sides for each nonterminal in such a grammar is a regular set. The study is motivated by the implementation project GraMa which will provide a C++ toolkit for the symbolic manipulation of context-free objects just as Grail does for regular objects. The results are that all transformations of interest take time linear in the size of the given grammar giving resulting grammars that are larger by a constant factor than the original grammar. Our results generalize known bounds for context-free grammars but do so in nontrivial ways. Specifically, we introduce a new representation scheme for extended context-free grammars (the symbol-threaded expression forest), a new normal form for these grammars (dot normal form) and new regular expression algorithms.
22;Dora Giammaressi;Jürgen Albert, Derick Wood;Extended Context-Free Grammars and Normal Form Algorithms;We investigate the complexity of a variety of normal-form transformations for extended context-free grammars, where by extended we mean that the set of right-hand sides for each nonterminal in such a grammar is a regular set. The study is motivated by the implementation project GraMa which will provide a C++ toolkit for the symbolic manipulation of context-free objects just as Grail does for regular objects. The results are that all transformations of interest take time linear in the size of the given grammar giving resulting grammars that are larger by a constant factor than the original grammar. Our results generalize known bounds for context-free grammars but do so in nontrivial ways. Specifically, we introduce a new representation scheme for extended context-free grammars (the symbol-threaded expression forest), a new normal form for these grammars (dot normal form) and new regular expression algorithms.
22;Derick Wood;Jürgen Albert, Dora Giammaressi;Extended Context-Free Grammars and Normal Form Algorithms;We investigate the complexity of a variety of normal-form transformations for extended context-free grammars, where by extended we mean that the set of right-hand sides for each nonterminal in such a grammar is a regular set. The study is motivated by the implementation project GraMa which will provide a C++ toolkit for the symbolic manipulation of context-free objects just as Grail does for regular objects. The results are that all transformations of interest take time linear in the size of the given grammar giving resulting grammars that are larger by a constant factor than the original grammar. Our results generalize known bounds for context-free grammars but do so in nontrivial ways. Specifically, we introduce a new representation scheme for extended context-free grammars (the symbol-threaded expression forest), a new normal form for these grammars (dot normal form) and new regular expression algorithms.
22;Norbert Blum;;On Parsing LL-Languages;Usually, a parser for an LL(k)-grammar G is a deterministic pushdown transducer which produces a leftmost derivation for a given input string x ∈ L(G). Ukkonen [<a aria-label="Reference 5" data-test="citation-ref" data-track="click" data-track-action="reference anchor" data-track-label="link" href="#ref-CR5" id="ref-link-section-d3675835e486" title="E. Ukkonen, Lower bound on the size of deterministic parsers, JCSS                        26 (1983), 153–170.">5] has given a family of LL(2)- grammars proving that every parser for these grammars has exponential size. If we add to a parser the possibility to manipulate a constant num- ber of pointers which point to positions within the constructed part of the leftmost derivation and to change the output in such positions, we obtain an extended parser for the LL(k)-grammar G. Given an arbitrary LL(k)-grammar G, we will show how to construct an extended parser of polynomial size manipulating at most k2 pointers.
22;Heiko Goeman;;On Parsing and Condensing Substrings of LR Languages in Linear Time;LR parsers have long been known as being an efficient algorithm for recognizing deterministic context-free grammars. In this article, we present a linear—time method for parsing substrings of LR languages. The algorithm depends on the LR automaton that is used for the usual parsing of complete sentences. We prove the correctness and linear complexity of our algorithm and present an interesting extension of our substring parser that allows to condense the input string, which increases the speed when reparsing that string for a second time.
22;Cezar Câmpeanu;Nicolae Sântean, Sheng Yu;Minimal Cover-Automata for Finite Languages;A cover-automaton A of a finite language L ⊆ Σ* is a finite automaton that accepts all words in L and possibly other words that are longer than any word in L. A minimal deterministic cover automaton of a finite language L usually has a smaller size than a minimal DFA that accept L. Thus, cover automata can be used to reduce the size of the representations of finite languages in practice. In this paper, we describe an efficient algorithm that, for a given DFA accepting a finite language, constructs a minimal deterministic finite coverautomaton of the language. We also give algorithms for the boolean operations on deterministic cover automata, i.e., on the finite languages they represent.
22;Nicolae Sântean;Cezar Câmpeanu, Sheng Yu;Minimal Cover-Automata for Finite Languages;A cover-automaton A of a finite language L ⊆ Σ* is a finite automaton that accepts all words in L and possibly other words that are longer than any word in L. A minimal deterministic cover automaton of a finite language L usually has a smaller size than a minimal DFA that accept L. Thus, cover automata can be used to reduce the size of the representations of finite languages in practice. In this paper, we describe an efficient algorithm that, for a given DFA accepting a finite language, constructs a minimal deterministic finite coverautomaton of the language. We also give algorithms for the boolean operations on deterministic cover automata, i.e., on the finite languages they represent.
22;Sheng Yu;Cezar Câmpeanu, Nicolae Sântean;Minimal Cover-Automata for Finite Languages;A cover-automaton A of a finite language L ⊆ Σ* is a finite automaton that accepts all words in L and possibly other words that are longer than any word in L. A minimal deterministic cover automaton of a finite language L usually has a smaller size than a minimal DFA that accept L. Thus, cover automata can be used to reduce the size of the representations of finite languages in practice. In this paper, we describe an efficient algorithm that, for a given DFA accepting a finite language, constructs a minimal deterministic finite coverautomaton of the language. We also give algorithms for the boolean operations on deterministic cover automata, i.e., on the finite languages they represent.
22;Jean-Marc Champarnaud;Djelloul Ziadi, Jean-Luc Ponty;Determinization of Glushkov Automata;We establish a new upper bound on the number of states of the automaton yielded by the determinization of a Glushkov automaton. We show that the ZPC structure, which is an implicit construction for Glushkov automata, leads to an efficient implementation of the subset construction.
22;Djelloul Ziadi;Jean-Marc Champarnaud, Jean-Luc Ponty;Determinization of Glushkov Automata;We establish a new upper bound on the number of states of the automaton yielded by the determinization of a Glushkov automaton. We show that the ZPC structure, which is an implicit construction for Glushkov automata, leads to an efficient implementation of the subset construction.
22;Jean-Luc Ponty;Jean-Marc Champarnaud, Djelloul Ziadi;Determinization of Glushkov Automata;We establish a new upper bound on the number of states of the automaton yielded by the determinization of a Glushkov automaton. We show that the ZPC structure, which is an implicit construction for Glushkov automata, leads to an efficient implementation of the subset construction.
22;Sandra Huerter;Kai Salomaa, Xiuming Wu, Sheng Yu;Implementing Reversed Alternating Finite Automaton (r-AFA) Operations;In [17], we introduced a bit-wise representation of r-AFA, which greatly improved the space efficiency in representing regular languages. We also described our algorithms and implementation methods for the union, intersection, and complementation of r-AFA. However, our direct algorithms for the star, concatenation, and reversal operations of r- AFA would cause an exponential expansion in the size of resulting r-AFA for even the average cases. In this paper, we will design new algorithms for the star, concatenation, and reversal operations of r-AFA based on the bit-wise representation introduced in [17]. Experiments show that the new algorithms can significantly reduce the state size of the resulting r- AFA. We also show how we have improved the DFA-to-AFA transformation algorithm which was described in [17]. The average run time of this transformation using the modified algorithm has improved significantly (by 97 percent).
22;Kai Salomaa;Sandra Huerter, Xiuming Wu, Sheng Yu;Implementing Reversed Alternating Finite Automaton (r-AFA) Operations;In [17], we introduced a bit-wise representation of r-AFA, which greatly improved the space efficiency in representing regular languages. We also described our algorithms and implementation methods for the union, intersection, and complementation of r-AFA. However, our direct algorithms for the star, concatenation, and reversal operations of r- AFA would cause an exponential expansion in the size of resulting r-AFA for even the average cases. In this paper, we will design new algorithms for the star, concatenation, and reversal operations of r-AFA based on the bit-wise representation introduced in [17]. Experiments show that the new algorithms can significantly reduce the state size of the resulting r- AFA. We also show how we have improved the DFA-to-AFA transformation algorithm which was described in [17]. The average run time of this transformation using the modified algorithm has improved significantly (by 97 percent).
22;Xiuming Wu;Sandra Huerter, Kai Salomaa, Sheng Yu;Implementing Reversed Alternating Finite Automaton (r-AFA) Operations;In [17], we introduced a bit-wise representation of r-AFA, which greatly improved the space efficiency in representing regular languages. We also described our algorithms and implementation methods for the union, intersection, and complementation of r-AFA. However, our direct algorithms for the star, concatenation, and reversal operations of r- AFA would cause an exponential expansion in the size of resulting r-AFA for even the average cases. In this paper, we will design new algorithms for the star, concatenation, and reversal operations of r-AFA based on the bit-wise representation introduced in [17]. Experiments show that the new algorithms can significantly reduce the state size of the resulting r- AFA. We also show how we have improved the DFA-to-AFA transformation algorithm which was described in [17]. The average run time of this transformation using the modified algorithm has improved significantly (by 97 percent).
22;Sheng Yu;Sandra Huerter, Kai Salomaa, Xiuming Wu;Implementing Reversed Alternating Finite Automaton (r-AFA) Operations;In [17], we introduced a bit-wise representation of r-AFA, which greatly improved the space efficiency in representing regular languages. We also described our algorithms and implementation methods for the union, intersection, and complementation of r-AFA. However, our direct algorithms for the star, concatenation, and reversal operations of r- AFA would cause an exponential expansion in the size of resulting r-AFA for even the average cases. In this paper, we will design new algorithms for the star, concatenation, and reversal operations of r-AFA based on the bit-wise representation introduced in [17]. Experiments show that the new algorithms can significantly reduce the state size of the resulting r- AFA. We also show how we have improved the DFA-to-AFA transformation algorithm which was described in [17]. The average run time of this transformation using the modified algorithm has improved significantly (by 97 percent).
22;Zdeněk Tronìček;;Operations on DASG;Acyclic Subsequence Graph (DASG) is an automaton that accepts all subsequences of a given string T. DASG allows us to decide whether a string S is a subsequence of T in O(|S|) time where |S| is the length of S. We show that if we slightly modify the string T, it is possible to get the DASG for the modified string from the original DASG. For this purpose we define these operations on DASG: adding a state on the left, deleting a state on left, adding a state on the right, deleting a state on the right, adding an inner state, deleting an inner state and replacing a transition label. For each of these operations we describe the modification of DASG and the proof of correctness.
22;Jan Holub;Bořivoj Melichar;Implementation of Nondeterministic Finite Automata for Approximate Pattern Matching;There are two ways of using the nondeterministic finite automata (NFA). The first one is the transformation to the equivalent deterministic finite automaton and the second one is the simulation of the run of NFA. In this paper we discuss the second way. We present an overview of the simulation methods that have been found in the approximate string matching. We generalize these simulation methods and form the rules for the usage of these methods.
22;Bořivoj Melichar;Jan Holub;Implementation of Nondeterministic Finite Automata for Approximate Pattern Matching;There are two ways of using the nondeterministic finite automata (NFA). The first one is the transformation to the equivalent deterministic finite automaton and the second one is the simulation of the run of NFA. In this paper we discuss the second way. We present an overview of the simulation methods that have been found in the approximate string matching. We generalize these simulation methods and form the rules for the usage of these methods.
22;Denis Maurel;Brigitte Le Pévédic, Olivier Rousseau;The Syntactic Prediction with Token Automata: Application to HandiAS System;This paper presents an adjustable way of syntactic prediction on the basis of left context with token automata. Our purpose is to predict the end of a word on the basis of its first letters keyboarding. We illustrate our intention with the presentation of a prototype software for disabled communication aid, called HandiAS.
22;Brigitte Le Pévédic;Denis Maurel, Olivier Rousseau;The Syntactic Prediction with Token Automata: Application to HandiAS System;This paper presents an adjustable way of syntactic prediction on the basis of left context with token automata. Our purpose is to predict the end of a word on the basis of its first letters keyboarding. We illustrate our intention with the presentation of a prototype software for disabled communication aid, called HandiAS.
22;Olivier Rousseau;Denis Maurel, Brigitte Le Pévédic;The Syntactic Prediction with Token Automata: Application to HandiAS System;This paper presents an adjustable way of syntactic prediction on the basis of left context with token automata. Our purpose is to predict the end of a word on the basis of its first letters keyboarding. We illustrate our intention with the presentation of a prototype software for disabled communication aid, called HandiAS.
22;Thierry Poibeau;;Bi-directional Automata to Extract Complex Phrases from Texts;This paper presents an experiment to develop natural-language tools to improve the quality of documents. These softwares are using finite-state automata enriched with notions of proximity, optionality and contextual information. They are called bi-directional because they need to parse a sequence not only from the left to right-hand side of a sentence, but on both sides of a word. This method improves efficiency.
22;Bruce W. Watson;;A Fast New Semi-incremental Algorithm for the Construction of Minimal Acyclic DFAs;We present a semi-incremental algorithm for constructing minimal acyclic deterministic finite automata. Such automata are useful for storing sets of words for spell-checking, among other applications. The algorithm is semi-incremental because it maintains the automaton in near-minimal condition and requires a final minimization step after the last word has been added (during construction).
22;Matti Nykänen;;Using Acceptors as Transducers;We wish to use a given nondeterministic two-way multi-tape acceptor as a transducer by supplying the contents for only some of its input tapes, and asking it to generate the missing contents for the other tapes. We provide here an algorithm for determining beforehand whether this transduction always results in a finite set of answers or not. We also develop an algorithm for evaluating these finite answers whenever the previous algorithm indicated their existence. Our algorithms can also be used for speeding up the simulation of these acceptors even when not used as transducers.
22;Dominique L’Her;Philippe Le Parc, Lionel Marcé;Proving Sequential Function Chart Programs Using Automata;Applications described by Sequential Function Chart (SFC) often being critical, we have studied the possibilities of program checking. In particular, physical time can be handled by SFC programs using temporisations, that’s why we are interested in the quantitative temporal properties. We have proposed a modeling of SFC in timed automata, a formalism which takes time into account. In this modeling, we use the physical constraints of the environment. Verification of properties can be carried out using the model-checker Kronos. We apply this method to SFC programs of average size like the one of the controlling part of the production cell Korso. The size of the programs remaining however a limit, we are studying the means of solving this problem.
22;Philippe Le Parc;Dominique L’Her, Lionel Marcé;Proving Sequential Function Chart Programs Using Automata;Applications described by Sequential Function Chart (SFC) often being critical, we have studied the possibilities of program checking. In particular, physical time can be handled by SFC programs using temporisations, that’s why we are interested in the quantitative temporal properties. We have proposed a modeling of SFC in timed automata, a formalism which takes time into account. In this modeling, we use the physical constraints of the environment. Verification of properties can be carried out using the model-checker Kronos. We apply this method to SFC programs of average size like the one of the controlling part of the production cell Korso. The size of the programs remaining however a limit, we are studying the means of solving this problem.
22;Lionel Marcé;Dominique L’Her, Philippe Le Parc;Proving Sequential Function Chart Programs Using Automata;Applications described by Sequential Function Chart (SFC) often being critical, we have studied the possibilities of program checking. In particular, physical time can be handled by SFC programs using temporisations, that’s why we are interested in the quantitative temporal properties. We have proposed a modeling of SFC in timed automata, a formalism which takes time into account. In this modeling, we use the physical constraints of the environment. Verification of properties can be carried out using the model-checker Kronos. We apply this method to SFC programs of average size like the one of the controlling part of the production cell Korso. The size of the programs remaining however a limit, we are studying the means of solving this problem.
22;Marie-Chantal Beaulieu;Anne Bergeron;Automata and Computational Probabilities;In this paper, we discuss the underlying ideas of a computer laboratory for symbolic manipulation of discrete random experiments. Finite automata, and associated formal series, are the basic theoretical tool for representing experiments, and for solving probability problems. Starting from a description of a random experiment given as a special kind of regular expressions, the environment constructs automata from which it extracts generating series associated to the experiment.
22;Anne Bergeron;Marie-Chantal Beaulieu;Automata and Computational Probabilities;In this paper, we discuss the underlying ideas of a computer laboratory for symbolic manipulation of discrete random experiments. Finite automata, and associated formal series, are the basic theoretical tool for representing experiments, and for solving probability problems. Starting from a description of a random experiment given as a special kind of regular expressions, the environment constructs automata from which it extracts generating series associated to the experiment.
22;Jean-Francis Michon;Jean-Marc Champarnaud;Automata and Binary Decision Diagrams;We show that the concept of automata minimization leads to a nice interpretation of the famous canonicity of binary decision diagrams discovered by Bryant.
22;Jean-Marc Champarnaud;Jean-Francis Michon;Automata and Binary Decision Diagrams;We show that the concept of automata minimization leads to a nice interpretation of the famous canonicity of binary decision diagrams discovered by Bryant.
22;Gérard Duchamp;Marianne Flouret, Éric Laugerotte;Operations over Automata with Multiplicities;We present here theoretical results coming from the implementation of the package called AMULT (automata with multiplicities in several noncommutative variables). We show that classical formulas are “almost every time” optimal and characterize the dual laws preserving rationality.
22;Marianne Flouret;Gérard Duchamp, Éric Laugerotte;Operations over Automata with Multiplicities;We present here theoretical results coming from the implementation of the package called AMULT (automata with multiplicities in several noncommutative variables). We show that classical formulas are “almost every time” optimal and characterize the dual laws preserving rationality.
22;Éric Laugerotte;Gérard Duchamp, Marianne Flouret;Operations over Automata with Multiplicities;We present here theoretical results coming from the implementation of the package called AMULT (automata with multiplicities in several noncommutative variables). We show that classical formulas are “almost every time” optimal and characterize the dual laws preserving rationality.
22;Ricardo Ueda Karpischek;;Paging Automata;We present biba, a package designed to deal with representations of large automata. It offers a library able to build, even on a modest computer, automata where the sum of the numbers of states and edges achieves one billion or more. Two applications that use this library are provided as examples. They build the reduced automaton for a given vocabulary, and the suffix automaton of a given word. New programs can be developed using this library. In order to overcome physical memory limitations, biba implements a paging scheme, in such a way that the automata really reside on disk, making possible their permanent storage. Through a simple interface suited for perl, small scripts can be easily written to use and extract informations from these automata.
22;Yuri Velinov;;On the Syntax, Semantics, and Implementation of a Graph-Based Computational Environment;In the present paper we consider the abstract background for designing a practical graph-based computational environment with variable, optional semantics. From the variety of possibilities we concentrate on graphs and polynets as possible carriers of the syntax, and finite automata and flow-diagram programs as possible semantics. We discuss the encapsulation property which emerges in such systems and give precise description of the syntax, operational and denotational semantics in terms of Category Theory. A data structure capable to meet the requirements of a graph-based computational environment is sketched at the end.
22;Sandro Pedrazzini;;The Finite State Automata’s Design Patterns;In this article we want to discuss the design patterns used and proposed for the realization of finite state automata. Various aspects in the design of a framework for the implementation of FSA will be treated, presenting not only the patterns for the single components, but the entire system design. Using design patterns to sketch a framework means performing an ”abstract implementation”, from which it is possible to realize concrete specific automata, simply customizing some classes. In order to test the framework, some concrete lexical tools have been created. The resulting automata and transducers are used to perform word form analysis, word form generation, creation and derivation history, spellchecking and phrase recognition.
