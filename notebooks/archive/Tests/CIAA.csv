Venue;Title;Authors;Abstract
CIAA 2022;On 25 Years of CIAA Through the Lens of Data Science;Hermann Gruber, Markus Holzer, Christian Rauch;We investigate the structure of the co-authorship graph for the Conference on Implementation and Application of Automata (CIAA) with techniques from network sciences. This allows us to answer a broad variety of questions on collaboration patterns. Our findings are in line with (statistical) properties of other co-authorship networks from biology, physics and mathematics as conducted earlier by pioneers of network sciences.
CIAA 2022;Manipulation of Regular Expressions Using Derivatives: An Overview;Nelma Moreira, Rogério Reis;The notions of derivative and partial derivative of regular expressions revealed themselves to be very powerful and have been successfully extended to many other formal language classes and algebraic structures. Although the undisputed elegance of this formalism, its efficient practical use is still a challenging research topic. Here we give a brief historical overview and summarise some of these aspects.
CIAA 2022;How to Settle the ReDoS Problem: Back to the Classical Automata Theory;Sicheol Sung, Hyunjoon Cheon, Yo-Sub Han;Most regular-expression matching engines in practice are based on the Thompson construction and the Spencer matching algorithm. While these engines work fast and efficiently, a serious problem, the regular expression denial-of-service (ReDoS), has been reported recently. ReDoS is an algorithm complexity attack, which exploits the backtracking feature of the engine, and makes the service unresponsive indefinitely. Researchers suggested a few remedies to cope with the ReDoS problem, yet they are often ad-hoc or undesirable in practice. We instead propose a hybrid matching scheme that selects between the Thompson and the Spencer matching algorithms depending on the needed features. We also suggest to use the position construction for its intrinsic characteristics for fast matching. We evaluate the proposed approach using a benchmark dataset collected from various open-source projects, and compare the performance with the current approach. The experimental results show that a hybrid matcher reduces the ReDoS-vulnerability by 96% and 99.98% in full and partial matching, respectively. Moreover, 55% of the most problematic regular expressions become invulnerable to ReDoS by the position construction.
CIAA 2022;Ordered Context-Free Grammars;Brink van der Merwe, Martin Berglund;We propose a new unambiguous grammar formalism, referred to as ordered context-free grammars, which is identical to context-free grammars, apart from the property that it also places an order on parse trees. Since only a minor modification to ordered context-free grammars is required to obtain parsing expression grammars, the relationship between context-free grammars and parsing expression grammars becomes more evident. By preserving how ordered context-free grammars support left-recursion, parsing expression grammars is modified to support left recursion in ways much more natural than current approaches.
CIAA 2022;Symbolic Weighted Language Models, Quantitative Parsing and Automated Music Transcription;Florent Jacquemard, Lydia Rodriguez de la Nava;We study several classes of symbolic weighted formalisms: automata (swA), transducers (swT) and visibly pushdown extensions (swVPA, swVPT). They combine the respective extensions of their symbolic and weighted counterparts, allowing a quantitative evaluation of words over a large or infinite input alphabet.
CIAA 2022;A Similarity Measure for Formal Languages Based on Convergent Geometric Series;Florian Bruse, Maurice Herwig, Martin Lange;We present a distance metric on formal languages based on the accumulated weight of words in their symmetric difference. The contribution of an individual word to this weight decreases exponentially in its length, guaranteeing the distance between languages to be a real value between 0 and 1. We show that this distance is computable for regular languages. As an application, we show how the similarity measure derived from a modification of this metric can be used in automatic grading of particular standard exercises in formal language theory classes.
CIAA 2022;Hybrid Tree Automata and the Yield Theorem for Constituent Tree Automata;Frank Drewes, Richard Mörbitz, Heiko Vogler;We introduce an automaton model for recognizing sets of hybrid trees, the hybrid tree automaton (HTA). Special cases of hybrid trees are constituent trees and dependency trees, as they occur in natural language processing. This includes the cases of discontinuous constituent trees and non-projective dependency trees. In general, a hybrid tree is a tree over a ranked alphabet in which symbols can additionally be equipped with an index, i.e., a natural number which indicates the position of that symbol in the yield of the hybrid tree. As a special case of HTA, we define constituent tree automata (CTA) which recognize sets of constituent trees. We show that the set of yields of a CTA-recognizable set of constituent trees is an LCFRS language, and vice versa.
CIAA 2022;Some Results Concerning Careful Synchronization of Partial Automata and Subset Synchronization of DFA’s;Jakub Ruszil;The goal of this paper is to present a family of partial automata that achieve length \(\varTheta (3^{\frac{n}{3}})\) of the shortest carefully synchronizing words, but using \(\frac{2}{9}n + 2\) letters, thus substantially improving the result obtained in [<a aria-label="Reference 19" data-test="citation-ref" data-track="click" data-track-action="reference anchor" data-track-label="link" href="#ref-CR19" id="ref-link-section-d326228e638" title="Martyugin, P.V.: Careful synchronization of partial automata with restricted alphabets. In: Bulatov, A.A., Shur, A.M. (eds.) CSR 2013. LNCS, vol. 7913, pp. 76–87. Springer, Heidelberg (2013).                   https://doi.org/10.1007/978-3-642-38536-0_7                                  ">19], which is \(\frac{1}{3}n + 1\) letters. Additionally, modifying our idea we obtain a family of automata over a three letter alphabet and a subexponential length of the shortest carefully synchronizing words and, as a corollary of that construction, a series of binary automata with a subexponential length of word reducing set of states to a particular subset.
CIAA 2022;A Toolkit for Parikh Matrices;Laura K. Hutchinson, Robert Mercaş, Daniel Reidenbach;The Parikh matrix mapping is a concept that provides information on the number of occurrences of certain (scattered) subwords in a word. Although Parikh matrices have been thoroughly studied, many of their basic properties remain open. In the present paper, we describe a toolkit that has been developed to support research in this field. Its functionality includes elementary and advanced operations related to Parikh matrices and the recently introduced variants of \(\mathbb {P}\)-Parikh matrices and \(\mathbb {L}\)-Parikh matrices.
CIAA 2022;Syntax Checking Either Way;Martin Kutrib, Uwe Meyer;We consider parsers of deterministic context-free languages and study the sizes of their syntax checking components. More precisely, we allow the input processing from left to right or, alternatively, from right to left, whatever is best for the given language. We establish an infinite sequence of deterministic context-free languages \(L_k\), for \(k\ge 1\), such that there is an exponential size trade-off between a deterministic pushdown automaton that reads its input from right to left and another one that reads its input from left to right. Concerning the constructibility of such a parser out of a given deterministic context-free language, it is shown that it is undecidable whether the reversal of a given deterministic context-free language is again deterministic context free. Furthermore, we study the expressive capacity of the family of languages whose reversals are deterministic context free. Finally, we turn to the family of deterministic context-free languages whose reversals are also deterministic context free and collect several of their closure properties.
CIAA 2022;On the Power of Pushing or Stationary Moves for Input-Driven Pushdown Automata;Martin Kutrib, Andreas Malcher, Matthias Wendlandt;Input-driven pushdown automata (\(\text {IDPDA}\)s) are pushdown automata where the next action on the pushdown store (push, pop, nothing) is solely governed by the input symbol. Nowadays such devices are usually defined such that every push operation pushes exactly one additional symbol on the pushdown store and, in addition, the devices work in real time so that stationary moves are not allowed. Here, we relax this strong definition and consider \(\text {IDPDA}\)s that may push more than one symbol in one step (\(\text {push-IDPDA}\)) or may perform stationary moves (\(\text {stat-IDPDA}\)). We study the computational power of the extended variants both in the deterministic and nondeterministic case, we investigate several decidability questions for the new automata classes, and we obtain useful interesting representations by inverse homomorphisms.
CIAA 2022;The Cut Operation in Subclasses of Convex Languages (Extended Abstract);Michal Hospodár, Viktor Olejár;The cut of two languages is a subset of their concatenation given by the leftmost maximal substring match. We study the state complexity of the cut operation assuming that both operands belong to some, possibly different, subclasses of convex languages, namely, right, left, two-sided, and all-sided ideal, prefix-, suffix-, factor-, and subword-closed, and -free languages. For all considered pairs of classes, we get the exact state complexity of cut. We show that it is m whenever the first language is a right ideal, and it is \(m+n-1\) or \(m+n-2\) if the first language is prefix-closed or prefix-free. In the other cases, the state complexity of cut is between \(mn-2n-m+4\) and \(mn-n+m\), the latter being the known state complexity of cut on regular languages. All our witnesses are described over a fixed alphabet of size at most three, except for three cases when the witness languages are described over an alphabet of size m or \(m-1\).
CIAA 2022;Variations of the Separating Words Problem;Nicholas Tran;The separating words problem seeks to determine the asymptotic growth of the minimum number of states of a deterministic finite automaton that accepts x but rejects y, where x and y are given strings. We study three natural variants of this problem which impose additional constraints on the start and/or end states: \(\forall \)-separation requires different end states for every common start state. \(\forall ^2\)-separation requires different end states for every pair of start states. and \(\forall ^201\)-separation requires fixed different end states for every pair of start states.
CIAA 2022;Homomorphisms on Graph-Walking Automata;Olga Martynova, Alexander Okhotin;Graph-walking automata (GWA) analyze an input graph by moving between its nodes, following the edges. This paper investigates the effect of node-replacement graph homomorphisms on recognizability by these automata. The family of graph languages recognized by GWA is closed under inverse homomorphisms. The main result of this paper is that, for n-state automata operating on graphs with k labels of edge end-points, the inverse homomorphic images require GWA with \(kn+O(1)\) states in the worst case. The second result is that already for tree-walking automata, the family they recognize is not closed under injective homomorphisms. here the proof is based on a homomorphic characterization of regular tree languages.
CIAA 2022;Nondeterministic State Complexity of Site-Directed Deletion;Oliver A. S. Lyon, Kai Salomaa;Site-directed deletion is a biologically inspired operation that removes a contiguous substring from the host string guided by a template string. The template string must match the prefix and suffix of a substring. When this occurs the middle section of the substring not contained in the prefix or suffix is removed. We consider the nondeterministic state complexity of the site-directed deletion operation. For regular languages recognized by nondeterministic finite automata with N and M states, respectively, we establish a new upper bound of \(2NM + N\) and a new worst case lower bound of 2NM. The upper bound improves a previously established upper bound, and no non-trivial lower bound was previously known for the nondeterministic state complexity of site-directed deletion.
CIAA 2022;Energy Complexity of Regular Language Recognition;Öykü Yılmaz, Fırat Kıyak, Meriç Üngör, A. C. Cem Say;The erasure of each bit of information by a computing device has an intrinsic energy cost. Although any Turing machine can be rewritten to be thermodynamically reversible without changing the recognized language, finite automata that are restricted to scan their input once in “real-time” fashion can only recognize the members of a proper subset of the class of regular languages in this reversible manner. We use a general quantum finite automaton model to study the thermodynamic cost per step associated with the recognition of different regular languages. We show that zero-error quantum finite automata have no energy cost advantage over their classical deterministic counterparts, and prove an upper bound for the cost that holds for all regular languages. We also demonstrate languages for which “error can be traded for energy”, i.e. whose zero-error recognition is associated with provably bigger energy cost per step when compared to their bounded-error recognition by real-time finite-memory quantum devices.
CIAA 2022;Real-Time, Constant-Space, Constant-Randomness Verifiers;Özdeniz Dolu, Nevzat Ersoy, M. Utkan Gezer, A. C. Cem Say;We study the class of languages that have membership proofs which can be verified by real-time finite-state machines using only a constant number of random bits, regardless of the size of their inputs. Since any further restriction on the verifiers would preclude the verification of nonregular languages, this is the tightest computational budget which allows the checking of externally provided proofs to have meaningful use. We show that all languages that can be recognized by two-head one-way deterministic finite automata have such membership proofs. For any \(k&gt.0\), there exist languages that cannot be recognized by any k-head one-way nondeterministic finite automaton, but that are nonetheless real-time verifiable in this sense. The set of nonpalindromes, which cannot be recognized by any one-way multihead deterministic finite automaton, is also demonstrated to be verifiable within these restrictions.
CIAA 2021;Back to the Future: A Fresh Look at Linear Temporal Logic;Javier Esparza;This note tells the story of how I came to understand that my work with Křetínský and Sickert on translating LTL into \(\omega \)-automata was deeply connected to a normal form for LTL, obtained 35 years ago by Lichtenstein, Pnueli and Zuck.
CIAA 2021;Say No to Case Analysis: Automating the Drudgery of Case-Based Proofs;Jeffrey Shallit;I present an argument that long, tedious proofs requiring a human to check many cases should be replaced by an algorithm, so a computer can do the work instead.
CIAA 2021;Regularity Conditions for Iterated Shuffle on Commutative Regular Languages;Stefan Hoffmann;We identify a subclass of the regular commutative languages that is closed under the iterated shuffle, or shuffle closure. In particular, it is regularity-preserving on this subclass. This subclass contains the commutative group languages and, for every alphabet \(\varSigma \), the class \(\mathbf{Com} ^{+}(\varSigma ^{*})\) given by the ordered variety \(\mathbf{Com} ^+\). Then, we state a simple characterization when the iterated shuffle on finite commutative languages gives a regular language again and state partial results for aperiodic commutative languages. We also show that the aperiodic, or star-free, commutative languages and the commutative group languages are closed under projection.
CIAA 2021;Memoized Regular Expressions;Brink van der Merwe, Jacobie Mouton, Steyn van Litsenborgh, Martin Berglund;We extend non-deterministic finite automata (NFAs) and regular expressions (regexes) by adding memoization to these formalisms. These extensions are aimed at improving the matching time of backtracking regex matchers. Additionally, we discuss how to extend the concept of ambiguity in order to be applicable to memoized extensions of regexes and NFAs. These more general notions of ambiguity can be used to analyze the matching time of backtracking regex matchers enhanced with memoization.
CIAA 2021;The Commutative Closure of Shuffle Languages over Group Languages is Regular;Stefan Hoffmann;We show that the commutative closure combined with the iterated shuffle is a regularity-preserving operation on group languages. In particular, for commutative group languages, the iterated shuffle is a regularity-preserving operation. We also give bounds for the size of minimal recognizing automata. Then, we use this result to deduce that the commutative closure of any shuffle language over group languages, i.e., a language given by a shuffle expression, i.e., expressions involving shuffle, iterated shuffle, concatenation, Kleene star and union in any order, starting with the group languages, always yields a regular language.
CIAA 2021;Efficient Enumeration of Regular Expressions for Faster Regular Expression Synthesis;Su-Hyeon Kim, Hyeonseung Im, Sang-Ki Ko;We study the problem of synthesizing regular expressions from a set of positive and negative strings. The previous synthesis algorithm proposed by Lee et al. [12] relies on the best-first enumeration of regular expressions. To improve the performance of the enumeration process, we define a new normal form of regular expressions called the concise normal form which allows us to significantly reduce the search space by pruning those not in the normal form while still capturing the whole class of regular languages. We conduct experiments with two benchmark datasets and demonstrate that our synthesis algorithm based on the proposed normal form outperforms the previous algorithm in terms of runtime complexity and scalability.
CIAA 2021;Degrees of Restriction for Two-Dimensional Automata;Taylor J. Smith, Kai Salomaa;A three-way (resp., two-way) two-dimensional automaton has a read-only input head that moves in three (resp., two) directions on a finite array of cells labelled by symbols of the input alphabet. Restricting the input head movement of a two-dimensional automaton results in a model that is weaker in terms of recognition power.
CIAA 2021;The Range of State Complexities of Languages Resulting from the Cascade Product—The Unary Case (Extended Abstract);Markus Holzer, Christian Rauch;We investigate the state complexity of languages resulting from the cascade product of two minimal deterministic finite automata with n and m states, respectively. More precisely we study the magic number problem of the cascade product operation and show what range of complexities can be produced in case the left automaton is unary, that is, has only a singleton letter alphabet. Here we distinguish the cases when the involved automata are reset automata, permutation automata, permutation-reset automata, or do not have any restriction on their structure. It turns out that the picture on the obtained state complexities of the cascade product is diverse, and for all cases, except where the left automaton is a unary permutation(-reset) or a deterministic finite automaton without structural restrictions, and the right one is a reset automaton or a deterministic finite automaton without structural restrictions, we are able to identify state sizes that cannot be reached—these numbers are called “magic.”
CIAA 2021;Guessing the Buffer Bound for k-Synchronizability;Cinzia Di Giusto, Laetitia Laversa, Etienne Lozes;A communicating system is \(k\)-synchronizable if all of the message sequence charts representing the executions can be divided into slices of k sends followed by k receptions. It was previously shown that, for a fixed given k, one could decide whether a communicating system is \(k\)-synchronizable. This result is interesting because the reachability problem can be solved for \(k\)-synchronizable systems. However, the decision procedure assumes that the bound k is fixed. In this paper we improve this result and show that it is possible to decide if such a bound k exists.
CIAA 2021;State Complexity of Permutation and Related Decision Problems on Alphabetical Pattern Constraints;Stefan Hoffmann;We investigate the state complexity of the permutation operation, or the commutative closure, on Alphabetical Pattern Constraints (APC). This class corresponds to level 3/2 of the Straubing-Thérien hierarchy and includes the finite, the piecewise-testable, or \(\mathcal J\)-trivial, and the \(\mathcal R\)-trivial and \(\mathcal L\)-trivial languages. We give a sharp state complexity bound expressed in terms of the longest strings in the unary projection languages of an associated finite language. This bound is already sharp for the subclass of finite languages. Additionally, for two subclasses, we give sharp bounds expressed in terms of the size of a recognizing input automaton and the size of the alphabet. Lastly, we investigate the inclusion and universality problem on APCs up to permutational equivalence. These two problems are known to be \(\textsf {PSPACE}\)-complete on APCs in general, even for fixed alphabets. However, we show them to be decidable in polynomial time for fixed alphabets if we only want to solve them up to permutational equivalence.
CIAA 2021;Algorithms for Probabilistic and Stochastic Subsequential Failure Transducers;Diana Geneva, Georgi Shopov, Stoyan Mihov;This paper introduces a framework for building probabilistic models with subsequential failure transducers. We first show how various types of subsequential transducers commonly used in natural language processing are represented by probabilistic and conditional probabilistic subsequential failure transducers. Afterwards we introduce efficient algorithms for composition of conditional probabilistic subsequential transducers with probabilistic subsequential failure transducers and weight pushing (canonization) of probabilistic subsequential failure transducers. Those algorithms are applicable to many tasks for representing probabilistic models with subsequential failure transducers. One such task is the construction of the \(HCLG\) weighted transducer used in speech recognition which we describe in detail. At the end, empirical results and comparison between the presented \(HCLG\) failure weighted transducer and the standard \(HCLG\) weighted transducer constructions are shown.
CIAA 2021;Ambiguity Hierarchies for Weighted Tree Automata;Andreas Maletti, Teodora Nasz, Kevin Stier, Markus Ulbricht;Weighted tree automata (WTA) extend classical weighted automata (WA) to the non-linear structure of trees. The expressive power of WA with varying degrees of ambiguity has been extensively studied. Unambiguous, finitely ambiguous, and polynomially ambiguous WA over the tropical (as well as the arctic) semiring strictly increase in expressive power. The recently developed pumping results of Mazowiecki and Riveros (STACS 2018) are lifted to trees in order to achieve the same strict hierarchy for WTA over the tropical (as well as the arctic) semiring.
CIAA 2021;Boolean Kernels of Context-Free Languages;Martin Kutrib, Luca Prigioniero;While the closure of a language family \(\mathscr {L}\) under certain language operations is the least family of languages which contains all members of \(\mathscr {L}\) and is closed under all of the operations, a kernel of \(\mathscr {L}\) is a maximal family of languages which is a sub-family of \(\mathscr {L}\) and is closed under all of the operations. Here we investigate properties of the Boolean kernels of the family of context-free languages. Additionally, languages that are mandatory for each Boolean kernel and languages that are optional for Boolean kernels are studied. That is, we consider the intersection of all Boolean kernels as well as their union. The expressive capacities of these families are addressed leading to a hierarchical structure. Further closure properties are considered. Furthermore, we study descriptional complexity aspects of these families, where languages are represented by context-free grammars with proofs attached. It turns out that the size trade-offs between all families in question and deterministic context-free languages are non-recursive. That is, one can choose an arbitrarily large recursive function f, but the gain in economy of description eventually exceeds f when changing from the latter system to the former.
CIAA 2021;Efficient String Matching Based on a Two-Step Simulation of the Suffix Automaton;Simone Faro, Stefano Scafiti;Automata play a very important role in the design of string matching algorithms as their use has always led to elegant and very efficient solutions in practice. In this paper, we present a new general approach to the exact string matching algorithm based on a non-standard efficient simulation of the suffix automaton of the pattern and give a specific efficient implementation of it. To show the effectiveness of our algorithm, we perform an extensive comparison against the most effective alternatives known in literature in terms of search speed and shift advancements. From our experimental results the new algorithm turns out to be very efficient in practical cases scaling much better when the length of the pattern increases, improving the search speed by nearly 10 times under suitable conditions.
CIAA 2021;Approximate Hashing for Bioinformatics;Guy Arbitman, Shmuel T. Klein, Pierre Peterlongo, Dana Shapira;The paper extends ideas from data compression by deduplication to the Bioinformatic field. The specific problems on which we show our approach to be useful are the clustering of a large set of DNA strings and the search for approximate matches of long substrings, both based on the design of what we call an approximate hashing function. The outcome of the new procedure is very similar to the clustering and search results obtained by accurate tools, but in much less time and with less required memory.
CIAA 2019;Static Garbage Collection;Sebastian Maneth;We present a method that allows to bound the sizes of intermediate trees in a composition of macro tree transducers. Macro tree transducers are a powerful model of tree translation which, for instance, includes all attribute grammars (seen as tree-to-tree translators). The idea of the method is to change a transducer in the composition so that it does not produce output nodes that will be removed (and ignored) by a subsequent transducer in the composition. This can be considered as a form of static garbage collection, where garbage is never produced by any transducer. We then give three applications of this result and show that (1) compositions of macro tree transducers can be computed in linear time with respect to the sum of sizes of input and output trees, (2) finiteness of ranges of compositions of macro tree transducers is decidable, and (3) the macro tree transducer composition hierarchy collapses when restricted to functions of linear size increase.
CIAA 2019;Graph-Walking Automata: From Whence They Come, and Whither They are Bound;Alexander Okhotin;Graph-walking automata are finite automata walking on graphs given as an input. tree-walking automata and two-way finite automata are their well-known special cases. Graph-walking automata can be regarded both as a model of navigation in an unknown environment, and as a generic computing device, with the graph as the model of its memory. This paper presents the known results on these automata, ranging from their limitations in traversing graphs, studied already in the 1970s, to the recent work on the logical reversibility of their computations.
CIAA 2019;Enumerated Automata Implementation of String Dictionaries;Robert Bakarić, Damir Korenčić, Strahil Ristov;Over the last decade a considerable effort was invested into research on implementing string dictionaries. String dictionary is a data structure that bijectively maps a set of strings to a set of integers, and that is used in various index-based applications. A recent paper [18] can be regarded as a reference work on the subject of string dictionary implementations. Although very comprehensive, [18] does not cover the implementation of a string dictionary with the enumerated deterministic finite automaton, a data structure naturally suited for this purpose. We compare the results for the state-of-the-art compressed enumerated automaton with those presented in [18] on the same collection of data sets, and on the collection of natural language word lists. We show that our string dictionary implementation is a competitive variant for different types of data, especially when dealing with large sets of strings, and when strings have more similarity between them. In particular, our method presents as a prominent solution for storing DNA motifs and words of inflected natural languages. We provide the code used for the experiments.
CIAA 2019;New Approaches for Context Sensitive Flash Codes;Gilad Baruch, Shmuel T. Klein, Dana Shapira;Rewriting codes for flash memory enable the multiple usage of the same storage space, under the constraint that 0-bits can be changed into 1-bits, but not vice versa. Context sensitive rewriting codes extend this idea by incorporating also information gathered from surrounding bits. Several new and better context sensitive rewriting codes based on automata are presented and analyzed. Empirical simulations show a good match with the theoretical results.
CIAA 2019;Dolev-Yao Theory with Associative Blindpair Operators;A. Baskar, R. Ramanujam, S. P. Suresh;In the context of modeling cryptographic tools like blind signatures and homomorphic encryption, the Dolev-Yao model is typically extended with an operator over which encryption is distributive. The intruder deduction problem has a non-elementary upper bound when the extended operator is an Abelian group operator. Here we show that the intruder deduction problem is DEXPTIME-complete when we restrict the operator to satisfy only the associative property. We propose an automata-based analysis for the upper bound and use the reachability problem for alternating pushdown systems to show the lower bound.
CIAA 2019;Semi-linear Lattices and Right One-Way Jumping Finite Automata (Extended Abstract);Simon Beier, Markus Holzer;Right one-way jumping automata (ROWJFAs) are an automaton model that was recently introduced for processing the input in a discontinuous way. In [S. Beier, M. Holzer: Properties of right one-way jumping finite automata. In Proc. 20th DCFS, number 10952 in LNCS, 2018] it was shown that the permutation closed languages accepted by ROWJFAs are exactly those with a finite number of positive Myhill-Nerode classes. Here a Myhill-Nerode equivalence class \([w]_L\) of a language L is said to be positive if w belongs to L. Obviously, this notion of positive Myhill-Nerode classes generalizes to sets of vectors of natural numbers. We give a characterization of the linear sets of vectors with a finite number of positive Myhill-Nerode classes, which uses rational cones. Furthermore, we investigate when a set of vectors can be decomposed as a finite union of sets of vectors with a finite number of positive Myhill-Nerode classes. A crucial role is played by lattices, which are special semi-linear sets that are defined as a natural way to extend “the pattern” of a linear set to the whole set of vectors of natural numbers in a given dimension. We show connections of lattices to the Myhill-Nerode relation and to rational cones. Some of these results will be used to give characterization results about ROWJFAs with multiple initial states. For binary alphabets we show connections of these and related automata to counter automata.
CIAA 2019;Z-Automata for Compact and Direct Representation of Unranked Tree Languages;Johanna Björklund, Frank Drewes, Giorgio Satta;Unranked tree languages are valuable in natural language processing for modelling dependency trees. We introduce a new type of automaton for unranked tree languages, called Z-automaton, that is tailored for this particular application. The Z-automaton offers a compact form of representation, and unlike the closely related notion of stepwise automata, does not require a binary encoding of its input. We establish an arc-factored normal form, and prove the membership problem of Z-automata in normal form to be in \( O \left( mn \right) \), where m is the size of the transition table of the Z-automaton and n is the size of the input tree.
CIAA 2019;A Benchmark Production Tool for Regular Expressions;Angelo Borsotti, Luca Breveglieri, Stefano Crespi Reghizzi, Angelo Morzenti;We describe a new tool, named REgen, that generates regular expressions (RE) to be used as test cases, and that generates also synthetic benchmarks for exercising and measuring the performance of RE-based software libraries and applications. Each group of REs is randomly generated and satisfies a user-specified set of constraints, such as length, nesting depth, operator arity, repetition depth, and syntax tree balancing. In addition to such parameters, other features are chosen by the tool. An RE group may include REs that are ambiguous, or that define the same regular language but differ with respect to their syntactic structure. A benchmark is a collection of RE groups that have a user-specified numerosity and distribution, together with a representative sample of texts for each RE in the collection. We present two generation algorithms for RE groups and for benchmarks. Experimental results are reported for a large benchmark we used to compare the performance of different RE parsing algorithms. The tool REgen and the RE benchmark are publicly available and fill a gap in supporting tools for the development and evaluation of RE applications.
CIAA 2019;New Algorithms for Manipulating Sequence BDDs;Shuhei Denzumi;Sequence binary decision diagram (SeqBDD) is a data structure to represent and manipulate sets of strings. This is a variant of zero-suppressed binary decision diagram (ZDD) that manipulates combinatorial sets. Nowadays, binary decision diagrams (BDDs) and its family have been recognized as an important data structure to manipulate discrete structures. SeqBDD has some set manipulation operations inherited from ZDD, but the number of the operations is not enough to deal with a wide variety of requests in string processing area. In this paper, we propose 50 new algorithms for manipulating SeqBDDs. We divide the operations into three categories and list up them. We also analyzed the time and space complexities of some new algorithms.
CIAA 2019;A Simple Extension to Finite Tree Automata for Defining Sets of Labeled, Connected Graphs;Akio Fujiyoshi, Daniel Průša;This paper introduces spanning tree automata (ST automata) usable for defining sets of labeled, connected graphs. The automata are simply obtained by extending ordinary top-down finite tree automata for labeled, ordered trees. It is shown that ST automata can define any finite set of labeled, connected graphs, and also some subclasses of infinite sets of graphs that can represent the structure of chemical molecules. Although the membership problem for ST automata is NP-complete, an efficient software was developed which supports a practical use of ST automata in chemoinformatics as well as in other fields.
CIAA 2019;Composition Closure of Linear Weighted Extended Top-Down Tree Transducers;Zoltán Fülöp, Andreas Maletti;Linear weighted extended top-down tree transducers with regular look-ahead and with weights from a semiring are formal models that are used in syntax-based statistical machine translation. The composition hierarchies of some restricted versions of such weighted tree transducers (also without regular look-ahead) are considered. In particular, combinations of the restrictions of \(\varepsilon \)-freeness (all rules consume input), nondeletion, and strictness (all rules produce output) are considered. The composition hierarchy is shown to be finite for all but one \(\varepsilon \)-free variant of these weighted transducers over any commutative semiring.
CIAA 2019;A General Architecture of Oritatami Systems for Simulating Arbitrary Finite Automata;Yo-Sub Han, Hwee Kim, Yusei Masuda, Shinnosuke Seki;In this paper, we propose an architecture of oritatami systems with which one can simulate an arbitrary nondeterministic finite automaton (NFA) in a unified manner. The oritatami system is known to be Turing-universal but the simulation available so far requires 542 bead types and \(O(t^4 \log ^2 t)\) steps in order to simulate t steps of a Turing machine. The architecture we propose employs only 329 bead types and requires just \(O(t |Q|^4 |\varSigma |^2)\) steps to simulate an NFA with a state set Q working on a word of length t over an alphabet \(\varSigma \).
CIAA 2019;Descriptional Complexity of Power and Positive Closure on Convex Languages;Michal Hospodár;We study the descriptional complexity of the k-th power and positive closure operations on the classes of prefix-, suffix-, factor-, and subword-free, -closed, and -convex regular languages, and on the classes of right, left, two-sided, and all-sided ideal languages. We show that the upper bound kn on the nondeterministic complexity of the k-th power in the class of regular languages is tight for closed and convex classes, while in the remaining classes, the tight upper bound is \(k(n-1)+1\). Next we show that the upper bound n on the nondeterministic complexity of the positive closure operation in the class of regular languages is tight in all considered classes except for classes of factor-closed and subword-closed languages, where the complexity is one. All our worst-case examples are described over a unary or binary alphabet, except for witnesses for the k-th power on subword-closed and subword-convex languages which are described over a ternary alphabet. Moreover, whenever a binary alphabet is used for describing a worst-case example, it is optimal in the sense that the corresponding upper bounds cannot be met by a language over a unary alphabet. The most interesting result is the description of a binary factor-closed language meeting the upper bound kn for the k-th power. To get this result, we use a method which enables us to avoid tedious descriptions of fooling sets. We also provide some results concerning the deterministic state complexity of these two operations on the classes of free, ideal, and closed languages.
CIAA 2019;Partitioning a Symmetric Rational Relation into Two Asymmetric Rational Relations;Stavros Konstantinidis, Mitja Mastnak, Juraj Šebej;We consider the problem of partitioning effectively a given symmetric (and irreflexive) rational relation R into two asymmetric rational relations. This problem is motivated by a recent method of embedding an R-independent language into one that is maximal R-independent, where the method requires to use an asymmetric partition of R. We solve the problem when R is realized by a zero-avoiding transducer (with some bound k): if the absolute value of the input-output length discrepancy of a computation exceeds k then the length discrepancy of the computation cannot become zero. This class of relations properly contains the recognizable, the left synchronous, and the right synchronous relations. We leave the asymmetric partition problem open when R is not zero-avoiding. We also show examples of total word-orderings for which there is a relation R that cannot be partitioned into two asymmetric rational relations with respect to the given word-orderings.
CIAA 2019;Partial Derivatives of Regular Expressions over Alphabet-Invariant and User-Defined Labels;Stavros Konstantinidis, Nelma Moreira, João Pires, Rogério Reis;We are interested in regular expressions that represent word relations in an alphabet-invariant way—for example, the set of all word pairs u, v where v is a prefix of u independently of what the alphabet is. This is the second part of a recent paper on this topic which focused on labelled graphs (transducers and automata) with alphabet-invariant and user-defined labels. In this paper we study derivatives of regular expressions over labels (atomic objects) in some set B. These labels can be any strings as long as the strings represent subsets of a certain monoid. We show that one can define partial derivative labelled graphs of type B expressions, whose transition labels can be elements of another label set X as long as X and B refer to the same monoid. We also show how to use derivatives directly to decide whether a given word pair is in the relation of a regular expression over pairing specs. Set specs and pairing specs are useful label sets allowing one to express languages and relations over large alphabets in a natural and compact way.
CIAA 2019;Input-Driven Multi-counter Automata;Martin Kutrib, Andreas Malcher, Matthias Wendlandt;The model of deterministic input-driven multi-counter automata is introduced and studied. On such devices, the input letters uniquely determine the operations on the underlying data structure that is consisting of multiple counters. We study the computational power of the resulting language families and compare them with known language families inside the Chomsky hierarchy. In addition, it is possible to prove a proper counter hierarchy depending on the alphabet size. This means that any input alphabet induces an upper bound which depends on the alphabet size only, such that \(k+1\) counters are more powerful than k counters as long as k is less than this bound. The hierarchy interestingly collapses at the level of the bound. Furthermore, we investigate the closure properties of the language families. Finally, the undecidability of the emptiness problem is derived for input-driven two-counter automata.
CIAA 2019;Two-Dimensional Pattern Matching Against Basic Picture Languages;František Mráz, Daniel Průša, Michael Wehar;Given a two-dimensional array of symbols and a picture language over a finite alphabet, we study the problem of finding rectangular subarrays of the array that belong to the picture language. We formulate four particular problems – finding maximum, minimum, any or all match(es) – and describe algorithms solving them for basic classes of picture languages, including local picture languages and picture languages accepted by deterministic on-line tessellation automata or deterministic four-way finite automata. We also prove that the matching problems cannot be solved for the class of local picture languages in linear time unless the problem of triangle finding is solvable in quadratic time. This shows there is a fundamental difference in the pattern matching complexity regarding the one-dimensional and two-dimensional setting.
CIAA 2018;On Design and Analysis of Chemical Reaction Network Algorithms;Anne Condon;The fields of DNA computing, molecular programming and DNA nanotechnology offer exciting new possibilities for organizing and manipulating matter at the nanoscale, and prompt us to think about computation in creative new ways. Molecules reacting in a test tube change state, and counts of molecules can in principle be used to simulate counter machines, all in a highly distributed, asynchronous and stochastic manner. In this talk I’ll give some background on models of molecular programming, focusing on Stochastic Chemical Reaction Networks, and describe some beautiful results and open problems pertaining to this model of computing.
CIAA 2018;Regular Expressions and Transducers over Alphabet-Invariant and User-Defined Labels;Stavros Konstantinidis, Nelma Moreira, Rogério Reis, Joshua Young;We are interested in regular expressions and transducers that represent word relations in an alphabet-invariant way—for example, the set of all word pairs u, v where v is a prefix of u independently of what the alphabet is. Current software systems of formal language objects do not have a mechanism to define such objects. We define transducers in which transition labels involve what we call set specifications, some of which are alphabet invariant. In fact, we consider automata-type objects, called labelled graphs, where each transition label can be any string, as long as that string represents a subset of a certain monoid. Then, the behaviour of the labelled graph is a subset of that monoid. We do the same for regular expressions. We obtain extensions of known algorithmic constructions on ordinary regular expressions and transducers, including partial derivative based methods, at the broad level of labelled graphs such that the computational efficiency of the extended constructions is not sacrificed. Then, for regular expressions with set specs we obtain a direct partial derivative method for membership. For transducers with set specs we obtain further algorithms that can be applied to questions about independent regular languages, in particular the witness version of the property satisfaction question.
CIAA 2018;Boosting Pushdown and Queue Machines by Preprocessing;Martin Kutrib, Andreas Malcher, Matthias Wendlandt;Motivated by preprocessing devices occurring for example in the context of syntactic parsers or HTML sanitization, we study pairs of finite state transducers and deterministic machines such as pushdown automata or queue automata as language accepting devices, where the original input is translated by a finite state transducer to an input of the deterministic machine which eventually accepts or rejects the preprocessed input. As deterministic machines we study input-driven machines as well as reversible machines equipped with a pushdown store or a queue store. It turns out that the preprocessing boosts on the one hand the computational power of the machines in all four cases, but on the other hand preserves and adds some positive closure properties as well as decidable problems. Thus, the preprocessing extends the computational power moderately by retaining most of the nice properties of the original machine.
CIAA 2018;The Validity of Weighted Automata;Sylvain Lombardy, Jacques Sakarovitch;This invited talk presents the work conducted on the problems that arise when dealing with weighted automata containing \(\varepsilon \)-transitions: how to define the behaviour of such automata in which the presence of \(\varepsilon \)-circuits results in infinite summations, and second how to eliminate the \(\varepsilon \)-transitions in an automaton whose behaviour has been recognised to be well-defined. The origin of this work is the implementation, in the Awali platform [19], of an \(\varepsilon \)-transition removal algorithm for automata with weight in \(\mathbb {Q}\) or \(\mathbb {R}\), a case that had never been treated before in the rich literature on the subject of \(\varepsilon \)-transition removal algorithms (cf. [16] for a survey). The results of this work have been published in [14].
CIAA 2018;Algorithms for Weighted Finite Automata with Failure Transitions;Cyril Allauzen, Michael D. Riley;In this paper we extend several weighted finite automata (WFA) algorithms to automata with failure transitions (\(\varphi \)-WFAs). Failure transitions, which are taken only when no immediate match is possible at a given state, are used to compactly represent automata and have many applications. Efficient algorithms to intersect two \(\varphi \)-WFAs, to remove failure transitions, to trim, and to compute (over \(\mathbb {R}_+\)) the shortest distance in a \(\varphi \)-WFA are presented.
CIAA 2018;The Bottom-Up Position Tree Automaton and Its Compact Version;Samira Attou, Ludovic Mignot, Djelloul Ziadi;The conversion of a given regular tree expression into a tree automaton has been widely studied. However, classical interpretations are based upon a Top-Down interpretation of tree automata. In this paper, we propose a new construction based on Gluskov’s one using a Bottom-Up interpretation. One of the main goals of this technique is to consider as a next step the links with deterministic recognizers, consideration that cannot be performed with classical Top-Down approaches. Furthermore, we exhibit a method to factorize transitions of tree automata and show that this technique is particularly interesting for the Glushkov constructions, by considering natural factorizations due to the structure of regular expression.
CIAA 2018;A New Hierarchy for Automaton Semigroups;Laurent Bartholdi, Thibault Godin, Ines Klimann, Matthieu Picantin;We define a new strict and computable hierarchy for the family of automaton semigroups, which reflects the various asymptotic behaviors of the state-activity growth. This hierarchy extends that given by Sidki for automaton groups, and also gives new insights into the latter. Its exponential part coincides with a notion of entropy for some associated automata.
CIAA 2018;Synchronizing Random Almost-Group Automata;Mikhail V. Berlinkov, Cyril Nicaud;In this paper we address the question of synchronizing random automata in the critical settings of almost-group automata. Group automata are automata where all letters act as permutations on the set of states, and they are not synchronizing (unless they have one state). In almost-group automata, one of the letters acts as a permutation on \(n-1\) states, and the others as permutations. We prove that this small change is enough for automata to become synchronizing with high probability. More precisely, we establish that the probability that a strongly connected almost-group automaton is not synchronizing is \(\frac{2^{k-1}-1}{n^{2(k-1)}}(1+o(1))\), for a k-letter alphabet.
CIAA 2018;A Comparison of Two N-Best Extraction Methods for Weighted Tree Automata;Johanna Björklund, Frank Drewes, Anna Jonsson;We conduct a comparative study of two state-of-the-art algorithms for extracting the N best trees from a weighted tree automaton (wta). The algorithms are Best Trees, which uses a priority queue to structure the search space, and Filtered Runs, which is based on an algorithm by Huang and Chiang that extracts N best runs, implemented as part of the Tiburon wta toolkit. The experiments are run on four data sets, each consisting of a sequence of wtas of increasing sizes. Our conclusion is that Best Trees can be recommended when the input wtas exhibit a high or unpredictable degree of nondeterminism, whereas Filtered Runs is the better option when the input wtas are large but essentially deterministic.
CIAA 2018;State Complexity of Overlap Assembly;Janusz A. Brzozowski, Lila Kari, Bai Li, Marek Szykuła;The state complexity of a regular language \(L_m\) is the number m of states in a minimal deterministic finite automaton (DFA) accepting \(L_m\). The state complexity of a regularity-preserving binary operation on regular languages is defined as the maximal state complexity of the result of the operation where the two operands range over all languages of state complexities \(\le m\) and \(\le n\), respectively. We find a tight upper bound on the state complexity of the binary operation overlap assembly on regular languages. This operation was introduced by Csuhaj-Varjú, Petre, and Vaszil to model the process of self-assembly of two linear DNA strands into a longer DNA strand, provided that their ends “overlap”. We prove that the state complexity of the overlap assembly of languages \(L_m\) and \(L_n\), where \(m\ge 2\) and \(n\ge 1\), is at most \(2 (m-1) 3^{n-1} + 2^n\). Moreover, for \(m \ge 2\) and \(n \ge 3\) there exist languages \(L_m\) and \(L_n\) over an alphabet of size n whose overlap assembly meets the upper bound and this bound cannot be met with smaller alphabets.
CIAA 2018;Online Stochastic Pattern Matching;Marco Cognetta, Yo-Sub Han;The pattern matching problem is to find all occurrences of a given pattern in an input text. In particular, we consider the case when the pattern is a stochastic regular language where each pattern string has its own probability. Our problem is to find all matching patterns—(start, end) indices in the text—whose probability is larger than a given threshold probability. A pattern matching procedure is frequently used on streaming data in several applications, and often it is very challenging to find the start index of a matching in streaming data. We design an efficient algorithm for the stochastic pattern matching problem over streaming data based on the transformation of the pattern PFA into a weighted automaton and a constant bound on the number of backtracks required to find a start index while reading the streaming input. We also employ heuristics that enable us to reduce the number of backtracks, which improves the practical runtime of our algorithm. We establish the tight theoretical runtime of the proposed algorithm and experimentally demonstrate its practical performance. Finally, we show a possible application of our algorithm to another stochastic pattern matching problem where we search for the maximum probability substring of a text that is a superstring of a specified string.
CIAA 2018;State Complexity of Reversals of Deterministic Finite Automata with Output;Sylvie Davies;We investigate the worst-case state complexity of reversals of deterministic finite automata with output (DFAOs). In these automata, each state is assigned some output value, rather than simply being labelled final or non-final. This directly generalizes the well-studied problem of determining the worst-case state complexity of reversals of ordinary deterministic finite automata. If a DFAO has n states and k possible output values, there is a known upper bound of \(k^n\) for the state complexity of reversal. We show this bound can be reached with a ternary input alphabet. We conjecture it cannot be reached with a binary input alphabet except when \(k = 2\), and give a lower bound for the case \(3 \le k &lt. n\). We prove that the state complexity of reversal depends solely on the transition monoid of the DFAO and the mapping that assigns output values to states.
CIAA 2018;Algorithms and Training for Weighted Multiset Automata and Regular Expressions;Justin DeBenedetto, David Chiang;Multiset automata are a class of automata for which the symbols can be read in any order and obtain the same result. We investigate weighted multiset automata and show how to construct them from weighted regular expressions. We present training methods to learn the weights for weighted regular expressions and for general multiset automata from data. Finally, we examine situations in which inside weights can be computed more efficiently.
CIAA 2018;Solving Parity Games: Explicit vs Symbolic;Antonio Di Stasio, Aniello Murano, Moshe Y. Vardi;In this paper we provide a broad investigation of the symbolic approach for solving Parity Games. Specifically, we implement in a fresh tool, called , four symbolic algorithms to solve Parity Games and compare their performances to the corresponding explicit versions for different classes of games. By means of benchmarks, we show that for random games, even for constrained random games, explicit algorithms actually perform better than symbolic algorithms. The situation changes, however, for structured games, where symbolic algorithms seem to have the advantage. This suggests that when evaluating algorithms for parity-game solving, it would be useful to have real benchmarks and not only random benchmarks, as the common practice has been.
CIAA 2018;Generalised Twinning Property;Stefan Gerdjikov;In this paper we consider the problem of sequentialisation of rational functions \(f:\varSigma ^*\rightarrow \mathcal{M}\). We introduce a class of monoids that includes infinitary groups, free monoids, tropical monoids and is closed under Cartesian Product. For this class of monoids we provide a sequentialisation construction for transducers and appropriately generalise the notion of Twinning Property. We provide a construction to test the Twinning Property for transducers over the considered class of monoids and prove that it is a necessary and sufficient condition for the sequentialisation construction to terminate.
CIAA 2018;Non-self-embedding Grammars, Constant-Height Pushdown Automata, and Limited Automata;Bruno Guillon, Giovanni Pighizzini, Luca Prigioniero;Non-self-embedding grammars are a restriction of context-free grammars which does not allow to describe recursive structures and, hence, which characterizes only the class of regular languages. A double exponential gap in size from non-self-embedding grammars to deterministic finite automata is known. The same size gap is also known from constant-height pushdown automata and 1-limited automata to deterministic finite automata. Constant-height pushdown automata and 1-limited automata are compared with non-self-embedding grammars. It is proved that non-self-embedding grammars and constant-height pushdown automata are polynomially related in size. Furthermore, a polynomial size simulation by 1-limited automata is presented. However, the converse transformation is proved to cost exponential.
CIAA 2018;The Ranges of Accepting State Complexities of Languages Resulting From Some Operations;Michal Hospodár, Markus Holzer;We examine the accepting state complexity, i.e., the minimal number of accepting states of deterministic finite automata (DFAs) for languages resulting from unary and binary operations on languages with accepting state complexity given as a parameter. This is continuation of the work of [J. Dassow: On the number of accepting states of finite automata, J. Autom., Lang. Comb., 21, 2016]. We solve most of the open problems mentioned thereof. In particular, we consider the operations of intersection, symmetric difference, right and left quotients, reversal, and permutation (on finite languages), where we obtain precise ranges of the accepting state complexities.
CIAA 2018;Semilinearity of Families of Languages;Oscar H. Ibarra, Ian McQuillan;Techniques are developed for creating new and general language families of only semilinear languages, and for showing families only contain semilinear languages. It is shown that for language families \(\mathcal{L}\) that are semilinear full trios, the smallest full AFL containing the languages obtained by intersecting languages in \(\mathcal{L}\) with languages in \(\mathsf{NCM}\) (where \(\mathsf{NCM}\) is the family of languages accepted by \(\textsf {NFA}\)s augmented with reversal-bounded counters), is also semilinear. If these closure properties are effective, this also immediately implies decidability of membership, emptiness, and infiniteness for these general families. From the general techniques, new grammar systems are given that are extensions of well-known families of semilinear full trios, whereby it is implied that these extensions must only describe semilinear languages. This also implies positive decidability properties for the new systems. Some characterizations of the new families are also given.
CIAA 2018;The Exact Complexity of Star-Complement-Star;Jozef Jirásek, Galina Jirásková;We show that the state complexity of the star-complement-star operation is given by \(\frac{3}{2}f(n\,-\,1) \,+\, 2 f(n\,-\,2) \,+\, 2n \,-\,5\), where \(f(2)=2\) and \(f(n) = \sum _{i=1}^{n-2}{n\atopwithdelims ()i} f (n\,-\,i) \,+\,2\). The function f(n) counts the number of distinct resistances possible for n arbitrary resistors each connected in series or parallel with previous ones, or the number of labeled threshold graphs on n vertices, and \(f(n)\sim n!(1-\ln 2)/(\ln 2)^{n+1} =2^{n \log n - 0.91 n + o(n)}\). Our witness language is defined over a quaternary alphabet, and we strongly conjecture that the size of the alphabet cannot be decreased.
CIAA 2017;On the Complexity of Determinizing Monitors;Luca Aceto, Antonis Achilleos, Adrian Francalanza, Anna Ingólfsdóttir, Sævar Örn Kjartansson;We examine the determinization of monitors. We demonstrate that every monitor is equivalent to a deterministic one, which is at most doubly exponential in size with respect to the original monitor. When monitors are described as CCS-like processes, this doubly-exponential bound is optimal. When (deterministic) monitors are described as finite automata (as their LTS), then they can be exponentially more succinct than their CCS process form.
CIAA 2017;On the Semantics of Atomic Subgroups in Practical Regular Expressions;Martin Berglund, Brink van der Merwe, Bruce Watson, Nicolaas Weideman;Most regular expression matching engines have operators and features to enhance the succinctness of classical regular expressions, such as interval quantifiers and regular lookahead. In addition, matching engines in for example Perl, Java, Ruby and .NET, also provide operators, such as atomic operators, that constrain the backtracking behavior of the engine. The most common use is to prevent needless backtracking, but the operators will often also change the language accepted. As such it is essential to develop a theoretical sound basis for the matching semantics of regular expressions with atomic operators. We here establish that atomic operators preserve regularity, but are exponentially more succinct for some languages. Further we investigate the state complexity of deterministic and non-deterministic finite automata accepting the language corresponding to a regular expression with atomic operators, and show that emptiness testing is PSPACE-complete.
CIAA 2017;On the Regularity and Learnability of Ordered DAG Languages;Henrik Björklund, Johanna Björklund, Petter Ericson;Order-Preserving DAG Grammars (OPDGs) is a subclass of Hyper-Edge Replacement Grammars that can be parsed in polynomial time. Their associated class of languages is known as Ordered DAG Languages, and the graphs they generate are characterised by being acyclic, rooted, and having a natural order on their nodes. OPDGs are useful in natural-language processing to model abstract meaning representations. We state and prove a Myhill-Nerode theorem for ordered DAG languages, and translate it into a MAT-learning algorithm for the same class. The algorithm infers a minimal OPDG G for the target language in time polynomial in G and the samples provided by the MAT oracle.
CIAA 2017;On the Number of Active States in Deterministic and Nondeterministic Finite Automata;Henning Bordihn, Markus Holzer;We introduce a new measure of descriptional complexity on finite automata, called the number of active states. Roughly speaking, the number of active states of an automaton A on input w counts the number of different states visited during the most economic computation of the automaton A for the word w. This concept generalizes to finite automata and regular languages in a straightforward way. We show that the number of active states of both finite automata and regular languages is computable, even with respect to nondeterministic finite automata. We further compare the number of active states to related measures for regular languages. In particular, we show incomparability to the radius of regular languages and that the difference between the number of active states and the total number of states needed in finite automata for a regular language can be of exponential order.
CIAA 2017;Complexity of Proper Prefix-Convex Regular Languages;Janusz A. Brzozowski, Corwin Sinnamon;A language L over an alphabet \(\varSigma \) is prefix-convex if, for any words \(x,y,z\in \varSigma ^*\), whenever x and xyz are in L, then so is xy. Prefix-convex languages include right-ideal, prefix-closed, and prefix-free languages, which were studied elsewhere. Here we concentrate on prefix-convex languages that do not belong to any one of these classes. we call such languages proper. We exhibit most complex proper prefix-convex languages, which meet the bounds for the size of the syntactic semigroup, reversal, complexity of atoms, star, product, and Boolean operations.
CIAA 2017;Equivalence of Probabilistic \(\mu \) -Calculus and p-Automata;Claudia Cauli, Nir Piterman;An important characteristic of Kozen’s \(\mu \)-calculus is its strong connection with parity alternating tree automata. Here, we show that the probabilistic \(\mu \)-calculus \(\mu ^p\)-calculus and p-automata (parity alternating Markov chain automata) have an equally strong connection. Namely, for every \(\mu ^p\)-calculus formula we can construct a p-automaton that accepts exactly those Markov chains that satisfy the formula. For every p-automaton we can construct a \(\mu ^p\)-calculus formula satisfied in exactly those Markov chains that are accepted by the automaton. The translation in one direction relies on a normal form of the calculus and in the other direction on the usage of vectorial \(\mu ^p\)-calculus. The proofs use the game semantics of \(\mu ^p\)-calculus and automata to show that our translations are correct.
CIAA 2017;Complexity of Bifix-Free Regular Languages;Robert Ferens, Marek Szykuła;We study descriptive complexity properties of the class of regular bifix-free languages, which is the intersection of prefix-free and suffix-free regular languages. We show that there exist universal bifix-free languages that meet all the bounds for the state complexity of basic operations (Boolean operations, product, star, and reversal). This is in contrast with suffix-free languages, where it is known that there does not exist such languages. Then we present a stream of bifix-free languages that is most complex in terms of all basic operations, syntactic complexity, and the number of atoms and their complexities, which requires a superexponential alphabet. We also complete the previous results by characterizing state complexity of product, star, and reversal, and establishing tight upper bounds for atom complexities of bifix-free languages. Moreover, we consider the problem of the minimal size of an alphabet required to meet the bounds, and the problem of attainable values of state complexities (magic numbers).
CIAA 2017;Computational Completeness of Path-Structured Graph-Controlled Insertion-Deletion Systems;Henning Fernau, Lakshmanan Kuppusamy, Indhumathi Raman;A graph-controlled insertion-deletion (GCID) system is a regulated extension of an insertion-deletion system. It has several components and each component contains some insertion-deletion rules. These components are the vertices of a directed control graph. A rule is applied to a string in a component and the resultant string is moved to the target component specified in the rule, describing the arcs of the control graph. We investigate which combinations of size parameters (the maximum number of components, the maximal length of the insertion string, the maximal length of the left context for insertion, the maximal length of the right context for insertion. a similar three restrictions with respect to deletion) are sufficient to maintain the computational completeness of such restricted systems with the additional restriction that the control graph is a path, thus, these results also hold for ins-del P systems.
CIAA 2017;Stamina: Stabilisation Monoids in Automata Theory;Nathanaël Fijalkow, Hugo Gimbert, Edon Kelmendi, Denis Kuperberg;We present Stamina, a tool solving three algorithmic problems in automata theory. First, compute the star height of a regular language, i.e. the minimal number of nested Kleene stars needed for expressing the language with a complement-free regular expression. Second, decide limitedness for regular cost functions. Third, decide whether a probabilistic leaktight automaton has value 1, i.e. whether a probabilistic leaktight automaton accepts words with probability arbitrarily close to 1.
CIAA 2017;A Simple Method for Building Bimachines from Functional Finite-State Transducers;Stefan Gerdjikov, Stoyan Mihov, Klaus U. Schulz;The standard construction of a bimachine from a functional transducer involves a preparation step for converting the transducer into an unambiguous transducer (A transducer is unambiguous if there exists at most one successful path for each label.). The conversion involves a specialized determinization. We introduce a new construction principle where the transducer is directly translated into a bimachine. For any input word accepted by the transducer the bimachine exactly imitates one successful path of the transducer. For some classes of transducers the new construction can build a bimachine with an exponentially lower number of states compared to the standard construction. We first present a simple and generic variant of the construction. A second specialized version leads to better complexity bounds in terms of the size of the bimachine.
CIAA 2017;Alignment Distance of Regular Tree Languages;Yo-Sub Han, Sang-Ki Ko;We consider the tree alignment distance problem between a tree and a regular tree language. The tree alignment distance is an alternative of the tree edit-distance, in which we construct an optimal alignment between two trees and compute its cost instead of directly computing the minimum cost of tree edits. The alignment distance is crucial for understanding the structural similarity between trees.
CIAA 2017;Nondeterministic Complexity of Operations on Free and Convex Languages;Michal Hospodár, Galina Jirásková, Peter Mlynárčik;We study the nondeterministic state complexity of basic regular operations on the classes of prefix-, suffix-, factor-, and subword-free and -convex regular languages. For the operations of intersection, union, concatenation, square, star, reversal, and complementation, we get the tight upper bounds for all considered classes except for complementation on factor- and subword-convex languages. Most of our witnesses are described over optimal alphabets. The most interesting result is the describing of a proper suffix-convex language over a five-letter alphabet meeting the upper bound \(2^n\) for complementation.
CIAA 2017;Transducing Reversibly with Finite State Machines;Martin Kutrib, Andreas Malcher, Matthias Wendlandt;Finite state machines are investigated towards their ability to reversibly compute transductions, that is, to transform inputs into outputs in a reversible way. This means that the transducers are backward deterministic and hence are able to uniquely step the computation back and forth. The families of transductions computed are classified with regard to three types of length-preserving transductions as well as to the property of working reversibly. It is possible to settle all inclusion relations between the families of transductions. Finally, the standard closure properties are investigated and the non-closure under almost all operations can be shown.
CIAA 2017;From Hadamard Expressions to Weighted Rotating Automata and Back;Louis-Marie Dando, Sylvain Lombardy;This paper deals with the conversion of expressions denoting Hadamard series into weighted rotating automata. We prove that any algorithm converting rational series into one-way weighted automata can be extended to provide an algorithm which achieves our goal. We apply this to define the derivation and the follow automata of a Hadamard expression. Our method is also used to extend algorithms which perform the inverse conversion, up to some adjustment in order to fulfill some constraints.
CIAA 2017;On the Conjecture \(\mathcal {L}_{\mathsf {DFCM}}\subsetneq \mathsf {RCM}\);Paolo Massazza;We prove that the class of the languages recognized by one-way deterministic 1-reversal bounded 1-counter machines is contained in \(\mathsf {RCM}\), a class of languages that has been recently introduced and that admits interesting properties. This is the first step to prove the conjecture \(\mathcal {L}_{\mathsf {DFCM}}\subsetneq \mathsf {RCM}\), which says that for any fixed integer k all the languages recognized by one-way deterministic 1-reversal bounded k-counter machines are in \(\mathsf {RCM}\). We recall that this conjecture implies that the generating function of a language in \(\mathcal {L}_{\mathsf {DFCM}}\) is holonomic.
CIAA 2017;Synchronization Problems in Automata Without Non-trivial Cycles;Andrew Ryzhikov;We study the computational complexity of various problems related to synchronization of weakly acyclic automata, a subclass of widely studied aperiodic automata. We provide upper and lower bounds on the length of a shortest word synchronizing a weakly acyclic automaton or, more generally, a subset of its states, and show that the problem of approximating this length is hard. We also show inapproximability of the problem of computing the rank of a subset of states in a binary weakly acyclic automaton and prove that several problems related to recognizing a synchronizing subset of states in such automata are NP-complete.
CIAA 2017;Syntactic Complexity of Bifix-Free Languages;Marek Szykuła, John Wittnebel;We study the properties of syntactic monoids of bifix-free regular languages. In particular, we solve an open problem concerning syntactic complexity: We prove that the cardinality of the syntactic semigroup of a bifix-free language with state complexity n is at most \((n-1)^{n-3}+(n-2)^{n-3}+(n-3)2^{n-3}\) for \(n \geqslant 6\). The main proof uses a large construction with the method of injective function. Since this bound is known to be reachable, and the values for \(n \leqslant 5\) are known, this completely settles the problem. We also prove that \((n-2)^{n-3} + (n-3)2^{n-3} - 1\) is the minimal size of the alphabet required to meet the bound for \(n \geqslant 6\). Finally, we show that the largest transition semigroups of minimal DFAs which recognize bifix-free languages are unique up to renaming the states.
CIAA 2016;Decision Problems for Finite Automata over Infinite Algebraic Structures;Bakhadyr Khoussainov, Jiamou Liu;We introduce the concept of finite automata over algebraic structures. We address the classical emptiness problem and its various refinements in our setting. In particular, we prove several decidability and undecidability results. We also explain the way our automata model connects with the existential first order theory of algebraic structures.
CIAA 2016;The Degree of Irreversibility in Deterministic Finite Automata;Holger Bock Axelsen, Markus Holzer, Martin Kutrib;Recently, Holzer et al. gave a method to decide whether the language accepted by a given deterministic finite automaton (DFA) can also be accepted by some reversible deterministic finite automaton (REV-DFA), and eventually proved NL-completeness. Here, we show that the corresponding problem for nondeterministic finite state automata (NFA) is PSPACE-complete. The recent DFA method essentially works by minimizing the DFA and inspecting it for a forbidden pattern. We here study the degree of irreversibility for a regular language, the minimal number of such forbidden patterns necessary in any DFA accepting the language, and show that the degree induces a strict infinite hierarchy of languages. We examine how the degree of irreversibility behaves under the usual language operations union, intersection, complement, concatenation, and Kleene star, showing tight bounds (some asymptotically) on the degree.
CIAA 2016;Deterministic Stack Transducers;Suna Bensch, Johanna Björklund, Martin Kutrib;We introduce and investigate stack transducers, which are one-way stack automata with an output tape. A one-way stack automaton is a classical pushdown automaton with the additional ability to move the stack head inside the stack without altering the contents. For stack transducers, we distinguish between a digging and a non-digging mode. In digging mode, the stack transducer can write on the output tape when its stack head is inside the stack, whereas in non-digging mode, the stack transducer is only allowed to emit symbols when its stack head is at the top of the stack. These stack transducers have a motivation from natural language interface applications, as they capture long-distance dependencies in syntactic, semantic, and discourse structures. We study the computational capacity for deterministic digging and non-digging stack transducers, as well as for their non-erasing and checking versions. We finally show that even for the strongest variant of stack transducers the stack languages are regular.
CIAA 2016;Computing the Expected Edit Distance from a String to a PFA;Jorge Calvo-Zaragoza, Colin de la Higuera, Jose Oncina;In a number of fields one is to compare a witness string with a distribution. One possibility is to compute the probability of the string for that distribution. Another, giving a more global view, is to compute the expected edit distance from a string randomly drawn to the witness string. This number is often used to measure the performance of a prediction, the goal then being to return the median string, or the string with smallest expected distance.
CIAA 2016;Derived-Term Automata of Multitape Rational Expressions;Akim Demaille;We introduce (weighted) rational expressions to denote series over Cartesian products of monoids. To this end, we propose the operator \(\mathbin {|}\) to build multitape expressions such as \((a^+\mathbin {|}x + b^+\mathbin {|}y)^*\). We define expansions, which generalize the concept of derivative of a rational expression, but relieved from the need of a free monoid. We propose an algorithm based on expansions to build multitape automata from multitape expressions.
CIAA 2016;Solving Parity Games Using an Automata-Based Algorithm;Antonio Di Stasio, Aniello Murano, Giuseppe Perelli, Moshe Y. Vardi;Parity games are abstract infinite-round games that take an important role in formal verification. In the basic setting, these games are two-player, turn-based, and played under perfect information on directed graphs, whose nodes are labeled with priorities. The winner of a play is determined according to the parities (even or odd) of the minimal priority occurring infinitely often in that play. The problem of finding a winning strategy in parity games is known to be in UPTime \(\cap \) CoUPTime and deciding whether a polynomial time solution exists is a long-standing open question. In the last two decades, a variety of algorithms have been proposed. Many of them have been also implemented in a platform named PGSolver. This has enabled an empirical evaluation of these algorithms and a better understanding of their relative merits.
CIAA 2016;Ternary Equational Languages;Zoltán Ésik;We present a general method for solving fixed point equations involving pseudo-complementation over complete ternary algebras satisfying some infinite distributivity conditions as generalized truth values, and finitely decomposable algebras as data domains. When the algebra of data domains is a word or a tree algebra, fixed point equations may be interpreted as grammars and we obtain wide classes of (fuzzy) languages and tree languages.
CIAA 2016;Problems on Finite Automata and the Exponential Time Hypothesis;Henning Fernau, Andreas Krebs;We study several classical decision problems on finite automata under the (Strong) Exponential Time Hypothesis. We focus on three types of problems: universality, equivalence, and emptiness of intersection. All these problems are known to be CoNP-hard for nondeterministic finite automata, even when restricted to unary input alphabets. A different type of problems on finite automata relates to aperiodicity and to synchronizing words. We also consider finite automata that work on commutative alphabets and those working on two-dimensional words.
CIAA 2016;A Practical Algorithm for the Uniform Membership Problem of Labeled Multidigraphs of Tree-Width 2 for Spanning Tree Automata;Akio Fujiyoshi;This paper presents a practical algorithm for the uniform membership problem of labeled multidigraphs of tree-width at most 2 for spanning tree automata. Though it has been shown that the membership problem is solvable in linear time for graphs of bounded tree-width, the algorithm obtained in the previous study is unusable in practice because of a big hidden constant.
CIAA 2016;A Practical Simulation Result for Two-Way Pushdown Automata;Robert Glück;The simulation of two-way deterministic and nondeterministic pushdown automata is revisited. A uniform algorithm presented herein decides on a random-access machine in linear time resp. cubic time whether a given pushdown automaton accepts a word, while the actual run of the automaton may take exponential time. The algorithm is practical since it only explores reachable configurations, simulates a class of quasi-deterministic decision problems in linear time even if the pushdown automaton is nondeterministic, and iterates over a simple work list. This is an improvement over previous simulation algorithms.
CIAA 2016;Nondeterministic Complexity of Operations on Closed and Ideal Languages;Michal Hospodár, Galina Jirásková, Peter Mlynárčik;We study the nondeterministic state complexity of basic regular operations on the classes of prefix-, suffix-, factor-, and subword-closed regular languages and on the classes of right, left, two-sided, and all-sided ideal regular languages. For the operations of union, intersection, complementation, concatenation, square, star, and reversal, we get the tight upper bounds for all considered classes.
CIAA 2016;On Bounded Semilinear Languages, Counter Machines, and Finite-Index ET0L;Oscar H. Ibarra, Ian McQuillan;We show that for every trio \(\mathcal{L}\) containing only semilinear languages, all bounded languages in \(\mathcal{L}\) can be accepted by one-way nondeterministic reversal-bounded multicounter machines (\(\textsf {NCM}\)), and in fact, even by the deterministic versions of these machines \((\textsf {DCM})\). This implies that for every semilinear trio (where these properties are effective), it is possible to decide containment, equivalence, and disjointness concerning its bounded languages. We also provide a relatively simple condition for when the bounded languages in a semilinear trio coincide exactly with those accepted by \(\textsf {DCM}\) machines. This is applied to finite-index \(\textsf {ET0L}\) systems, where we show that the bounded languages generated by these systems are exactly the bounded languages accepted by \(\textsf {DCM}\). We also define, compare, and characterize several other types of languages that are both bounded and semilinear.
CIAA 2016;Kuratowski Algebras Generated by Prefix-Free Languages;Jozef Jirásek Jr., Juraj Šebej;We study Kuratowski algebras generated by prefix-free languages under the operations of star and complement. Our results are as follows. Five of 12 possible algebras cannot be generated by any prefix-free language. Two algebras are generated only by trivial prefix-free languages, the empty set and the language \(\{\varepsilon \}\). Each of the remaining five algebras can be generated, for every \(n\ge 4\), by a regular prefix-free language of state complexity n, which meets the upper bounds on the state complexities of all the languages in the resulting algebra.
CIAA 2016;A Logical Characterization of Small 2NFAs;Christos A. Kapoutsis, Lamana Mulaffer;Let 2N be the class of families of problems solvable by families of two-way nondeterministic finite automata of polynomial size. We characterize 2N in terms of families of formulas of transitive-closure logic. These formulas apply the transitive-closure operator on a quantifier-free disjunctive normal form of first-order logic with successor and constants, where (i) apart from two special variables, all others are equated to constants in every clause, and (ii) no clause simultaneously relates these two special variables and refers to fixed input cells. We prove that automata with polynomially many states are as powerful as formulas with polynomially many clauses and polynomially large constants. This can be seen as a refinement of Immerman’s theorem that nondeterministic logarithmic space matches positive transitive-closure logic (NL = FO+pos TC).
CIAA 2016;Experiments with Synchronizing Automata;Andrzej Kisielewicz, Jakub Kowalski, Marek Szykuła;We have improved an algorithm generating synchronizing automata with a large length of the shortest reset words. This has been done by refining some known results concerning bounds on the reset length. Our improvements make possible to consider a number of conjectures and open questions concerning synchronizing automata, checking them for automata with a small number of states and discussing the results. In particular, we have verified the Černý conjecture for all binary automata with at most 12 states, and all ternary automata with at most 8 states.
CIAA 2016;Implementation of Code Properties via Transducers;Stavros Konstantinidis, Casey Meijer, Nelma Moreira, Rogério Reis;The FAdo system is a symbolic manipulator of formal language objects, implemented in Python. In this work, we extend its capabilities by implementing methods to manipulate transducers and we go one level higher than existing formal language systems and implement methods to manipulate objects representing classes of independent languages (widely known as code properties). Our methods allow users to define their own code properties and combine them between themselves or with fixed properties such as prefix codes, suffix codes, error detecting codes, etc. The satisfaction and maximality decision questions are solvable for any of the definable properties. The new online system LaSer allows one to query about a code property and obtain the answer in a batch mode. Our work is founded on independence theory as well as the theory of rational relations and transducers, and contributes with improved algorithms on these objects.
CIAA 2016;On Synchronizing Automata and Uniform Distribution;Emil Lerner;Let \(m &gt. 1, [m] = \{0, 1, \ldots , m-1\}\), \([m]^\infty \) be a set of all one-side infinite sequences with elements from [m]. Consider a function \(g: [m]^\infty \rightarrow [m]^\infty \) which is a bijection defined by a deterministic finite transducer (DFT) whose input/output alphabets are [m]. Denote the prefix of length n of an infinite word w by \(w \bmod m^n\). A function \(f: [m]^\infty \rightarrow [m]^\infty \) is said to be compatible if from \(w_1 \bmod m^n = w_2 \bmod m^n\) it follows \(f(w_1) \bmod m^n= f(w_2) \bmod m^n\). It is known that all functions defined by DFT are compatible. A function f is said to be a uniformly distributed function over \([m]^\infty \) if the set \(\left\{ \frac{\overline{f(z) \bmod m^n}}{m^n}:z \in [m]^n \right\} \) is uniformly distributed as \(n \rightarrow \infty \) (here \(\overline{f(z) \bmod m^n}\) stands for the number whose base-m expansion is first n symbols of f(z)). We prove a necessary and sufficient condition for composite function \(f \odot g\) to be uniformly distributed for any uniformly distributed compatible function \(f:[m]^\infty \rightarrow [m]^\infty \). The condition is based on a generalization of the notion of synchronizing automaton.
CIAA 2015;Automata and Logics for Concurrent Systems: Five Models in Five Pages;Benedikt Bollig;We survey various automata models of concurrent systems and their connection with monadic second-order logic: finite automata, class memory automata, nested-word automata, asynchronous automata, and message-passing automata.
CIAA 2015;Hardware Implementations of Finite Automata and Regular Expressions;Bruce W. Watson;This extended abstract sketches some of the most recent advances in hardware implementations (and surrounding issues) of finite automata and regular expressions.
CIAA 2015;Complexity of Inferring Local Transition Functions of Discrete Dynamical Systems;Abhijin Adiga, Chris J. Kuhlman, Madhav V. Marathe, S. S. Ravi, Daniel J. Rosenkrantz, Richard E. Stearns;We consider the problem of inferring the local transition functions of discrete dynamical systems from observed behavior. Our focus is on synchronous systems whose local transition functions are threshold functions. We assume that the topology of the system is known and that the goal is to infer a threshold value for each node so that the system produces the observed behavior. We show that some of these inference problems are efficiently solvable while others are NP-complete, even when the underlying graph of the dynamical system is a simple path. We also identify a fixed parameter tractable problem in this context.
CIAA 2015;From Ambiguous Regular Expressions to Deterministic Parsing Automata;Angelo Borsotti, Luca Breveglieri, Stefano Crespi Reghizzi, Angelo Morzenti;This new parser generator for ambiguous regular expressions (RE) formally extends the Berry-Sethi (BS) algorithm into a finite-state device that specifies the syntax tree(s). We extend the local testability property of the marked RE’s from terminal strings to linearized syntax trees. The generator supports disambiguation, i.e., selecting a preferred tree in case of ambiguity. The selection is parametric with respect to the Greedy or POSIX criterion. The parser is proved correct and has linear-time complexity. The generator is available as an interactive SW tool (on GitHub - see http://github.com/breveglieri/ebs/README).
CIAA 2015;Deciding Synchronous Kleene Algebra with Derivatives;Sabine Broda, Sílvia Cavadas, Miguel Ferreira, Nelma Moreira;Synchronous Kleene algebra (SKA) is a decidable framework that combines Kleene algebra (KA) with a synchrony model of concurrency. Elements of SKA can be seen as processes taking place within a fixed discrete time frame and that, at each time step, may execute one or more basic actions or then come to a halt. The synchronous Kleene algebra with tests (SKAT) combines SKA with a Boolean algebra. Both algebras were introduced by Prisacariu, who proved the decidability of the equational theory, through a Kleene theorem based on the classical Thompson \(\varepsilon \)-NFA construction. Using the notion of partial derivatives, we present a new decision procedure for equivalence between SKA terms. The results are extended for SKAT considering automata with transitions labeled by Boolean expressions instead of atoms. This work continous previous research done for KA and KAT, where derivative based methods were used in feasible algorithms for testing terms equivalence.
CIAA 2015;On the Hierarchy of Block Deterministic Languages;Pascal Caron, Ludovic Mignot, Clément Miklarz;A regular language is k-block deterministic if it is specified by a k-block deterministic regular expression. This subclass of regular languages has been introduced by Giammarresi et al. as a possible extension of one-unambiguous regular languages defined and characterized by Brüggemann-Klein and Wood. We first show that each k-block deterministic regular language is the alphabetic image of some one-unambiguous regular language. Moreover, we show that the conversion from a minimal DFA of a k-block deterministic regular language to a k-block deterministic automaton not only requires state elimination, and that the proof given by Han and Wood of a proper hierarchy in k-block deterministic languages based on this result is erroneous. Despite these results, we show by giving a parameterized family that there is a proper hierarchy in k-block deterministic regular languages.
CIAA 2015;Security of Numerical Sensors in Automata;Zhe Dang, Dmitry Dementyev, Thomas R. Fischer, William J. Hutton III;Numerical sensors are numerical functions applied on memory contents. We study the computability of the mutual information rate between two sensors in various forms of automata, including nondeterministic pushdown automata augmented with reversal-bounded counters as well as discrete timed automata. The computed mutual information rate can be used to determine whether it is the case that there is essentially no information flow between a low sensor and a high sensor and hence could provide a way to quantitatively and algorithmically analyze some covert channels.
CIAA 2015;Jumping Finite Automata: Characterizations and Complexity;Henning Fernau, Meenakshi Paramasivan, Markus L. Schmid;We characterize the class of languages described by jumping finite automata (i. e., finite automata, for which the input head after reading (and consuming) a symbol, can jump to an arbitrary position of the remaining input) in terms of special shuffle expressions. We can characterize some interesting subclasses of this language class. The complexity of parsing these languages is also investigated.
CIAA 2015;Run-Length Encoded Nondeterministic KMP and Suffix Automata;Emanuele Giaquinta;We present a novel bit-parallel representation, based on the run-length encoding, of the nondeterministic KMP and suffix automata for a string P with at least two distinct symbols. Our encoding requires \(O((\sigma + m)\lceil \rho / w\rceil )\) space and allows one to simulate the automata on a string in time \(O(\lceil \rho / w\rceil )\) per transition, where \(\sigma \) is the alphabet size, m is the length of P, \(\rho \) is the length of the run-length encoding of P and w is the machine word size in bits. The input string can be given in either unencoded or run-length encoded form. Finally, we present practical variants of the Shift-And and BNDM algorithms based on this encoding.
CIAA 2015;More on Deterministic and Nondeterministic Finite Cover Automata;Hermann Gruber, Markus Holzer, Sebastian Jakobi;Finite languages are an important sub-regular language family, which were intensively studied during the last two decades in particular from a descriptional complexity perspective. An important contribution to the theory of finite languages are the deterministic and the recently introduced nondeterministic finite cover automata (DFCAs and NFCAs, respectively) as an alternative representation of finite languages by ordinary finite automata. We compare these two types of cover automata from a descriptional complexity point of view, showing that these devices have a lot in common with ordinary finite automata. In particular, we study how to adapt lower bound techniques for nondeterministic finite automata to NFCAs such as, e.g., the biclique edge cover technique, solving an open problem from the literature. Moreover, the trade-off of conversions between DFCAs and NFCAs as well as between finite cover automata and ordinary finite automata are investigated. Finally, we present some results on the average size of finite cover automata.
CIAA 2015;On the Number of Synchronizing Colorings of Digraphs;Vladimir V. Gusev, Marek Szykuła;We deal with k-out-regular directed multigraphs with loops (called simply digraphs). The edges of such a digraph can be colored by elements of some fixed k-element set in such a way that outgoing edges of every vertex have different colors. Such a coloring corresponds naturally to an automaton. The road coloring theorem states that every primitive digraph has a synchronizing coloring.
CIAA 2015;On the Uniform Random Generation of Non Deterministic Automata Up to Isomorphism;Pierre-Cyrille Héam, Jean-Luc Joly;In this paper we address the problem of the uniform random generation of non deterministic automata (NFA) up to isomorphism. First, we show how to use a Monte-Carlo approach to uniformly sample a NFA. Secondly, we show how to use the Metropolis-Hastings Algorithm to uniformly generate NFAs up to isomorphism. Using labeling techniques, we show that in practice it is possible to move into the modified Markov Chain efficiently, allowing the random generation of NFAs up to isomorphism with dozens of states. This general approach is also applied to several interesting subclasses of NFAs (up to isomorphism), such as NFAs having a unique initial states and a bounded output degree. Finally, we prove that for these interesting subclasses of NFAs, moving into the Metropolis Markov chain can be done in polynomial time. Promising experimental results constitute a practical contribution.
CIAA 2015;Random Generation and Enumeration of Accessible Deterministic Real-Time Pushdown Automata;Pierre-Cyrille Héam, Jean-Luc Joly;This paper presents a general framework for the uniform random generation of deterministic real-time accessible pushdown automata. A polynomial time algorithm to randomly generate a pushdown automaton having a fixed stack operations total size is proposed. The influence of the accepting condition (empty stack, final state) on the reachability of the generated automata is investigated.
CIAA 2015;Subword Metrics for Infinite Words;Stefan Hoffmann, Ludwig Staiger;The space of one-sided infinite words plays a crucial rôle in several parts of Theoretical Computer Science. Usually, it is convenient to regard this space as a metric space, the Cantor-space. It turned out that for several purposes topologies other than the one of the Cantor-space are useful, e.g. for studying fragments of first-order logic over infinite words or for a topological characterisation of random infinite words.
CIAA 2015;From Two-Way to One-Way Finite Automata—Three Regular Expression-Based Methods;Mans Hulden;We describe three regular expression-based methods to characterize as a regular language the language defined by a two-way automaton. The construction methods yield relatively simple techniques to directly construct one-way automata that simulate the behavior of two-way automata. The approaches also offer conceptually uncomplicated alternative equivalence proofs of two-way automata and one-way automata, particularly in the deterministic case.
CIAA 2015;Describing Homing and Distinguishing Sequences for Nondeterministic Finite State Machines via Synchronizing Automata;Natalia Kushik, Nina Yevtushenko;There is a long standing problem of the study of homing and distinguishing sequences for deterministic and nondeterministic Finite State Machines (FSMs) which are widely used in many applications. A homing sequence allows establishing the state of the given FSM after applying the sequence while a distinguishing sequence allows learning the state of the given FSM before the sequence is applied. On the other hand, other sequences, namely, synchronizing sequences, have been thoroughly studied for finite automata. For a synchronizing automaton, there is a state such that a synchronizing sequence takes the automaton from any state to this state. There are many papers reported on such automata as well as on the complexity of synchronizing sequences. In this paper, given a complete nondeterministic FSM, we propose a method for deriving a corresponding finite automaton such that the set of all homing (or distinguishing) sequences coincides with the set of all synchronizing sequences of the derived automaton.
CIAA 2015;Expressive Capacity of Concatenation Freeness;Martin Kutrib, Matthias Wendlandt;The expressive capacity of regular expressions without concatenation, but with complementation and a finite set of words as literals is studied. In particular, a characterization of unary concatenation-free languages by the Boolean closure of certain sets of languages is shown. The characterization is then used to derive regular languages that are not concatenation free. Closure properties of the family of concatenation-free languages are derived. Furthermore, the position of the family in the subregular hierarchy is considered and settled for the unary case. In particular, there are concatenation-free languages that do not belong to all of the families in the hierarchy. Moreover, except for comets, all of the families in the subregular hierarchy considered are strictly included in the family of concatenation-free languages.
CIAA 2014;FPsolve: A Generic Solver for Fixpoint Equations over Semirings;Javier Esparza, Michael Luttenberger, Maximilian Schlund;We introduce FPsolve, an implementation of generic algorithms for solving fixpoint equations over semirings. We first illustrate the interest of generic solvers by means of a scenario. We then succinctly describe some of the algorithms implemented in the tool, and provide some implementation details.
CIAA 2014;Restarting Automata for Picture Languages: A Survey on Recent Developments;Friedrich Otto;Much work has been done to obtain classes of picture languages that would correspond to the classes of the Chomsky hierarchy for string languages, and finally the class REC of recognizable picture languages has been agreed on as the class that corresponds to the ‘regular string languages.’ This class has several nice characterizations in terms of regular expressions, tiling automata, and on-line tesselation automata, and it has nice closure properties, but it also has two main drawbacks: all its characterizations are highly nondeterministic in nature, and it contains languages that are NP-complete. Consequentially, various deterministic subclasses of REC have been defined. Mainly, however, these definitions are quite complex, and it is not clear which of the resulting classes should be considered as ‘the’ class of deterministic recognizable picture languages. Here we present some recent developments obtained in a research project that aims at finding a deterministic model of a two-dimensional automaton that has the following desirable properties:
CIAA 2014;Investigations on Automata and Languages over a Unary Alphabet;Giovanni Pighizzini;The investigation of automata and languages defined over a one letter alphabet shows interesting differences with respect to the case of alphabets with at least two letters. Probably, the oldest example emphasizing one of these differences is the collapse of the classes of regular and context-free languages in the unary case (Ginsburg and Rice, 1962). Many differences have been proved concerning the state costs of the simulations between different variants of unary finite state automata (Chrobak, 1986, Mereghetti and Pighizzini, 2001). We present an overview of those results. Because important connections with fundamental questions in space complexity, we give emphasis to unary two-way automata. Furthermore, we discuss unary versions of other computational models, as one-way and two-way pushdown automata, even extended with auxiliary workspace, and multi-head automata.
CIAA 2014;Cellular Automata for Crowd Dynamics;Georgios Ch. Sirakoulis;Cellular Automata (CA) as bio-inspired parallel computational models of self-reproducing organisms can capture the essential features of systems where global behavior arises from the collective effect of simple components which interact locally. In this aspect, CAs have been considered as a fine candidate to model pedestrian behavior and crowd dynamics in a fine manner. In specific, for crowd modeling, the CA models show evidence of a macroscopic nature with microscopic extensions, i.e. they provide adequate details in the description of human behavior and interaction, whilst they retain the computational cost at low levels. In this paper several CA models for crowd evacuation taking into consideration different modeling principles, like potential fields techniques, obstacle avoidance, follow-the-leader principles, grouping theory, etc. will be presented in an attempt to accomplish efficient crowd evacuation simulation. Moreover, an integrated system based on CAs that operates as an anticipative crowd management tool in cases of medium density crowd evacuation for indoor and outdoor environments is also shown, and its results different real world cases and different environments prove its efficiency. Finally, robot guided evacuation with the help of CAs is also presented. Quite recently, an evacuation system was proposed, based on an accurate CA model capable of assessing the human behavior during emergency situations takes advantage of the simulation output to provide sufficient information to a mobile robotic guide, which in turn guides people towards a less congestive exit at a time.
CIAA 2014;Counting Equivalent Linear Finite Transducers Using a Canonical Form;Ivone Amorim, António Machiavelo, Rogério Reis;The notion of linear finite transducer (LFT) plays a crucial role in a family of cryptosystems introduced in the 80’s and 90’s. However, as far as we know, no study was ever conducted to count and enumerate these transducers, which is essential to verify if the size of the key space, of the aforementioned systems, is large enough to prevent an exhaustive search attack. In this paper, we determine the cardinal of the equivalence classes on the set of the LFTs with a given size. This result is sufficient to get an approximate value, by random sampling, for the number of non-equivalent injective LFTs, and subsequently for the size of the key space. We introduce a notion of canonical LFT, give a method to verify if two LFTs are equivalent, and prove that every LFT has exactly one equivalent canonical LFT. We then show how this canonical LFT allows us to calculate the size of each equivalence class on the set of the LFTs with the same number of states.
CIAA 2014;On the Power of One-Way Automata with Quantum and Classical States;Maria Paola Bianchi, Carlo Mereghetti, Beatrice Palano;We consider the model of one-way automata with quantum and classical states (qcfas) introduced in [23]. We show, by a direct approach, that qcfas with isolated cut-point accept regular languages only, thus characterizing their computational power. Moreover, we give a size lower bound for qcfas accepting regular languages, and we explicitly build qcfas accepting the word quotients and inverse homomorphic images of languages accepted by given qcfas with isolated cut-point, maintaining the same cut-point, isolation, and polynomially increasing the size.
CIAA 2014;On Comparing Deterministic Finite Automata and the Shuffle of Words;Franziska Biegler, Ian McQuillan;We continue the study of the shuffle of individual words, and the problem of decomposing a finite automaton into the shuffle on words. There is a known polynomial time algorithm to decide whether the shuffle of two words is a subset of the language accepted by a deterministic finite automaton [5]. In this paper, we consider the converse problem of determining whether or not the language accepted by a deterministic finite automaton is a subset of the shuffle of two words. We provide a polynomial time algorithm to decide whether the language accepted by a deterministic finite automaton is a subset of the shuffle of two words, for the special case when the skeletons of the two words are of fixed length. Therefore, for this special case, we can decide equality in polynomial time as well. However, we then show that this problem is coNP-Complete in general, as conjectured in [2].
CIAA 2014;Minimal Partial Languages and Automata;Francine Blanchet-Sadri, Kira Goldner, Aidan Shackleton;Partial words are sequences of characters from an alphabet in which some positions may be marked with a “hole” symbol, ⋄. We can create a ⋄-substitution mapping this symbol to a subset of the alphabet, so that applying such a substitution to a partial word results in a set of full words (ones without holes). This setup allows us to compress regular languages into smaller partial languages. Deterministic finite automata for such partial languages, referred to as ⋄-DFAs, employ a limited non-determinism that can allow them to have lower state complexity than the minimal DFAs for the corresponding full languages. Our paper focuses on algorithms for the construction of minimal partial languages, associated with some ⋄-substitution, as well as approximation algorithms for the construction of minimal ⋄-DFAs.
CIAA 2014;Large Aperiodic Semigroups;Janusz Brzozowski, Marek Szykuła;We search for the largest syntactic semigroup of a star-free language having n left quotients. equivalently, we look for the largest transition semigroup of an aperiodic finite automaton with n states.
CIAA 2014;On the Square of Regular Languages;Kristína Čevorová, Galina Jirásková, Ivana Krajňáková;We show that the upper bound (n − k)·2n + k·2n − 1 on the state complexity of the square of a regular language recognized by an n-state deterministic finite automaton with k final states is tight in the ternary case for every k with 1 ≤ k ≤ n − 2. Using this result, we are able to define a language that is hard for the square operation on languages accepted by alternating finite automata. In the unary case, the known upper bound for square is 2n − 1, and we prove that each value in the range from 1 to 2n − 1 may be attained by the state complexity of the square of a unary language with state complexity n whenever n ≥ 5.
CIAA 2014;Unary Languages Recognized by Two-Way One-Counter Automata;Marzio De Biasi, Abuzer Yakaryılmaz;A two-way deterministic finite state automaton with one counter (2D1CA) is a fundamental computational model that has been examined in many different aspects since sixties, but we know little about its power in the case of unary languages. Up to our knowledge, the only known unary nonregular languages recognized by 2D1CAs are those formed by strings having exponential length, where the exponents form some trivial unary regular language. In this paper, we present some non-trivial subsets of these languages. By using the input head as a second counter, we present simulations of two-way deterministic finite automata with linearly bounded counters and linear–space Turing machines. We also show how a fixed-size quantum register can help to simplify some of these languages. Finally, we compare unary 2D1CAs with two–counter machines and provide some insights about the limits of their computational power.
CIAA 2014;A Type System for Weighted Automata and Rational Expressions;Akim Demaille, Alexandre Duret-Lutz, Sylvain Lombardy, Luca Saiu, Jacques Sakarovitch;We present a type system for automata and rational expressions, expressive enough to encompass weighted automata and transducers in a single coherent formalism. The system allows to express useful properties about the applicability of operations including binary heterogeneous functions over automata.
CIAA 2014;Bounded Prefix-Suffix Duplication;Marius Dumitran, Javier Gil, Florin Manea, Victor Mitrana;We consider a restricted variant of the prefix-suffix duplication operation, called bounded prefix-suffix duplication. It consists in the iterative duplication of a prefix or suffix, whose length is bounded by a constant, of a given word. We give a sufficient condition for the closure under bounded prefix-suffix duplication of a class of languages. Consequently, the class of regular languages is closed under bounded prefix-suffix duplication. furthermore, we propose an algorithm deciding whether a regular language is a finite k-prefix-suffix duplication language. An efficient algorithm solving the membership problem for the k-prefix-suffix duplication of a language is also presented. Finally, we define the k-prefix-suffix duplication distance between two words, extend it to languages and show how it can be computed for regular languages.
CIAA 2014;Recognition of Labeled Multidigraphs by Spanning Tree Automata;Akio Fujiyoshi;In this paper, we study tree automata recognizing labeled multidigraphs. We define that a labeled multidigraph is accepted by a tree automaton if and only if the graph has a spanning tree accepted by the tree automaton. We call this automaton a spanning tree automaton. The membership problem of labeled multidigraphs for a spanning tree automaton is NP-complete because the Hamiltonian path problem can be easily reduced to it. However, it will be shown that the membership problem is solvable in linear time for graphs of bounded tree-width.
CIAA 2014;Reset Thresholds of Automata with Two Cycle Lengths;Vladimir V. Gusev, Elena V. Pribavkina;We present several series of synchronizing automata with multiple parameters, generalizing previously known results. Let p and q be two arbitrary co-prime positive integers, q &gt. p. We describe reset thresholds of the colorings of primitive digraphs with exactly one cycle of length p and one cycle of length q. Also, we study reset thresholds of the colorings of primitive digraphs with exactly one cycle of length q and two cycles of length p.
CIAA 2014;On the Ambiguity, Finite-Valuedness, and Lossiness Problems in Acceptors and Transducers;Oscar H. Ibarra;We prove new decidability and undecidability results concerning the finite-ambiguity problem in acceptors, and the finite-valuedness and lossiness problems in transducers. The acceptors and transducers we study have infinite memory.
CIAA 2014;Kleene Closure on Regular and Prefix-Free Languages;Galina Jirásková, Matúš Palmovský, Juraj Šebej;We study the Kleene closure operation on regular and prefix-free languages. Using an alphabet of size 2n, we get the contiguous range from 1 to 3/4·2n of complexities of the Kleene closure of regular languages accepted by minimal n-state deterministic finite automata. In the case of prefix-free languages, the Kleene closure may attain just three possible complexities n − 2, n − 1, and n.
CIAA 2014;Left is Better than Right for Reducing Nondeterminism of NFAs;Sang-Ki Ko, Yo-Sub Han;We study the NFA reductions by invariant equivalences. It is well-known that the NFA minimization problem is PSPACE-complete. Therefore, there have been approaches to reduce the size of NFAs in low polynomial time by computing invariant equivalence and merging the states within same equivalence class. Here we consider the nondeterminism reduction of NFAs by invariant equivalences. We, in particular, show that the left-invariant equivalence is more useful than the right-invariant equivalence for reducing NFA nondeterminism. We also present experimental evidence for showing that NFA reduction by left-invariant equivalence achieves the better reduction of nondeterminism than right-invariant equivalence.
CIAA 2014;Analytic Functions Computable by Finite State Transducers;Petr Kůrka, Tomáš Vávra;We show that the only analytic functions computable by finite state transducers in sofic Möbius number systems are Möbius transformations.
CIAA 2013;Cover Languages and Implementations;Cezar Câmpeanu;A cover language is a superset of a given language. Deterministic Finite Cover Automata (DFCA) are Deterministic Finite Automata (DFA) accepting finite languages and other words longer than any word in the given language. Some papers from the 60’s were constructing DFCAs as a byproduct using ad-hoc procedures, but DFCAs have never been defined until 1998. The notion of Deterministic Finite Cover Automaton, which is based on the concept of similarity relations, was introduced for the very first time at WIA’98, where the authors give the first rigorous formal definition and a clear minimization algorithm.
CIAA 2013;Automata for Codes;Helmut Jürgensen;We survey the actual and potential rôles of automata in the modelling of information transmission systems and, in particular, in the encoder, channel and decoder components of such systems. Our focus is on applications of codes in such systems and on the relevance of automaton theoretic methods to these applications. We discuss, for example, the issues of error-detection, fault-tolerance and error-correction for variable-length codes. Beyond reviewing known work in a possibly new setting, we also present some recent results on fault-tolerant decoders for systems in which synchronization errors are likely. We conclude with a kind of research programme, a list of rather general open problems requiring solutions.
CIAA 2013;Applications of Symbolic Finite Automata;Margus Veanes;Symbolic automata theory lifts classical automata theory to rich alphabet theories. It does so by replacing an explicit alphabet with an alphabet described implicitly by a Boolean algebra. How does this lifting affect the basic algorithms that lay the foundation for modern automata theory and what is the incentive for doing this? We investigate these questions here. In our approach we use state-of-the-art constraint solving techniques for automata analysis that are both expressive and efficient, even for very large and infinite alphabets. We show how symbolic finite automata enable applications ranging from modern regex analysis to advanced web security analysis, that were out of reach with prior methods.
CIAA 2013;Computing Weights;Houda Abbad, Éric Laugerotte;This paper introduces an efficient weighted regognition algorithm. It is based on a suitable tree structure called ZPC without building the position automaton. The ZPC-structure results from the compact language and the polynomial structure of weighted expressions. We show that the time complexity of this algorithm is the best oneuntil now.
CIAA 2013;Partial Word DFAs;Eric Balkanski, F. Blanchet-Sadri, Matthew Kilgore, B. J. Wyatt;Recently, Dassow et al. connected partial words and regular languages. Partial words are sequences in which some positions may be undefined, represented with a “hole” symbol ⋄. If we restrict what the symbol ⋄ can represent, we can use partial words to compress the representation of regular languages. Doing so allows the creation of so-called ⋄-DFAs which are smaller than the DFAs recognizing the original language L, which recognize the compressed language. However, the ⋄-DFAs may be larger than the NFAs recognizing L. In this paper, we investigate a question of Dassow et al. as to how these sizes are related.
CIAA 2013;Using Regular Grammars for Event-Based Testing;Fevzi Belli, Mutlu Beyazıt;Model-based testing involves formal models for test generation. This paper suggests regular grammars for event-based modeling. This model, represented in BNF, will then be systematically modified by well-defined mutation operators in order to generate fault models, called mutants. Specific algorithms apply to both the model of the system under consideration and the mutants to generate test cases. While existing methods focus on single events the approach introduced in this paper suggests considering event sequences of length k≥1, that is, k-sequences. The approach also enables to cope with a tough problem encountered in mutation-oriented testing: the elimination of mutants that are equivalent to the original model, and mutants that model the same faults multiple times. These mutants lead to unproductive test suites that cause wasting of resources. The approach proposed devises strategies to exclude the mentioned mutants in that they will not be generated at all.
CIAA 2013;Two-Pass Greedy Regular Expression Parsing;Niels Bjørn Bugge Grathwohl, Fritz Henglein, Lasse Nielsen, Ulrik Terp Rasmussen;We present new algorithms for producing greedy parses for regular expressions (REs) in a semi-streaming fashion. Our lean-log algorithm executes in time O(mn) for REs of size m and input strings of size n and outputs a compact bit-coded parse tree representation. It improves on previous algorithms by: operating in only 2 passes. using only O(m) words of random-access memory (independent of n). requiring only kn bits of sequentially written and read log storage, where \(k &lt. \frac{1}{3} m\) is the number of alternatives and Kleene stars in the RE. processing the input string as a symbol stream and not requiring it to be stored at all. Previous RE parsing algorithms do not scale linearly with input size, or require substantially more log storage and employ 3 passes where the first consists of reversing the input, or do not or are not known to produce a greedy parse. The performance of our unoptimized C-based prototype indicates that our lean-log algorithm has also in practice superior performance and is surprisingly competitive with RE tools not performing full parsing, such as Grep.
CIAA 2013;Universal Witnesses for State Complexity of Basic Operations Combined with Reversal;Janusz Brzozowski, David Liu;We study the state complexity of boolean operations, concatenation, and star, with one or two of the argument languages reversed. We derive tight upper bounds for the symmetric differences and differences of such languages. We prove that the previously discovered bounds for union, intersection, concatenation and star of such languages can all be met by the recently introduced universal witness and its variants.
CIAA 2013;Trimming Visibly Pushdown Automata;Mathieu Caralp, Pierre-Alain Reynier, Jean-Marc Talbot;We study the problem of trimming visibly pushdown automata (VPA). We first describe a polynomial time procedure which, given a visibly pushdown automaton that accepts only well-nested words, returns an equivalent visibly pushdown automaton that is trimmed. We then show how this procedure can be lifted to the setting of arbitrary VPA. Furthermore, we present a way of building, given a VPA, an equivalent VPA which is both deterministic and trimmed.
CIAA 2013;A Uniformization Theorem for Nested Word to Word Transductions;Dmitry Chistikov, Rupak Majumdar;We study the class of relations implemented by nested word to word transducers (also known as visibly pushdown transducers). We show that any such relation can be uniformized by a functional relation from the same class, implemented by an unambiguous transducer. We give an exponential upper bound on the state complexity of the uniformization, improving a previous doubly exponential upper bound. Our construction generalizes a classical construction by Schützenberger for the disambiguation of nondeterministic finite-state automata, using determinization and summarization constructions on nested word automata. Besides theoretical interest, our procedure can be the basis for synthesis procedures for nested word to word transductions.
CIAA 2013;Towards Nominal Context-Free Model-Checking;Pierpaolo Degano, Gian-Luigi Ferrari, Gianluca Mezzetti;Two kinds of automata are introduced, for recognising regular and context-free nominal languages. We compare their expressive power with that of analogous proposals in the literature. Some properties of our languages are proved, in particular that emptiness of a context-free nominal language L is decidable, and that the intersection of L with a regular nominal language is still context-free. This paves the way for model-checking systems against access control properties in the nominal case, which is our main objective.
CIAA 2013;Implementation Concepts in Vaucanson 2;Akim Demaille, Alexandre Duret-Lutz, Sylvain Lombardy, Jacques Sakarovitch;Vaucanson is an open source C++ platform dedicated to the computation with finite weighted automata. It is generic: it allows to write algorithms that apply on a wide set of mathematical objects. Initiated ten years ago, several shortcomings were discovered along the years, especially problems related to code complexity and obfuscation as well as performance issues. This paper presents the concepts underlying Vaucanson 2, a complete rewrite of the platform that addresses these issues.
CIAA 2013;A Completion Algorithm for Lattice Tree Automata;Thomas Genet, Tristan Le Gall, Axel Legay, Valérie Murat;When dealing with infinite-state systems, Regular Tree Model Checking approaches may have some difficulties to represent infinite sets of data. We propose Lattice Tree Automata, an extended version of tree automata to represent complex data domains and their related operations in an efficient manner. Moreover, we introduce a new completion-based algorithm for computing the possibly infinite set of reachable states in a finite amount of time. This algorithm is independent of the lattice making it possible to seamlessly plug abstract domains into a Regular Tree Model Checking algorithm. As a first instance, we implemented a completion with an interval abstract domain. We provide some experiments showing that this implementation permits to scale up regular tree model-checking of Java programs dealing with integer arithmetics.
CIAA 2013;Approximate Matching between a Context-Free Grammar and a Finite-State Automaton;Yo-Sub Han, Sang-Ki Ko, Kai Salomaa;Given a context-free grammar (CFG) and a finite-state automaton (FA), we tackle the problem of computing the most similar pair of strings from two languages. We in particular consider three different gap cost models, linear, affine and concave models, that are crucial for finding a proper alignment between two bio sequences. We design efficient algorithms for computing the edit-distance between a CFG and an FA under these gap cost models. The time complexity of our algorithm for computing the linear or affine gap distance is polynomial and the time complexity for the concave gap distance is exponential.
CIAA 2013;On Palindromic Sequence Automata and Applications;Md. Mahbubul Hasan, A. S. M. Sohidull Islam, M. Sohel Rahman, Ayon Sen;In this paper, we present a novel weighted finite automata called PSA (Palindromic Subsequence Automata) that is a compact representation of all the palindromic subsequences of a string. Then we use PSA to solve the LCPS (Longest Common Palindromic Subsequence) problem. Our automata based algorithms are efficient both in theory and in practice.
CIAA 2013; LALBLC A Program Testing the Equivalence of dpda’s;Patrick Henry, Géraud Sénizergues;We describe the program LALBLC which tests whether two deterministic pushdown automata recognize the same language.
CIAA 2013;Brzozowski’s Minimization Algorithm—More Robust than Expected;Markus Holzer, Sebastian Jakobi;For a finite automaton, regardless whether it is deterministic or nondeterministic, Brzozowski’s minimization algorithm computes the equivalent minimal deterministic finite automaton by applying reversal and power-set construction twice. Although this is an exponential algorithm because of the power-set construction, it performs well in experimental studies compared to efficient O(nlogn) minimization algorithms. Here we show how to slightly enhance Brzozowski’s minimization algorithm by some sort of reachability information so that it can be applied to the following automata models: deterministic cover automata, almost equivalent deterministic finite state machines, and k-similar automata.
CIAA 2013;Some Decision Problems Concerning NPDAs, Palindromes, and Dyck Languages;Oscar H. Ibarra, Bala Ravikumar;We address several types of decision questions related to context-free languages when an NPDA is given as input. First we consider the question of whether the NPDA makes a bounded number of stack reversals (over all accepting inputs) and show that this problem is undecidable even when the NPDA is only 2-ambiguous. We consider the same problem for counter machines (i.e., whether the counter makes a bounded number of reversals) and show that it is also undecidable. On the other hand, we show that the problem is decidable for unambiguous NPDAs even when augmented with reversal-bounded counters. Next, we look at problems of equivalence, containment and disjointness with fixed languages. With the fixed language L0 being one of the following: P = \(\{ x \# x^r \ | \)x ∈ (0 + 1)* }, Pu = \(\{ x x^r \ | \)x ∈ (0 + 1)* }, Dk = Dyck language with k-type of parentheses, or Sk = two-sided Dyck language with k types of parentheses, we consider problems such as: ‘Is L(M) ∩ L0 = ∅?’, ‘Is L(M) ⊆ L0?’, or ‘Is L(M) = L0?’, where M is an input NPDA (or a restricted form of it). For example, we show that the problem, ‘Is L(M) ∩ P?’, is undecidable when M is a deterministic one-counter acceptor, while the problem ‘Is L(M) ⊆ P?’ is decidable even for NPDAs augmented with reversal-bounded counters. Another result is that the problem ‘Is L(M) ⊆ Pu?’ is decidable in polynomial time for M an NPDA. We also show several other related decidability and undecidability results.
CIAA 2013;On the Boundary of Regular Languages;Jozef Jirásek, Galina Jirásková;We prove that the tight bound on the state complexity of the boundary of regular languages, defined as bd\((L)=L^* \cap ( \, \overline{L} \, )^*\), is 22n − 2 + 22n − 3 + 2n − 2 + 2 − 2·3n − 2 − n. Our witness languages are described over a five-letter alphabet. For a four-letter alphabet, the lower bound is smaller by just one, and we conjecture that the upper bound cannot be met in the quaternary case.
CIAA 2012;In Memoriam Sheng Yu;Yuan Gao, Kai Salomaa;Professor Sheng Yu passed away unexpectedly in London, Canada on January 23, 2012, one day before his 62nd birthday. Sheng was one of the world leading theoretical computer scientists. His strong commitment to excellence in scholarship has touched everyone who has worked or studied with him. This includes a large segment of the “CIAA community” and, in particular, the authors of the current article. Sheng Yu’s work will continue to influence and inspire automata theory research for a long time to come.
CIAA 2012;In Search of Most Complex Regular Languages;Janusz Brzozowski;Regular languages that are most complex under common complexity measures are studied. In particular, certain ternary languages Un(a,b,c), \(n\geqslant 3\), over the alphabet {a,b,c} are examined. It is proved that the state complexity bounds that hold for arbitrary regular languages are also met by the languages Un(a,b,c) for union, intersection, difference, symmetric difference, product (concatenation) and star. Maximal bounds are also met by Un(a,b,c) for the number of atoms, the quotient complexity of atoms, the size of the syntactic semigroup, reversal, and 22 combined operations, 5 of which require slightly modified versions. The language Un(a,b,c,d) is an extension of Un(a,b,c), obtained by adding an identity input to the minimal DFA of Un(a,b,c). The witness Un(a,b,c,d) and its modified versions work for 14 more combined operations. Thus Un(a,b,c) and Un(a,b,c,d) appear to be universal witnesses for alphabets of size 3 and 4, respectively.
CIAA 2012;A Formal Framework for Processes Inspired by the Functioning of Living Cells;Andrzej Ehrenfeucht, Grzegorz Rozenberg;Natural Computing is concerned with both human-designed computing inspired by nature and computing taking place in nature. The former research strand investigates computational techniques, models of computation and computational devices inspired by nature. The latter research strand investigates, in terms of information processing, processes taking place in nature.
CIAA 2012;Adding Pebbles to Weighted Automata;Paul Gastin, Benjamin Monmege;We extend weighted automata and weighted rational expressions with 2-way moves and (reusable) pebbles. We show with examples from natural language modeling and quantitative model-checking that weighted expressions and automata with pebbles are more expressive and allow much more natural and intuitive specifications than classical ones. We extend Kleene-Schützenberger theorem showing that weighted expressions and automata with pebbles have the same expressive power. We focus on an efficient translation from expressions to automata. We also prove that the evaluation problem for weighted automata can be done very efficiently if the number of (reusable) pebbles is low.
CIAA 2012;Typed Linear Algebra for Weigthed (Probabilistic) Automata;José N. Oliveira;There is a need for a language able to reconcile the recent upsurge of interest in quantitative methods in the software sciences with logic and set theory that have been used for so many years in capturing the qualitative aspects of the same body of knowledge. Such a lingua franca should be typed, polymorphic, diagrammatic, calculational and easy to blend with traditional notation.
CIAA 2012;A Pushdown Transducer Extension for the OpenFst Library;Cyril Allauzen, Michael Riley;Pushdown automata are devices that can efficiently represent context-free languages, have natural weighted versions, and combine naturally with finite automata. We describe a pushdown transducer extension to OpenFst, a weighted finite-state transducer library. We present several weighted pushdown algorithms, some with clear finite-state analogues, describe their library usage and give some applications of these methods to recognition, parsing and translation.
CIAA 2012;Weak Inclusion for Recursive XML Types;Joshua Amavi, Jacques Chabin, Pierre Réty;Considering that the unranked tree languages L(G) and L(G′) are those defined by given possibly-recursive XML typesG and G′, this paper proposes a method to verify whether L(G) is “approximatively” included in L(G′). The approximation consists in weakening the father-children relationships. Experimental results are discussed, showing the efficiency of our method in many situations.
CIAA 2012;Synchronizing Automata on Quasi-Eulerian Digraph;Mikhail V. Berlinkov;We describe a new version of the so-called extension method that was used to prove quadratic upper bounds on the minimum length of reset words for various important classes of synchronizing automata. Our approach is formulated in terms of Markov chains. it is in a sense dual to the usual extension method and improves on a recent result by Jungers. As an application, we obtain a quadratic upper bound on the minimum length of reset words for a generalization of Eulerian automata.
CIAA 2012;Cellular Automata on Regular Rooted Trees;Tullio Ceccherini-Silberstein, Michel Coornaert, Francesca Fiorenzi, Zoran Šunić;We study cellular automata on regular rooted trees. This includes the characterization of sofic tree shifts in terms of unrestricted Rabin automata and the decidability of the surjectivity problem for cellular automata between sofic tree shifts.
CIAA 2012;Strict Local Testability with Consensus Equals Regularity;Stefano Crespi Reghizzi, Pierluigi L. San Pietro;A recent language definition device named consensual is based on agreement between similar words. Considering, say, a regular set of words over a bipartite alphabet made by pairs of unmarked/marked letters, the match relation specifies when such words agree. Therefore a regular set (the “base”) over the bipartite alphabet specifies another language over the unmarked alphabet, called the consensual language. A word is in the consensual language if a set of corresponding matching words is in the base. From previous results, the family of consensual languages based on regular sets have an NLOGSPACE word problem, include non-semilinear languages, and are incomparable with the context-free (CF) ones. moreover the size of a consensual specification can be in a logarithmic ratio with respect to a NFA for the same language. We study the consensual languages that are produced by other language families: the Strictly Locally Testable of McNaughton and Papert and the context-free/sensitive ones. Using a recent generalization of Medvedev’s homomorphic characterization of regular languages, we prove that regular languages are exactly the consensual languages based on strictly locally testable sets, a result that hints at a novel parallel decomposition of finite automata into locally testable components. The consensual family based on context-free sets strictly includes the CF family, while the consensual and the base families collapse together if the context-sensitive languages are chosen instead of the CF.
CIAA 2012;Nominal Automata for Resource Usage Control;Pierpaolo Degano, Gian-Luigi Ferrari, Gianluca Mezzetti;Two classes of nominal automata, namely Usage Automata (UAs) and Variable Finite Automata (VFAs) are considered to express resource control policies over program execution traces expressed by a nominal calculus (Usages). We first analyse closure properties of UAs, and then show UAs less expressive than VFAs. We finally carry over to VFAs the symbolic technique for model checking Usages against UAs, so making it possible to verify the compliance of a program with a larger class of security properties.
CIAA 2012;Weighted Nested Word Automata and Logics over Strong Bimonoids;Manfred Droste, Bundit Pibaljommee;Nested words have been introduced by Alur and Madhusudan as a model for e.g. recursive programs or XML documents and have received much recent interest. In this paper, we investigate a quantitative automaton model and a quantitative logic for nested words. The behavior resp. the semantics map nested words to weights taken from a strong bimonoid. Strong bimonoids can be viewed as semirings without requiring the distributivity assumption which was essential in the classical theory of formal power series. strong bimonoids include e.g. all bounded lattices and many other structures from multi-valued logics. Our main results show that weighted nested word automata and suitable weighted MSO logics are expressively equivalent. This extends the classical Büchi-Elgot result from words to a weighted setting for nested words.
CIAA 2012;A Fast Suffix Automata Based Algorithm for Exact Online String Matching;Simone Faro, Thierry Lecroq;Searching for all occurrences of a pattern in a text is a fundamental problem in computer science with applications in many other fields, like natural language processing, information retrieval and computational biology. Automata play a very important role in the design of efficient solutions for the exact string matching problem. In this paper we propose a new very simple solution which turns out to be very efficient in practical cases. It is based on a suitable factorization of the pattern and on a straightforward and light encoding of the suffix automaton. It turns out that on average the new technique leads to longer shift than that proposed by other known solutions which make use of suffix automata.
CIAA 2012;P(l)aying for Synchronization;Fedor Fominykh, Mikhail Volkov;Two topics are presented: synchronization games and synchronization costs. In a synchronization game on a deterministic finite automaton, there are two players, Alice and Bob, whose moves alternate. Alice wants to synchronize the given automaton, while Bob aims to make her task as hard as possible. We answer a few natural questions related to such games. Speaking about synchronization costs, we consider deterministic automata in which each transition has a certain price. The problem is whether or not a given automaton can be synchronized within a given budget. We determine the complexity of this problem.
CIAA 2012;Synchronizing Automata of Bounded Rank;Vladimir V. Gusev;We reduce the problem of synchronization of an n-state automaton with letters of rank at most r &lt. n to the problem of synchronization of an r-state automaton with constraints given by a regular language. Using this technique we construct a series of synchronizing n-state automata in which every letter has rank r &lt. n and whose reset threshold is at least r2 − r − 1 Moreover, if \(r &gt. \frac{n}{2}\), such automata are strongly connected.
CIAA 2012;Automatic Theorem-Proving in Combinatorics on Words;Daniel Goč, Dane Henshall, Jeffrey Shallit;We describe a technique for mechanically proving certain kinds of theorems in combinatorics on words, using finite automata and a package for manipulating them. We illustrate our technique by applying it to (a) solve an open problem of Currie and Saari on the lengths of unbordered factors in the Thue-Morse sequence. (b) verify an old result of Prodinger and Urbanek on the paperfolding sequence and (c) find an explicit expression for the recurrence function for the Rudin-Shapiro sequence. All results were obtained by machine computations.
CIAA 2012;How to Synchronize the Heads of a Multitape Automaton;Oscar H. Ibarra, Nicholas Q. Tran;Given an n-tape automaton M with a one-way read-only head per tape and a right end marker $ on each tape, we say that M is aligned or 0-synchronized (or simply, synchronized) if for every n-tuple x = (x1, …, xn) that is accepted, there is a computation on x such that at any time during the computation, all heads, except those that have reached the end marker, are on the same position. When a head reaches the marker, it can no longer move. As usual, an n-tuple x = (x1, …, xn) is accepted if M eventually reaches the configuration where all n heads are on $ in an accepting state. In two recent papers, we looked at the problem of deciding, given an n-tape automaton of a given type, whether there exists an equivalent synchronized n-tape automaton of the same type. In this paper, we exhibit various classes of multitape automata which can(not) be converted to equivalent synchronized multitape automata.
CIAA 2012;Regular Ideal Languages and Their Boolean Combinations;Franz Jahn, Manfred Kufleitner, Alexander Lauser;We consider ideals and Boolean combinations of ideals. For the regular languages within these classes we give expressively complete automaton models. In addition, we consider general properties of regular ideals and their Boolean combinations. These properties include effective algebraic characterizations and lattice identities.
CIAA 2012;Hyper-minimization for Deterministic Tree Automata;Artur Jeż, Andreas Maletti;Hyper-minimization aims to reduce the size of the representation of a language beyond the limits imposed by classical minimization. To this end, the hyper-minimal representation can represent a language that has a finite difference to the original language. The first hyper-minimization algorithm is presented for (bottom-up) deterministic tree automata, which represent the recognizable tree languages. It runs in time \({\cal O}(\ell m n)\), where ℓ is the maximal rank of the input symbols, m is the number of transitions, and n is the number of states of the input tree automaton.
CIAA 2011;Derick Wood: Always in Our Hearts;Sheng Yu;Professor Derick Wood passed away on October 4, 2010. He was only seventy year old. His death was a great loss to his family, friends, colleagues and students, especially to his beloved wife Mary. He left us many interesting research results, more than three hundred publications [1], including three monograph and textbooks [3,4,5], and a lot of vivid memories of an energetic, thoughtful, humorous, careful, and decisive Derick Wood.
CIAA 2011;Streamable Fragments of Forward XPath;Olivier Gauwin, Joachim Niehren;We present a query answering algorithm for a fragment of Forward XPath on Xml streams that we obtain by compilation to deterministic nested word automata. Our algorithm is earliest and in polynomial time. This proves the finite streamability of the fragment of Forward XPath with child steps, outermost-descendant steps, label tests, negation, and conjunction (aka filters), under the reasonable assumption that the number of conjunctions is bounded. We also prove that finite streamability fails without this assumption except if P=NP.
CIAA 2011;Gaining Power by Input Operations: Finite Automata and Beyond;Markus Holzer, Martin Kutrib;We summarize results on extended finite automata, which are basically finite state machines with the additional ability to manipulate the still unread part of the input. Well-known manipulation functions are reversal, left-revolving, right-revolving, and circular interchanging, or even biologically motivated functions as hairpin inversion. We mainly focus on the computational power of these machines and on the closure properties by standard formal language operations of the induced language families. Moreover, we also discuss several generalizations of this concept, the natural generalization to hybrid extended finite automata, which allows several input manipulation functions, and in particular, extended pushdown automata, which lead to an alternative characterization of Khabbaz hierarchy of languages. We do not prove these results but we merely draw attention to the big picture, some of the main ideas involved, and open problems for further research.
CIAA 2011;Weak Inclusion for XML Types;Joshua Amavi, Jacques Chabin, Mirian Halfeld Ferrari, Pierre Réty;Considering that the unranked tree languages L(G) and L(G′) are those defined by given non-recursive XML typesG and G′, this paper proposes a simple and intuitive method to verify whether L(G) is “approximatively” included in L(G′). Our approximative criterion consists in weakening the father-children relationships. Experimental results are discussed, showing the efficiency of our method in many situations.
CIAA 2011;Categorial Grammars with Iterated Types form a Strict Hierarchy of k-Valued Languages;Denis Béchet, Alexandre Dikovsky, Annie Foret;The notion of k-valued categorial grammars where a word is associated to at most k types is often used in the field of lexicalized grammars as a fruitful constraint for obtaining several properties like the existence of learning algorithms. This principle is relevant only when the classes of k-valued grammars correspond to a real hierarchy of languages. Such a property had been shown earlier for classical categorial grammars.
CIAA 2011;Bouma2 – A High-Performance Input-Aware Multiple String-Match Algorithm;Erez Buchnik;We present Bouma2, a new algorithm for exact multiple string-match. It is highly parallelizable, has small footprint, and can be tuned using statistics of the input stream. It uses a special hashing technique to map the pattern-set to 2-symbol sequences, allowing the match procedure to be considerably optimized. This algorithm employs a fast-path/slow-path principle at match-time, which facilitates pipelining in H/W. We also produce experimental comparative results.
CIAA 2011;Random Generation of Deterministic Acyclic Automata Using Markov Chains;Vincent Carnino, Sven De Felice;In this article we propose an algorithm, based on Markov chain techniques, to generate random automata that are deterministic, accessible and acyclic. The distribution of the output approaches the uniform distribution on n-state such automata. We then show how to adapt this algorithm in order to generate minimal acyclic automata with n states almost uniformly.
CIAA 2011;Variable and Clause Ordering in an FSA Approach to Propositional Satisfiability;José M. Castaño, Rodrigo Castaño;We use a finite state (FSA) construction approach to address the problem of propositional satisfiability (SAT). We use a very simple translation from formulas in conjunctive normal form (CNF) to regular expressions and use regular expressions to construct an FSA. As a consequence of the FSA construction, we obtain an ALL-SAT solver and model counter. We compare how several variable ordering (state ordering) heuristics affect the running time of the FSA construction. We also present a strategy for clause ordering (automata composition). We compare the running time of state-of-the-art model counters, BDD based sat solvers and we show that this FSA approach obtains state-of-the-art performance on some hard unsatisfiable benchmarks. This work brings up many questions on the possible use of automata to address SAT.
CIAA 2011;Nondeterministic Moore Automata and Brzozowski’s Algorithm;Giusi Castiglione, Antonio Restivo, Marinella Sciortino;Moore automata represent a model that has many applications. In this paper we define a notion of coherent nondeterministic Moore automaton (NMA) and show that such a model has the same computational power of the classical deterministic Moore automaton. We consider also the problem of constructing the minimal deterministic Moore automaton equivalent to a given NMA. In this paper we propose an algorithm that is a variant of Brzozowski’s algorithm in the sense that it is essentially structured as reverse operation and subset construction performed twice.
CIAA 2011;Building Phylogeny with Minimal Absent Words;Supaporn Chairungsee, Maxime Crochemore;An absent word in a sequence is a segment that does not occur in the given sequence. It is a minimal absent word if all its proper factors occur in the given sequence.
CIAA 2011;On the Hardness of Priority Synthesis;Chih-Hong Cheng, Barbara Jobstmann, Christian Buckl, Alois Knoll;We study properties of priority synthesis [2], an automatic method to ensure desired safety properties in component-based systems using priorities. Priorities are a powerful concept to orchestrate components [3], e.g., the BIP framework [1] for designing and modeling embedded and autonomous systems is based on this concept.
CIAA 2011;Smaller Representation of Finite State Automata;Jan Daciuk, Dawid Weiss;This paper is a follow-up to Jan Daciuk’s experiments on space-efficient finite state automata representation that can be used directly for traversals in main memory [4]. We investigate several techniques of reducing the memory footprint of minimal automata, mainly exploiting the fact that transition labels and transition pointer offset values are not evenly distributed and so are suitable for compression. We achieve a size gain of around 20–30% compared to the original representation given in [4]. This result is comparable to the state-of-the-art dictionary compression techniques like the LZ-trie [10] method, but remains memory and CPU efficient during construction.
CIAA 2011;Compositional Failure Detection in Structured Transition Systems;Ingo Felscher, Wolfgang Thomas;In model-checking, systems are often given as products. We propose an approach that is built on a preprocessing of specifications in terms of appropriate automata. This allows to incorporate information about the local behaviour and synchronization of the system components into the specification. We develop a framework of (partially) synchronized automaton products and a format of corresponding specification automata that allows for a compositional failure detection of linear regular properties (either for finite or for infinite behaviour). As a result we obtain an algorithm which separates the local and the non-local segments of system runs, resulting in improved complexity bounds in typical specifications.
CIAA 2011;Chrobak Normal Form Revisited, with Applications;Paweł Gawrychowski;It is well known that any nondeterministic finite automata over a unary alphabet can be represented in a certain normal form called the Chrobak normal form [1]. We present a very simple conversion procedure working in \(\mathcal{O}(n^3)\) time. Then we extend the algorithm to improve two trade-offs concerning conversions between different representations of unary regular languages. Given an n-state NFA, we are able to find a regular expression of size \(\mathcal{O}(\frac{n^2}{\log^2 n})\) describing the same language (which improves the previously known \(\mathcal{O}(n^2)\) size bound [8]) and a context-free grammar in Chomsky normal form with \(\mathcal{O}(\sqrt{n\log n})\) nonterminals (which improves the previously known \(\mathcal{O}(n^{2/3})\) bound [3]).
CIAA 2011;A Cellular Automaton Model for Car Traffic with a Form-One-Lane Rule;Yo-Sub Han, Sang-Ki Ko;We propose a cellular automaton model that simulates a traffic flow with a junction. We include a ‘form-one-lane’ rule that decides which car moves ahead when two cars on two different lanes are in front of a junction. We present a fundamental diagram of the proposed model and car distribution examples. We also demonstrate that the proposed model is useful for predicting the real-world traffic flow with a junction.
CIAA 2011;Loops and Overloops for Tree Walking Automata;Pierre-Cyrille Héam, Vincent Hugot, Olga Kouchnarenko;Tree Walking Automata (TWA) have lately received renewed interest thanks to their tight connection to XML. This paper introduces the notion of tree overloops, which is closely related to tree loops, and investigates the use of both for the following common operations on TWA: testing membership, transformation into a Bottom-Up Tree Automaton (BUTA), and testing emptiness. Notably, we argue that transformation into a BUTA is slightly less straightforward than was assumed, show that using overloops yields much smaller BUTA in the deterministic case, and provide a polynomial over-approximation of this construction which detects emptiness with surprising accuracy against randomly generated TWA.
CIAA 2011;Nondeterministic State Complexity of Star-Free Languages;Markus Holzer, Martin Kutrib, Katja Meckel;We investigate the nondeterministic state complexity of several operations on finite automata accepting star-free languages. It turns out that in most cases exactly the same tight bounds as for general regular languages are reached. This nicely complements the results recently obtained in [8] for the operation problem of star-free languages accepted by deterministic finite automata.
CIAA 2011;On the Containment and Equivalence Problems for GSMs, Transducers, and Linear CFGs;Oscar H. Ibarra;We explore the boundaries between decidability and undecidability of the containment and equivalence problems for restricted classes of nondeterministic generalized sequential machines (NGSMs), nondeterministic finite transducers (NFTs), nondeterministic pushdown transducers (NPDTs), and linear context-free grammars (LCFGs). We believe that our results are the sharpest known to date concerning these devices.
CIAA 2011;Computing All ℓ-Cover Automata Fast;Artur Jeż, Andreas Maletti;Given a language L and a number ℓ, an ℓ-cover automaton for L is a DFA M such that its language coincides with L on all words of length at most ℓ. It is known that an equivalent minimal ℓ-cover automaton can be constructed in time \(\mathcal{O}(n \log n)\), where n is the number of states of M. This is achieved by a clever and sophisticated variant of Hopcroft’s algorithm, which computes the ℓ-similarity inside the main algorithm. This contribution presents an alternative simple algorithm with running time \(\mathcal{O}(n \log n)\), in which the computation is split into three phases. First, a compact representation of the gap table is created. Second, this representation is enriched with information about the length of a shortest word leading to the states. These two steps are independent of the parameter ℓ. Third, the ℓ-similarity is extracted by simple comparisons against ℓ. In particular, this approach allows the calculation of all the sizes of minimal ℓ-cover automata (for all valid ℓ) in the same time bound.
CIAA 2010;Using Automata to Describe Self-Assembled Nanostructures;Nataša Jonoska;There is an increased necessity for mathematical study of self-assembly of various phenomena ranging from nano-scale structures, material design, crystals, biomolecular cages such as viral capsids and for computing. We show an algebraic model for describing and characterizing nanostructures built by a set of molecular building blocks. This algebraic approach connects the classifcal view of crystal dissection with a more modern system based on algebraic automata theory.
CIAA 2010;A Summary of Some Discrete-Event System Control Problems;Karen Rudie;A summary of the area of control of discrete-event systems is given. In this research area, automata and formal language theory is used as a tool to model physical problems that arise in technological and industrial systems. The key ingredients to discrete-event control problems are a process that can be modeled by an automaton, events in that process that cannot be disabled or prevented from occurring, and a controlling agent that manipulates the events that can be disabled to guarantee that the process under control either generates all the strings in some prescribed language or as many strings as possible in some prescribed language. When multiple controlling agents act on a process, decentralized control problems arise. In decentralized discrete-event systems, it is presumed that the agents effecting control cannot each see all event occurrences. Partial observation leads to some problems that cannot be solved in polynomial time and some others that are not even decidable.
CIAA 2010;Large-Scale Training of SVMs with Automata Kernels;Cyril Allauzen, Corinna Cortes, Mehryar Mohri;This paper presents a novel application of automata algorithms to machine learning. It introduces the first optimization solution for support vector machines used with sequence kernels that is purely based on weighted automata and transducer algorithms, without requiring any specific solver. The algorithms presented apply to a family of kernels covering all those commonly used in text and speech processing or computational biology. We show that these algorithms have significantly better computational complexity than previous ones and report the results of large-scale experiments demonstrating a dramatic reduction of the training time, typically by several orders of magnitude.
CIAA 2010;Filters for Efficient Composition of Weighted Finite-State Transducers;Cyril Allauzen, Michael Riley, Johan Schalkwyk;This paper describes a weighted finite-state transducer composition algorithm that generalizes the concept of the composition filter and presents various filters that process epsilon transitions, look-ahead along paths, and push forward labels along epsilon paths. These filters, either individually or in combination, make it possible to compose some transducers much more efficiently in time and space than otherwise possible. We present examples of this drawn, in part, from demanding speech-processing applications. The generalized composition algorithm and many of these filters have been included in OpenFst, an open-source weighted transducer library.
CIAA 2010;Incremental DFA Minimisation;Marco Almeida, Nelma Moreira, Rogério Reis;We present a new incremental algorithm for minimising deterministic finite automata. It runs in quadratic time for any practical application and may be halted at any point, returning a partially minimised automaton. Hence, the algorithm may be applied to a given automaton at the same time as it is processing a string for acceptance. We also include some experimental comparative results.
CIAA 2010;Finite Automata for Generalized Approach to Backward Pattern Matching;Jan Antoš, Bořivoj Melichar;We generalized the DAWG backward pattern matching approach to be able to solve a broad range of pattern matching problems. We use a definition of a class of problems. We describe a finite automaton for the basic pattern matching problem of finding an exact occurrence of one string in a text. We propose a mechanism to use simple operations over finite automata in a systematic approach to derive automata for solving problems from a defined class, such as approximate matching, regular expression matching, sequence matching, matching of set of patterns, etc. and their combinations. The benefit of this approach is the ability to quickly derive solutions for newly formulated pattern matching problems.
CIAA 2010;Partial Derivative Automata Formalized in Coq ;José Bacelar Almeida, Nelma Moreira, David Pereira, Simão Melo de Sousa;In this paper we present a computer assisted proof of the correctness of a partial derivative automata construction from a regular expression within the Coq proof assistant. This proof is part of a formalization of Kleene algebra and regular languages in Coq towards their usage in program certification.
CIAA 2010;Regular Geometrical Languages and Tiling the Plane;Jean-Marc Champarnaud, Jean-Philippe Dubernard, Hadrien Jeanne;We show that if a binary language L is regular, prolongable and geometrical, then it can generate, on certain assumptions, a p1 type tiling of a part of ℕ2. We also show that the sequence of states that appear along a horizontal line in such a tiling only depends on the shape of the tiling sub-figure and is somehow periodic.
CIAA 2010;COMPAS - A Computing Package for Synchronization;Krzysztof Chmiel, Adam Roman;In this paper we describe COMPAS - the open-source computing package, dedicated to the computations on synchronizing automata. COMPAS design is based on a generic programming paradigm. This makes the package very powerful because of its flexibility and extensibility. The paper describes shortly the package architecture and its main algorithms and some examples of use. COMPAS allows to easily operate on synchronizing automata, verifying new synchronizing algorithms etc. To the best of our knowledge, this is the first such flexible, extensible and open-source package for synchronization.
CIAA 2010;From Sequential Extended Regular Expressions to NFA with Symbolic Labels;Alessandro Cimatti, Sergio Mover, Marco Roveri, Stefano Tonetta;Practical property specification languages such as the IEEE standard PSL use at their core Sequential Extended Regular Expressions (SERE). In order to enable the reuse of traditional verification techniques, it is necessary to translate SEREs into automata. SERE are regular expressions built over alphabets resulting from the state variables of the design under analysis. Thus, a traditional approach to generate the automaton would suffer from the fact that the size of the alphabet is exponential in the number of symbols in the design.
CIAA 2010;State Complexity of Catenation Combined with Union and Intersection;Bo Cui, Yuan Gao, Lila Kari, Sheng Yu;In this paper, we study the state complexities of two particular combinations of operations: catenation combined with union and catenation combined with intersection. We show that the state complexity of the former combined operation is considerably less than the mathematical composition of the state complexities of catenation and union, while the state complexity of the latter one is equal to the mathematical composition of the state complexities of catenation and intersection.
CIAA 2010;Complexity Results and the Growths of Hairpin Completions of Regular Languages (Extended Abstract);Volker Diekert, Steffen Kopecki;The hairpin completion is a natural operation on formal languages which has been inspired by molecular phenomena in biology and by DNA-computing. In 2009 we presented in [6] a (polynomial time) decision algorithm to decide regularity of the hairpin completion. In this paper we provide four new results: 1.) We show that the decision problem is NL-complete. 2.) There is a polynomial time decision algorithm which runs in time \(\mathcal{O}(n^{8})\), this improves [6], which provided \(\mathcal{O}(n^{20})\). 3.) For the one-sided case (which is closer to DNA computing) the time is \(\mathcal{O}(n^{2})\), only. 4.) The hairpin completion is unambiguous linear context-free. This result allows to compute the growth (generating function) of the hairpin completion and to compare it with the growth of the underlying regular language.
CIAA 2010;On Straight Words and Minimal Permutators in Finite Transformation Semigroups;Attila Egri-Nagy, Chrystopher L. Nehaniv;Motivated by issues arising in computer science, we investigate the loop-free paths from the identity transformation and corresponding straight words in the Cayley graph of a finite transformation semigroup with a fixed generator set. Of special interest are words that permute a given subset of the state set. Certain such words, called minimal permutators, are shown to comprise a code, and the straight ones comprise a finite code. Thus, words that permute a given subset are uniquely factorizable as products of the subset’s minimal permutators, and these can be further reduced to straight minimal permutators. This leads to insight into structure of local pools of reversibility in transformation semigroups in terms of the set of words permuting a given subset. These findings can be exploited in practical calculations for hierarchical decompositions of finite automata. As an example we consider groups arising in biological systems.
CIAA 2010;On Lazy Representations and Sturmian Graphs;Chiara Epifanio, Christiane Frougny, Alessandra Gabriele, Filippo Mignosi, Jeffrey Shallit;In this paper we establish a strong relationship between the set of lazy representations and the set of paths in a Sturmian graph associated with a real number α. We prove that for any non-negative integer i the unique path weighted i in the Sturmian graph associated with α represents the lazy representation of i in the Ostrowski numeration system associated with α. Moreover, we provide several properties of the representations of the natural integers in this numeration system.
CIAA 2010;Symbolic Dynamics, Flower Automata and Infinite Traces;Wit Foryś, Piotr Oprocha, Slawomir Bakalarski;Considering a finite alphabet as a set of allowed instructions, we can identify finite words with basic actions or programs. Hence infinite paths on a flower automaton can represent order in which these programs are executed and a flower shift related with it represents list of instructions to be executed at some mid-point of the computation.
CIAA 2010;The Cayley-Hamilton Theorem for Noncommutative Semirings;Radu Grosu;The Cayley-Hamilton theorem (CHT) is a classic result in linear algebra over fields which states that a matrix satisfies its own characteristic polynomial. CHT has been extended from fields to commutative semirings by Rutherford in 1964. However, to the best of our knowledge, no result is known for noncommutative semirings. This is a serious limitation, as the class of regular languages, with finite automata as their recognizers, is a noncommutative idempotent semiring. In this paper we extend the CHT to noncommutative semirings. We also provide a simpler version of CHT for noncommutative idempotent semirings.
CIAA 2010;Approximating Minimum Reset Sequences;Michael Gerbush, Brent Heeringa;We consider the problem of finding minimum reset sequences in synchronizing automata. The well-known Černý conjecture states that every n-state synchronizing automaton has a reset sequence with length at most (n − 1)2. While this conjecture gives an upper bound on the length of every reset sequence, it does not directly address the problem of finding the shortest reset sequence. We call this the minimum reset sequence (mrs) problem. We give an O(kmnk + n4/k)-time \(\lceil \frac{n-1}{k-1} \rceil\)-approximation for the mrs problem for any k ≥ 2. We also show that our analysis is tight. When k = 2 our algorithm reduces to Eppstein’s algorithm and yields an (n − 1)-approximation. When k = n our algorithm is the familiar exponential-time, exact algorithm. We define a non-trivial class of mrs which we call stack cover. We show that stack cover naturally generalizes two classic optimization problems: minset cover and shortest common supersequence. Both these problems are known to be hard to approximate, although at present, set cover has a slightly stronger lower bound. In particular, it is NP-hard to approximate set cover to within a factor of c ·logn for some c &gt. 0. Thus, the minimum reset sequence problem is as least as hard to approximate as set cover. This improves the previous best lower bound which showed that it was NP-hard to approximate the mrs on binary alphabets to within any constant factor. Our result requires an alphabet of arbitrary size.
CIAA 2010;Transductions Computed by PC-Systems of Monotone Deterministic Restarting Automata;Norbert Hundeshagen, Friedrich Otto, Marcel Vollweiler;We associate a transduction (that is, a binary relation) with the characteristic language of a restarting automaton, and we prove that in this way monotone deterministic restarting automata yield a characterization of pushdown transductions. Then we study the class of transductions that are computed by parallel communicating systems (PC-systems) of monotone deterministic restarting automata. We will see that this class includes all transductions that are computable.
CIAA 2010;Uniformizing Rational Relations for Natural Language Applications Using Weighted Determinization;J. Howard Johnson;Rational functions have many applications in natural language processing. Specifying them can be difficult since many of the techniques over-generalize and incorrect transformations need to be removed or avoided. Uniformization is the process of restricting a rational relation to make it single-valued while preserving its domain. One way of doing this is to use weighted determinization with an appropriate semiring to produce a subsequential transducer when this is possible. A basic algorithm using the genealogical minimum as the selection process is discussed with a motivating example.
CIAA 2009;Implementation and Application of Automata in String Processing;Gonzalo Navarro;Automata have been enormously successful in matching different types of complex patterns on sequences, with applications in many areas, from text retrieval to bioinformatics, from multimedia databases to signal processing. In general terms, the process to match a complex pattern is (1) design a NFA that recognizes the pattern. (2) slightly modify it to recognize any string ending with the pattern. (3) convert it into a DFA. (4) feed it with the sequence, signaling the endpoints of a pattern occurrence each time the DFA reaches a final state. Alternatively one can omit step (2) and backtrack with the DFA on the suffix tree of the sequence, which leads to sublinear-time complex pattern matching in many relevant cases. This process, as it is well-known, has a potential problem in stage (3), because the DFA can be of exponential size. Rather than being a theoretical reservation, the problem does arise in a number of real-life situations.
CIAA 2009;Applications of Automata in XML Processing;Christoph Koch;XML is at once a document format and a semistructed data model, and has become a de-facto standard for exchanging data on the Internet. XML documents can alternatively be viewed as labeled trees, and tree automata are natural mechanisms for a wide range of processing tasks on XML documents. In this talk, I survey applications of automata in XML processing with an emphasis on those directions of work that so far have had the greatest practical impact. The talk will consist of three parts. In the first, I will discuss XML validation. The standard schema formalisms for XML, Document Type Definitions and XML Schema, are regular tree grammars at their core. These official standards of the World Wide Web Consortium are well-founded in automata theory and formal language theory, and are designed to incorporate special restrictions to facilitate the creation of automata for document validation. The second part will cover XML stream processing techniques and XML publish-subscribe systems, an area in which a number of exciting automata-based systems have been built. The third and final part covers XML query processing using automata, and applications in Web information extraction.
CIAA 2009;Program Analysis through Finite Tree Automata;Helmut Seidl;Dynamic Pushdown Networks (dpn’s) have recently been introduced as a convenient abstraction of systems which provide recursive procedure calls and spawning of concurrent tasks such as Java programs [1, 4-6]. We show how the executions of dpn’s can naturally be represented through ranked trees. The configuration reached by a program execution then can be read off from the sequence of leaves of this execution tree. This observation allows us to reduce decision problems such as reachability of configurations within a regular set for dpn’s to standard decision problems for finite tree automata.
CIAA 2009;An nlogn Algorithm for Hyper-minimizing States in a (Minimized) Deterministic Automaton;Markus Holzer, Andreas Maletti;We improve a recent result [A. Badr: Hyper-Minimization in O(n2). In Proc. CIAA, LNCS 5148, 2008] for hyper-minimized finite automata. Namely, we present an O(nlogn) algorithm that computes for a given finite deterministic automaton (dfa) an almost equivalent dfa that is as small as possible—such an automaton is called hyper-minimal. Here two finite automata are almost equivalent if and only if the symmetric difference of their languages is finite. In other words, two almost-equivalent automata disagree on acceptance on finitely many inputs. In this way, we solve an open problem stated in [A. Badr, V. Geffert, I. Shipman: Hyper-minimizing minimized deterministic finite state automata. RAIRO Theor. Inf. Appl. 43(1), 2009] and by Badr. Moreover, we show that minimization linearly reduces to hyper-minimization, which shows that the time-bound O(n logn) is optimal for hyper-minimization.
CIAA 2009;On Extremal Cases of Hopcroft’s Algorithm;Giusi Castiglione, Antonio Restivo, Marinella Sciortino;In this paper we consider the problem of minimization of deterministic finite automata (DFA) with reference to Hopcroft’s algorithm. Hopcroft’s algorithm has several degrees of freedom, so there can exist different sequences of refinements of the set of the states that lead to the final partition. We find an infinite family of binary automata for which such a process is unique. Some recent papers (cf. [3,7,1]) have been devoted to find families of automata for which Hopcroft’s algorithm has its worst execution time. They are unary automata associated to circular words. However, automata minimization can be achieved also in linear time when the alphabet has only one letter (cf. [14]), so in this paper we face the tightness of the algorithm when the alphabet contains more than one letter. In particular we define an infinite family of binary automata representing the worst case of Hopcroft’s algorithm. They are automata associated to particular trees and we deepen the connection between the refinement process of Hopcroft’s algorithm and the combinatorial properties of such trees.
CIAA 2009;Compact Normal Form for Regular Languages as Xor Automata;Jean Vuillemin, Nicolas Gama;The only presently known normal form for a regular language \({\mathcal{L}}\in{\mathcal{R}\mathrm{eg}}\) is its Minimal Deterministic Automaton \({\mathrm{MDA}}({\mathcal{L}})\). We show that a regular language is also characterized by a finite dimension \(\dim({\mathcal{L}})\), which is always smaller than the number \(|{\mathrm{MDA}}({\mathcal{L}})|\) of states, and often exponentially so. The dimension is also the minimal number of states of all Nondeterministic Xor Automaton (NXA) which accept the language. NXAs combine the advantages of deterministic automata (normal form, negation, minimization, equivalence of states, accessibility) and of nondeterministic ones (compactness, mirror language). We present an algorithmic construction of the Minimal Non Deterministic Xor Automaton \({\mathrm{MXA}}(\mathcal{L})\), in cubic time from any NXA for \({\mathcal{L}}\in{\mathcal{R}\mathrm{eg}}\). The MXA provides another normal form: \({\mathcal{L}}=\mathcal{L}^{\prime}\Leftrightarrow{\mathrm{MXA}}({\mathcal{L}})={\mathrm{MXA}}(\mathcal{L}^{\prime})\). Our algorithm establishes a missing connection between Brzozowski’s mirror-based minimization method for deterministic automata, and algorithms based on state-equivalence.
CIAA 2009;Cellular Automata with Sparse Communication;Martin Kutrib, Andreas Malcher;We investigate cellular automata whose internal inter-cell communication is bounded. The communication is quantitatively measured by the number of uses of the links between cells. It is shown that even the weakest non-trivial device in question, that is, one-way cellular automata where each two neighboring cells may communicate constantly often only, accept rather complicated languages. We investigate the computational capacity of the devices in question and prove an infinite strict hierarchy depending on the bound on the total number of communications during a computation. Despite their sparse communication even for the weakest devices, by reduction of Hilbert’s tenth problem undecidability of several problems is derived. Finally, the question whether a given real-time one-way cellular automaton belongs to the weakest class is shown to be undecidable. This result can be adapted to answer an open question posed in [16].
CIAA 2009;A Cellular Automaton Model for Car Traffic with a Slow-to-Stop Rule;Adam Clarridge, Kai Salomaa;We propose a modification of the widely known Benjamin-Johnson-Hui (BJH) cellular automaton model for single-lane traffic simulation. In particular, our model includes a ‘slow-to-stop’ rule that exhibits more realistic microscopic driver behaviour than the BJH model. We present some statistics related to fuel economy and pollution generation and show that our model differs greatly in these measures. We give concise results based on extensive simulations using our system.
CIAA 2009;On Parallel Implementations of Deterministic Finite Automata;Jan Holub, Stanislav Štekr;We present implementations of parallel DFA run methods and find whether and under what conditions is worthy to use the parallel methods of simulation of run of finite automata.
CIAA 2009;FAdo and GUItar: Tools for Automata Manipulation and Visualization;André Almeida, Marco Almeida, José Alves, Nelma Moreira, Rogério Reis;FAdo is an ongoing project which aims to provide a set of tools for symbolic manipulation of formal languages. To allow high-level programming with complex data structures, easy prototyping of algorithms, and portability (to use in computer grid systems for example), are its main features. Our main motivation is the theoretical and experimental research, but we have also in mind the construction of a pedagogical tool for teaching automata theory and formal languages. For the graphical visualization and interactive manipulation a new interface application, GUItar, is being developed. In this paper, we describe the main components of the FAdo system as well as the basics of the graphical interface and editor, the export/import filters and its generic interface with external systems, such as FAdo .
CIAA 2009;A Testing Framework for Finite-State Morphology;François Barthélemy;This paper describes a unit testing framework for the languages which rely on rational relations to describe Natural Language Morphology. A test is divided into two parts: firstly compute a finite-state machine. secondly inspect this machine to compute its cardinality. The first part involves the finite-state machines to be tested and finite-state machines encoding the inputs of the test. A dependency relation is used to relate tests and the components of the description.
CIAA 2009;A Table Compression Method for Extended Aho-Corasick Automaton;Yanbing Liu, Yifu Yang, Ping Liu, Jianlong Tan;The Aho-Corasick algorithm is a classic method for matching a set of strings. However, the huge memory usage of Aho-Corasick automaton prevents it from being applied to large-scale pattern sets. Here we present a simple but efficient table compression method to reduce the automaton’s space. The basic idea of our method is based on equivalent rows elimination, which groups state rows into equivalent classes and eliminates the duplicates. Experiments demonstrate that the proposed method significantly reduces the memory usage and still runs at linear searching time comparable to that of extended Aho-Corasick algorithm. Our method provides good trade-off between memory usage and searching time.
CIAA 2009;Compact Representation for Answer Sets of n-ary Regular Queries;Kazuhiro Inaba, Haruo Hosoya;An n-ary query over trees takes an input tree t and returns a set of n-tuples of the nodes of t. In this paper, a compact data structure is introduced for representing the answer sets of n-ary queries defined by tree automata. Despite that the number of the elements of the answer set can be as large as |t|n, our representation allows to store the set using only O(3n |t|) space. Several basic operations on the sets are shown to be efficiently executable on the representation.
CIAA 2009;Recognition of a Spanning Tree of Directed Acyclic Graphs by Tree Automata;Akio Fujiyoshi;In this paper, we study tree automata for directed acyclic graphs (DAGs). We define the movement of a tree automaton on a DAG so that a DAG is accepted by a tree automaton if and only if a DAG has a spanning tree accepted by a tree automaton. The NP-completeness of the membership problem of DAGs for a tree automaton is shown, and a linear-time recognition algorithm of series-parallel graphs for a tree automaton is presented.
CIAA 2009;Random Generation of Deterministic Tree (Walking) Automata;Pierre-Cyrille Héam, Cyril Nicaud, Sylvain Schmitz;Uniform random generators deliver a simple empirical means to estimate the average complexity of an algorithm. We present a general rejection algorithm that generates sequential letter-to-letter transducers up to isomorphism. We tailor this general scheme to randomly generate deterministic tree walking automata and deterministic top-down tree automata. We apply our implementation of the generator to the estimation of the average complexity of a deterministic tree walking automata to nondeterministic top-down tree automata construction we also implemented.
CIAA 2009;Hedge Pattern Partial Derivative;Taro Suzuki, Satoshi Okui;We propose hedge pattern partial derivatives, an extension of Antimirov’s partial derivatives, in order to give an operational semantics of pattern matching of regular hedge expression patterns, which is crucial in XML processing. We show that correct and small matching automata can be constructed from hedge pattern partial derivatives.
CIAA 2009;TAGED Approximations for Temporal Properties Model-Checking;Roméo Courbis, Pierre-Cyrille Héam, Olga Kouchnarenko;This paper investigates the use of tree automata with global equalities and disequalities (TAGED for short) in reachability analysis over term rewriting systems (TRSs). The reachability problem being in general undecidable on non terminating TRSs, we provide TAGED-based construction, and then design approximation-based semi-decision procedures to model-check useful temporal patterns on infinite state rewriting graphs. To show that the above TAGED-based construction can be effectively carried out, complexity analysis for rewriting TAGED-definable languages is given.
CIAA 2009;Verifying Parallel Programs with Dynamic Communication Structures;Mohamed Faouzi Atig, Tayssir Touili;We address the verification problem of networks of communicating pushdown systems modeling communicating parallel programs with procedure calls. Processes in such networks can read the control state of the other processes according to a given communication structure (specifying the observability rights between processes). The reachability problem of such models is undecidable in general. First, we define a class of networks that effectively preserves recognizability (hence, its reachability problem is decidable). Then, we consider networks where the communication structure can change dynamically during the execution according to a phase graph. The reachability problem for these dynamic networks being undecidable in general, we define a subclass for which it becomes decidable. Then, we consider reachability when the switches in the communication structures are bounded. We show that this problem is undecidable even for one switch. Then, we define a natural class of models for which this problem is decidable. This class can be used in the definition of an efficient semi-decision procedure for the analysis of the general model of dynamic networks. Our techniques allowed to find bugs in two versions of a Windows NT Bluetooth driver.
CIAA 2009;Fixpoint Guided Abstraction Refinement for Alternating Automata;Pierre Ganty, Nicolas Maquet, Jean-François Raskin;In this paper, we develop and evaluate two new algorithms for checking emptiness of alternating automata. These algorithms build on previous works. First, they rely on antichains to efficiently manipulate the state-spaces underlying the analysis of alternating automata. Second, they are abstract algorithms with built-in refinement operators based on techniques that exploit information computed by abstract fixed points (and not counter-examples as it is usually the case). The efficiency of our new algorithms is illustrated by experimental results.
CIAA 2008;Nondeterministic Finite Automata—Recent Results on the Descriptional and Computational Complexity;Markus Holzer, Martin Kutrib;Nondeterministic finite automata (NFAs) were introduced in [67], where their equivalence to deterministic finite automata was shown. Over the last 50 years, a vast literature documenting the importance of finite automata as an enormously valuable concept has been developed. In the present paper, we tour a fragment of this literature. Mostly, we discuss recent developments relevant to NFAs related problems like, for example, (i) simulation of and by several types of finite automata, (ii) minimization and approximation, (iii) size estimation of minimal NFAs, and (iv) state complexity of language operations. We thus come across descriptional and computational complexity issues of nondeterministic finite automata. We do not prove these results but we merely draw attention to the big picture and some of the main ideas involved.
CIAA 2008;Language Decompositions, Primality, and Trajectory-Based Operations;Kai Salomaa;We consider the decomposability of languages and the notion of primality with respect to catenation, as well as, more general operations. We survey recent results and discuss open problems.
CIAA 2008;Automata, Probability, and Recursion;Mihalis Yannakakis;We discuss work on the modeling and analysis of systems with probabilistic and recursive features. Recursive Markov chains extend ordinary finite state Markov chains with the ability to invoke other Markov chains in a potentially recursive manner. The equivalent model of Probabilistic Pushdown Automata extends ordinary pushdown automata with probabilistic actions. Both of these are natural abstract models for probabilistic programs with procedures, and related systems. They generalize other classical well-studied stochastic models, e.g. Stochastic Context-free Grammars and (Multi-type) Branching Processes, that arise in a variety of areas. More generally, Recursive Markov Decision Processes and Recursive Stochastic Games can be used to model recursive systems that have both probabilistic and nonprobabilistic, controllable actions. In recent years there has been substantial work on the algorithmic analysis of these models, regarding basic questions of termination, reachability, and analysis of the properties of their executions. In this talk we will present some of the basic theory, algorithmic methods, results, and challenges.
CIAA 2008;Concurrency, Synchronization, and Conflicts in Petri Nets;Hsu-Chun Yen;Petri nets represent one of the most popular formalisms for specifying, modeling, and analyzing concurrent systems. In spite of their popularity, many interesting problems concerning Petri nets are either undecidable or of very high complexity. Lipton [7] and Rackoff [10] showed exponential space lower and upper bounds, respectively, for the boundedness problem. As for the containment and the equivalence problems, Rabin [1] and Hack [5], respectively, showed these two problems to be undecidable. The reachability problem is known to be decidable [8] and exponential-space-hard [7].
CIAA 2008;Automated Compositional Reasoning of Intuitionistically Closed Regular Properties;Yih-Kuen Tsay, Bow-Yaw Wang;Analysis of infinitary safety properties with automated compositional reasoning through learning is discussed. We consider the class of intuitionistically closed regular languages and show that it forms a Heyting algebra and is finitely approximatable. Consequently, compositional proof rules can be verified automatically and learning algorithms for finitary regular languages suffice for generating the needed contextual assumptions. We also provide a semantic justification of an axiom to deduce circular compositional proof rules for such infinitary languages.
CIAA 2008;Antimirov and Mosses’s Rewrite System Revisited;Marco Almeida, Nelma Moreira, Rogério Reis;Antimirov and Mosses proposed a rewrite system for deciding the equivalence of two (extended) regular expressions. In this paper we present a functional approach to that method, prove its correctness, and give some experimental comparative results. Besides an improved version of Antimirov and Mosses’s algorithm, we present a version using partial derivatives. Our preliminary results lead to the conclusion that, indeed, these methods are feasible and, generally, faster than the classical methods.
CIAA 2008;Antichain-Based Universality and Inclusion Testing over Nondeterministic Finite Tree Automata;Ahmed Bouajjani, Peter Habermehl, Lukáš Holík, Tayssir Touili, Tomáš Vojnar;We propose new antichain-based algorithms for checking universality and inclusion of nondeterministic tree automata (NTA). We have implemented these algorithms in a prototype tool and our experiments show that they provide a significant improvement over the traditional determinisation-based approaches. We use our antichain-based inclusion checking algorithm to build an abstract regular tree model checking framework based entirely on NTA. We show the significantly improved efficiency of this framework through a series of experiments with verifying various programs over dynamic linked tree-shaped data structures.
CIAA 2008;Testing Whether a Binary and Prolongeable Regular Language L Is Geometrical or Not on the Minimal Deterministic Automaton of Pref(L);J. -M. Champarnaud, J. -Ph. Dubernard, H. Jeanne;Our aim is to present an efficient algorithm that checks whether a binary and prolongeable regular language is geometrical or not, based on specific properties of its minimal deterministic automaton. Geometrical languages have been introduced in the framework of off-line temporal validation of real-time softwares. Actually, validation can be achieved through both a model based on regular languages and a model based on discrete geometry. Geometrical languages are intended to develop a link between these two models. The regular case is of practical interest regarding to implementation features, which motivates the design of an efficient geometricity test addressing the family of regular languages.
CIAA 2008;Hopcroft’s Minimization Technique: Queues or Stacks?;Andrei Păun, Mihaela Păun, Alfonso Rodríguez-Patón;We consider the absolute worst case time complexity for Hopcroft’s minimization algorithm applied to unary languages (or a modification of this algorithm for cover automata minimization). We show that in this setting the worst case is reached only for deterministic automata or cover automata following the structure of the de Bruijn words. We refine a previous result by showing that the Berstel/Carton example reported before is actually the absolute worst case time complexity in the case of unary languages for deterministic automata. We show that the same result is valid also when considering the setting of cover automata and an algorithm based on the Hopcroft’s method used for minimization of cover automata. We also show that a LIFO implementation for the splitting list is desirable for the case of unary languages in the setting of deterministic finite automata.
CIAA 2008;Learning Regular Languages Using Nondeterministic Finite Automata;Pedro García, Manuel Vázquez de Parga, Gloria I. Álvarez, José Ruiz;A new general method for inference of regular languages using nondeterministic automata as output has recently been developed and proved to converge. The aim of this paper is to describe and analyze the behavior of two implementations of that method and to compare it with two well known algorithms for the same task. A complete set of experiments has been carried out and the results of the new algorithms improve the existing ones both in recognition rates as in sizes of the output automata.
CIAA 2008;Multi-Return Macro Tree Transducers;Kazuhiro Inaba, Haruo Hosoya, Sebastian Maneth;An extension of macro tree transducers is introduced with the capability of states to return multiple trees at the same time. Under call-by-value semantics, the new model is strictly more expressive than call-by-value macro tree transducers, and moreover, it has better closure properties under composition.
CIAA 2008;Computing Convex Hulls by Automata Iteration;François Cantin, Axel Legay, Pierre Wolper;This paper considers the problem of computing the real convex hull of a finite set of n-dimensional integer vectors. The starting point is a finite-automaton representation of the initial set of vectors. The proposed method consists in computing a sequence of automata representing approximations of the convex hull and using extrapolation techniques to compute the limit of this sequence. The convex hull can then be directly computed from this limit in the form of an automaton-based representation of the corresponding set of real vectors. The technique is quite general and has been implemented. Also, our result fits in a wider scheme whose objective is to improve the techniques for converting automata-based representation of constraints to formulas.
CIAA 2008;A Translation from the HTML DTD into a Regular Hedge Grammar;Takuya Nishiyama, Yasuhiko Minamide;The PHP string analyzer developed by the second author approximates the string output of a program with a context-free grammar. By developing a procedure to decide inclusion between context-free and regular hedge languages, Minamide and Tozawa applied this analysis to checking the validity of dynamically generated XHTML documents. In this paper, we consider the problem of checking the validity of dynamically generated HTML documents instead of XHTML documents.
CIAA 2008;Tree-Series-to-Tree-Series Transformations;Andreas Maletti;We investigate the tree-series-to-tree-series (ts-ts) transformation computed by tree series transducers. Unless the used semiring is complete, this transformation is, in general, not well-defined. In practice, many used semirings are not complete (like the probability semiring). We establish a syntactical condition that guarantees well-definedness of the ts-ts transformation in arbitrary commutative semirings. For positive (ie, zero-sum and zero-divisor free) semirings the condition actually characterizes the well-definedness, so that well-definedness is decidable in this scenario.
CIAA 2008;Automata-Theoretic Analysis of Bit-Split Languages for Packet Scanning;Ryan Dixon, Ömer Eğecioğlu, Timothy Sherwood;Bit-splitting breaks the problem of monitoring traffic payloads to detect the occurrence of suspicious patterns into several parallel components, each of which searches for a particular bit pattern. We analyze bit-splitting as applied to Aho-Corasick style string matching. The problem can be viewed as the recovery of a special class of regular languages over product alphabets from a collection of homomorphic images. We use this characterization to prove correctness and to give space bounds. In particular we show that the NFA to DFA conversion of the Aho-Corasick type machine used for bit-splitting incurs only linear overhead.
CIAA 2008;Pattern Matching in DCA Coded Text;Jan Lahoda, Bořivoj Melichar, Jan Žd’árek;A new algorithm searching all occurrences of a regular expression pattern in a text is presented. It uses only the text that has been compressed by the text compression using antidictionaries without its decompression. The proposed algorithm runs in \({\mathcal O}(2^m\cdot||{\rm AD}||^2+n_c+r)\) worst case time, where m is the length of the pattern, AD is the antidictionary, nC is the length of the coded text and r is the number of found matches.
CIAA 2008;Five Determinisation Algorithms;Rob van Glabbeek, Bas Ploeger;Determinisation of nondeterministic finite automata is a well-studied problem that plays an important role in compiler theory and system verification. In the latter field, one often encounters automata consisting of millions or even billions of states. On such input, the memory usage of analysis tools becomes the major bottleneck. In this paper we present several determinisation algorithms, all variants of the well-known subset construction, that aim to reduce memory usage and produce smaller output automata. One of them produces automata that are already minimal. We apply our algorithms to determinise automata that describe the possible sequences appearing after a fixed-length run of cellular automaton 110, and obtain a significant improvement in both memory and time efficiency.
CIAA 2008;Persistent Computations of Turing Machines;Harald Hempel, Madlen Kimmritz;In this paper we formally define the notion of persistent Turing machines to model interactive computations. We compare the power of persistent computations with their classical counterparts.
CIAA 2008;On Complexity of Two Dimensional Languages Generated by Transducers;Egor Dolzhenko, Nataša Jonoska;We consider two-dimensional languages, called here 2d transducer languages, generated by iterative applications of transducers (finite state automata with output). To each transducer a two-dimensional language consisting of blocks of symbols is associated: the bottom row of a block is an input string accepted by the transducer and, by iterative application of the transducer, each row of the block is an output of the transducer on the preceding row. We observe that this class of languages is a proper subclass of recognizable picture languages containing the class of all factorial local 2d languages. By taking the average growth rate of the number of blocks in the language as a measure of its complexity, also known as the entropy of the language, we show that every entropy value of a one-dimensional regular language can be obtained as an entropy value of a 2d transducer language.
CIAA 2007;Spiking Neural P Systems Used as Acceptors and Transducers;Gheorghe Păun;The study of spiking neural P systems is a branch of membrane computing (comprehensive information about this area of natural computing can be found in [24], [9], or at the web page [31]) initiated in [18]. The goal is to build a model of the way the neurons cooperate in (large) neural nets, communicating by means of spikes, electrical impulses of identical shapes. “Computing by spiking” is a vivid research area in neural computing, which promises to lead to a neural computing “of the third generation” - see [12], [22], etc.
CIAA 2007;Linear-Time Model Checking: Automata Theory in Practice;Moshe Y. Vardi;In automata-theoretic model checking we compose the design under verification with a Büchi automaton that accepts traces violating the specification. We then use graph algorithms to search for a counterexample trace. The basic theory of this approach was worked out in the 1980s, and the basic algorithms were developed during the 1990s. Both explicit and symbolic implementations, such as SPIN and and SMV, are widely used. It turns out, however, that there are still many gaps in our understanding of the algorithmic issues involved in automata-theoretic model checking. This paper covers the fundamentals of automata-theoretic model checking. The conference talk also reviews the reduction of the theory to practice and outlines areas that require further research.
CIAA 2007;OpenFst: A General and Efficient Weighted Finite-State Transducer Library;Cyril Allauzen, Michael Riley, Johan Schalkwyk, Wojciech Skut, Mehryar Mohri;We describe OpenFst, an open-source library for weighted finite-state transducers (WFSTs). OpenFst consists of a C++ template library with efficient WFST representations and over twenty-five operations for constructing, combining, optimizing, and searching them. At the shell-command level, there are corresponding transducer file representations and programs that operate on them. OpenFst is designed to be both very efficient in time and space and to scale to very large problems.
CIAA 2007;Automata Applications in Chip-Design Software;Bruce W. Watson;In this paper, I present several new automata applications in software for electronic design automation (EDA) — chip design. EDA software has typically been implemented by and for microelectronic engineers, and the associated algorithmics remains underdeveloped. In several cases, overly complex algorithms have been used whereas automata could have been applied after abstracting from the problem details.
CIAA 2007;Synchronizing Automata Preserving a Chain of Partial Orders;Mikhail V. Volkov;We present a new class of automata which strictly contains the class of aperiodic automata and shares with the latter certain synchronization properties. In particular, every strongly connected automaton in this new class is synchronizing and has a reset word of length \(\left\lfloor\frac{n(n+1)}6\right\rfloor\) where n is the number of states of the automaton.
CIAA 2007;Reducing Acyclic Cover Transducers;Jean-Marc Champarnaud, Franck Guingne, Jacques Farré;Finite languages and finite subsequential functions can be represented by possibly cyclic finite machines, respectively called cover automata and cover transducers. In general, reduced cover machines have much fewer states than the corresponding minimal machines, yielding a compact representation for lexicons or dictionaries. We present here a new algorithm for reducing the number of states of an acyclic transducer.
CIAA 2007;On-the-Fly Stuttering in the Construction of Deterministic ω-Automata;Joachim Klein, Christel Baier;We propose to use the knowledge that an ω-regular property is stutter insensitive to construct potentially smaller deterministic ω-automata for such a property, e.g. using Safra’s determinization construction. This knowledge allows us to skip states that are redundant under stuttering, which can reduce the size of the generated automaton. In order to use this technique even for automata that are not completely insensitive to stuttering, we introduce the notion of partial stutter insensitiveness and apply our construction only on the subset of symbols for which stuttering is allowed. We evaluate the benefits of this heuristic in practice using multiple sets of benchmark formulas.
CIAA 2007;Average Value and Variance of Pattern Statistics in Rational Models;Massimiliano Goldwurm, Roberto Radicioni;We study the pattern statistics representing the number of occurrences of a given string in a word of length n generated at random by rational stochastic models, defined by means of weighted finite automata. We get asymptotic estimations for the mean value and the variance of these statistics under the hypothesis that the matrix of all transition weights is primitive. Our results extend previous evaluations obtained by assuming ergodic stationary Markovian sources and they yield a general framework to determine analogous estimations under several stochastic models. In particular they show the role of the stationarity hypothesis in such models.
CIAA 2007;Weighted Automata and Weighted Logics with Discounting;Manfred Droste, George Rahonis;We introduce a weighted logic with discounting and we establish Büchi’s and Elgot’s theorem for weighted automata over finite words and arbitrary commutative semirings. Then we investigate Büchi and Muller automata with discounting over the max-plus and the min-plus semiring. We show their expressive equivalence with weighted MSO-sentences with discounting. In this case our logic has a purely syntactic definition. For the finite case, we obtain a purely syntactically defined weighted logic if the underlying semiring is additively locally finite.
CIAA 2007;Regulated Nondeterminism in Pushdown Automata;Martin Kutrib, Andreas Malcher, Larissa Werlein;A generalization of pushdown automata towards regulated nondeterminism is studied. The nondeterminism is governed in such a way that the decision, whether or not a nondeterministic rule is applied, depends on the whole content of the stack. More precisely, the content of the stack is considered as a word over the stack alphabet, and the pushdown automaton is allowed to act nondeterministically, if this word belongs to some given set R of control words. Otherwise its behavior is deterministic. The computational capacity of such R -PDAs depends on the complexity of R. It turns out that non-context-free languages are accepted even if R is a linear, deterministic context-free language. On the other hand, regular control sets R do not increase the computational capacity of nondeterministic pushdown automata. This raises the natural question for the relations between the structure and complexity of regular sets R on one hand and the computational capacity of the corresponding R -PDA on the other hand. Clearly, if R is empty, the deterministic context-free languages are characterized. For R = {a,b}* one obtains all context-free languages. Furthermore, if R is finite, then the regular closure of the deterministic context-free languages is described. We investigate these questions, and discuss closure properties of the language classes in question under AFL operations.
CIAA 2007;Deterministic Caterpillar Expressions;Kai Salomaa, Sheng Yu, Jinfeng Zan;Caterpillar expressions have been introduced by Brüggemann-Klein and Wood for applications in markup languages. A caterpillar expression can be implemented as a tree walking automaton operating on unranked trees. Here we give a formal definition of determinism of caterpillar expressions that is based on the language of instruction sequences defined by the expression. We show that determinism of caterpillar expressions can be decided in polynomial time.
CIAA 2007;Backward and Forward Bisimulation Minimisation of Tree Automata;Johanna Högberg, Andreas Maletti, Jonathan May;We improve an existing bisimulation minimisation algorithm for tree automata by introducing backward and forward bisimulations and developing minimisation algorithms for them. Minimisation via forward bisimulation is also effective for deterministic automata and faster than the previous algorithm. Minimisation via backward bisimulation generalises the previous algorithm and is thus more effective but just as fast. We demonstrate implementations of these algorithms on a typical task in natural language processing.
CIAA 2007;An Implementation of Deterministic Tree Automata Minimization;Rafael C. Carrasco, Jan Daciuk, Mikel L. Forcada;A frontier-to-root deterministic finite-state tree automaton (DTA) can be used as a compact data structure to store collections of unranked ordered trees. DTAs are usually sparser than string automata, as most transitions are undefined and therefore, special care must be taken in order to minimize them efficiently. However, it is difficult to find simple and detailed descriptions of the minimization procedure in the published literature. Here, we fully describe a simple implementation of the standard minimization algorithm that needs a time in \(\mathcal{O}(|A|^2)\), with |A| being the size of the DTA.
CIAA 2007;Accelerating Boyer Moore Searches on Binary Texts;Shmuel T. Klein, Miri Kopel Ben-Nissan;The Boyer and Moore (BM) pattern matching algorithm is considered as one of the best, but its performance is reduced on binary data. Yet, searching in binary texts has important applications, such as compressed matching. The paper shows how, by means of some pre-computed tables, one may implement the BM algorithm also for the binary case without referring to bits, and processing only entire blocks such as bytes or words, thereby significantly reducing the number of comparisons. Empirical comparisons show that the new variant performs better than regular binary BM and even than BDM.
CIAA 2007;On the Suffix Automaton with Mismatches;Maxime Crochemore, Chiara Epifanio, Alessandra Gabriele, Filippo Mignosi;In this paper we focus on the construction of the minimal deterministic finite automaton Sk that recognizes the set of suffixes of a word w up to k errors. We present an algorithm that makes use of Sk in order to accept in an efficient way the language of all suffixes of w up to k errors in every window of size r, where r is the value of the repetition index of w. Moreover, we give some experimental results on some well-known words, like prefixes of Fibonacci and Thue-Morse words, and we make a conjecture on the size of the suffix automaton with mismatches.
CIAA 2007;On String Matching in Chunked Texts;Hannu Peltola, Jorma Tarhio;We study exact string matching in special texts, which consist of consecutive fixed-length chunks where each position of a chunk has a character distribution of its own. This kind of setting can also be interpreted so that a chunk represents a character of a larger alphabet. If texts and patterns are of this kind, it may ruin the efficiency of common algorithms. We examine anomalies related to the Horspool and Sunday algorithms in this setting. In addition we present two new algorithms.
CIAA 2007;Factor Automata of Automata and Applications;Mehryar Mohri, Pedro Moreno, Eugene Weinstein;An efficient data structure for representing the full index of a set of strings is the factor automaton, the minimal deterministic automaton representing the set of all factors or substrings of these strings. This paper presents a novel analysis of the size of the factor automaton of an automaton, that is the minimal deterministic automaton accepting the set of factors of a finite set of strings, itself represented by a finite automaton. It shows that the factor automaton of a set of strings U has at most 2|Q| − 2 states, where Q is the number of nodes of a prefix-tree representing the strings in U, a bound that significantly improves over 2 ||U||− 1, the bound given by Blumer et al. (1987), where ||U|| is the sum of the lengths of all strings in U. It also gives novel and general bounds for the size of the factor automaton of an automaton as a function of the size of the original automaton and the maximal length of a suffix shared by the strings it accepts. Our analysis suggests that the use of factor automata of automata can be practical for large-scale applications, a fact that is further supported by the results of our experiments applying factor automata to a music identification task with more than 15,000 songs.
CIAA 2007;Subset Seed Automaton;Gregory Kucherov, Laurent Noé, Mikhail Roytberg;We study the pattern matching automaton introduced in [1] for the purpose of seed-based similarity search. We show that our definition provides a compact automaton, much smaller than the one obtained by applying the Aho-Corasick construction. We study properties of this automaton and present an efficient implementation of the automaton construction. We also present some experimental results and show that this automaton can be successfully applied to more general situations.
CIAA 2007;A Measure for the Degree of Nondeterminism of Context-Free Languages;František Mráz, Martin Plátek, Friedrich Otto;Restarting automata can be seen as analytical variants of classical automata as well as of regulated rewriting systems. We study some measures for the degree of nondeterminism of (context-free) languages in terms of lexicalized deterministic restarting automata. These measures are based on the number of auxiliary symbols (categories) used for recognizing a language as the projection of its characteristic language onto its input alphabet. This type of recognition is typical for analysis by reduction, a method used in linguistics for the creation and verification of formal descriptions of natural languages. Our main results establish a two-dimensional hierarchy of classes of (context-free) languages based on the expansion factor of a language and on the number of different auxiliary symbols available in the underlying characteristic language.
CIAA 2006;Information Distance and Its Applications;Ming Li;We summarize the recent developments of a general theory of information distance and its applications in whole genome phylogeny, document comparison, internet query-answer systems, and many other data mining tasks. We also solve an open problem regarding the universality of the normalized information distance.
CIAA 2006;Theory Inspired by Gene Assembly in Ciliates;Grzegorz Rozenberg;Ciliates (ciliated protozoa) are unicellular organisms with an evolutionary history that extends back perhaps two billion (2 x 109) years. The unique extraordinary feature of ciliates is that they posses two kinds of nuclei within the same cell: macronucleus containing genes that provide the genetic information needed to maintain the structure and function of the cell, and micronucleus that does not contribute to the maintainance, growth and proliferation of the cell – it is reserved for the sexual exchange of DNA between two mating cells.
CIAA 2006;On the State Complexity of Combined Operations;Sheng Yu;The state complexity of combined operations is studied. We show that the state complexity of a combined operation can be very different from the composition of the state complexities of the participating individual operations. However, the estimate through individual nondeterministic state complexities for each of the combined operations being considered is very similar to the actual state complexity. Several open problems related to state complexity are also proposed.
CIAA 2006;Path-Equivalent Removals of ε-transitions in a Genomic Weighted Finite Automaton;Mathieu Giraud, Philippe Veber, Dominique Lavenier;Weighted finite automata (WFA) are used with accelerating hardware to scan large genomic banks. Hardwiring such automata raise surface area and clock frequency constraints, requiring efficient ε-transitions-removal techniques. In this paper, we present new bounds on the number of new transitions for several ε-transitions-removal problems. We study the case of acyclic WFA. We introduce a new problem, the partial removal of ε-transitions while accepting short chains of ε-transitions.
CIAA 2006;Hybrid Extended Finite Automata;Henning Bordihn, Markus Holzer, Martin Kutrib;Extended finite automata are finite state automata equipped with the additional ability to apply an operation on the currently remaining input word, depending on the current state. Hybrid extended finite automata can choose from a finite set of such operations. In this paper, five word operations are taken into consideration which always yield letter-equivalent results, namely reversal and shift operations. The computational power of those machines is investigated, locating the corresponding families of languages in the Chomsky hierarchy. Furthermore, different types of hybrid extended finite automata, defined by the set of operations they are allowed to apply, are compared with each other, demonstrating that there exist dependencies and independencies between the input manipulating operations.
CIAA 2006;Refinement of Near Random Access Video Coding with Weighted Finite Automata;German Tischler;Random access video compression is mostly implemented without any reduction of temporal redundancy. Standard video compression systems like MPEG (1,2 and 4) are heavily based on motion compensation, which to some extent makes random access at single frame level impossible. We present a method for near random access video compression of low-motion video that is based on the discrete cosine transform and vector quantization and refine this system using weighted finite automata while keeping the random access property and using some reduction of temporal redundancy.
CIAA 2006;Borders and Finite Automata;Martin Šimůnek, Bořivoj Melichar;A border of a string is a prefix of the string that is simultaneously its suffix. It is one of the basic stringology keystones used as a part of many algorithms in pattern matching, molecular biology, computer-assisted music analysis and others. The paper discusses automata-theoretical background of Iliopoulos’s ALL_BORDERS algorithm that finds all borders of a string with don’t care symbols. We show that ALL_BORDERS algorithm is a simulator of a finite automaton together with explaining the function of the automaton. We show that the simulated automaton accepts intersection of sets of prefixes and suffixes (and thus a set of borders) of the input string. Last but not least we define approximate borders. Based on the knowledge of the automata background of ALL_BORDERS algorithm we offer an automata-based algorithm that finds approximate borders with Hamming distance. We discuss conditions under which the same principle can be used for other distance measures for which an approximate searching automaton can be constructed.
CIAA 2006;Finding Common Motifs with Gaps Using Finite Automata;Pavlos Antoniou, Jan Holub, Costas S. Iliopoulos, Bořivoj Melichar, Pierre Peterlongo;We present an algorithm that uses finite automata to find the common motifs with gaps occurring in all strings belonging to a finite set S = {S1,S2,...,Sr}. In order to find these common motifs we must first identify the factors that exist in each string. Therefore the algorithm begins by constructing a factor automaton for each string Si. To find the common factors of all the strings, the algorithm needs to gather all the factors from the strings together in one data structure and this is achieved by computing an automaton that accepts the union of the above-mentioned automata. Using this automaton we are able to create a new factor alphabet. Based on this factor alphabet a finite automaton is created for each string Si that accepts sequences of all non overlapping factors residing in each string. The intersection of the latter automata produces the finite automaton which accepts all the common subsequences with gaps over the factor alphabet that are present in all the strings of the set S = {S1,S2,...,Sr}. These common subsequences are the common motifs of the strings.
CIAA 2006;Factor Oracles;Maxime Crochemore, Lucian Ilie, Emine Seid-Hilmi;The factor oracle is a relatively new data structure for the set of factors of a string which has been introduced by Allauzen, Crochemore, and Raffinot in 1999. It may recognize non-factors (hence the name “oracle”) but its implementational simplicity and experimental behaviour are stunning. factor oracle based string matching has been conjectured optimal on average. However, its structure is not well understood. We take important steps in clarifying its structure by explaining how it can be obtained as a quotient of the trie for the set of factors. When seen this way, all known properties of the factor oracle become simple observations. Also, we introduce a framework where various oracles can be compared. The factor oracle is better than several natural ones.
CIAA 2006;Reducing Simple Grammars: Exponential Against Highly-Polynomial Time in Practice;Cédric Bastien, Jurek Czyzowicz, Wojciech Fraczak, Wojciech Rytter;The simple grammar reduction is an important component in the implementation of Concatenation State Machines (a hardware version of stateless pushdown automata designed for wire-speed network packet classification). We present a comparison and experimental analysis of the best-known algorithms for the grammar reduction. There are two classes of algorithms: the ones that process compressed strings without decompression (polynomial time) and the ones which process strings explicitely. The second category, though exponential time in pessimistic case, is more efficient in the considered practical scenario. There are two approaches to this problem: one processing compressed strings without decompression and another one which processes strings explicitely. It turns out that the second approach is more efficient in the considered practical scenario despite having worst-case exponential time complexity (while the first one is polynomial). The study has been conducted in the context of network packet classification, where simple grammars are used for representing the classification policies.
CIAA 2006;Tiburon: A Weighted Tree Automata Toolkit;Jonathan May, Kevin Knight;The availability of weighted finite-state string automata toolkits made possible great advances in natural language processing. However, recent advances in syntax-based NLP model design are unsuitable for these toolkits. To combat this problem, we introduce a weighted finite-state tree automata toolkit, which incorporates recent developments in weighted tree automata theory and is useful for natural language applications such as machine translation, sentence compression, question answering, and many more.
CIAA 2006;Around Hopcroft’s Algorithm;Manuel Baclet, Claire Pagetti;In this paper, a reflection is made on an indeterminism inherent to Hopcroft’s minimization algorithm: the splitter choice. We have implemented two natural policies (FIFO and FILO) for managing the set of splitters for which we obtain the following practical results: the FILO strategy performs better than the FIFO strategy, in the case of a one letter alphabet, the practical complexity in the FILO case never exceeds a linear one and our implementation is more efficient than the minimization algorithm of the FSM tool. This implementation is being integrated in a finite automata library, the Dash library. Thus, we present an efficient manner to manipulate automata by using canonical minimal automata.
CIAA 2006;Multi-tape Automata with Symbol Classes;F. Nicart, J. -M. Champarnaud, T. Csáki, T. Gaál, A. Kempe;We propose a new model of finite state machine: multi-tape automata with symbol classes and identity and non-identity constraints (in short MASCIN). This model generalizes both classical single or multi-tape machines, and machines with extended alphabet. We define this model in terms of a constraint satisfaction problem and discuss a problem occurring when projection is used on the model. Finally, we describe its implementation and results of a performance test.
CIAA 2006;On the Computation of Some Standard Distances Between Probabilistic Automata;Corinna Cortes, Mehryar Mohri, Ashish Rastogi;The problem of the computation of a distance between two probabilistic automata arises in a variety of statistical learning problems. This paper presents an exhaustive analysis of the problem of computing the Lp distance between two automata. We give efficient exact and approximate algorithms for computing these distances for p even and prove the problem to be NP-hard for all odd values of p, thereby completing previously known hardness results. We also give an efficient algorithm for computing the Hellinger distance between unambiguous probabilistic automata. Our results include a general algorithm for the computation of the norm of an unambiguous probabilistic automaton based on a monoid morphism and efficient algorithms for the specific case of the computation of the Lp norm. Finally, we also describe an efficient algorithm for testing the equivalence of two arbitrary probabilistic automata A1 and A2 based on Schützenberger’s standardization with a running time complexity of O(|Σ| (|A1| + |A2|)3), a significant improvement over the previously best algorithm reported for this problem.
CIAA 2006;Does o-Substitution Preserve Recognizability?;Andreas Maletti;Substitution operations on tree series are at the basis of systems of equations (over tree series) and tree series transducers. Tree series transducers seem to be an interesting transformation device in syntactic pattern matching. In this contribution, it is shown that o-substitution preserves recognizable tree series provided that the target tree series is linear and the semiring is idempotent, commutative, and continuous. This result is applied to prove that the range of the o-t-ts transformation computed by a linear recognizable tree series transducer is pointwise recognizable.
CIAA 2006;Correctness Preservation and Complexity of Simple RL-Automata;H. Messerschmidt, F. Mráz, F. Otto, M. Plátek;Analysis by reduction is a method used in linguistics for checking the correctness of sentences of natural languages. This method can be modelled by restarting automata. Here we study a new type of restarting automaton, the so-called t-sRL-automaton, which is an RL-automaton that is rather restricted in that it has a window of size 1 only, and that it works under a minimal acceptance condition. On the other hand, it is allowed to perform up to t rewrite (that is, delete) steps per cycle. We study the correctness preservation of these automata on the one hand, and the complexity of these automata on the other hand, establishing a complexity measure that is based on the description of t-sRL-automata in terms of so-called meta-instructions. We present a hierarchy result and we show that the correctness preserving nondeterministic t-sRL-automata are not stronger than the deterministic t-sRL-automata.
CIAA 2006;Bisimulation Minimization of Tree Automata;Parosh Aziz Abdulla, Lisa Kaati, Johanna Högberg;We extend an algorithm by Paige and Tarjan that solves the coarsest stable refinement problem to the domain of trees. The algorithm is used to minimize non-deterministic tree automata (NTA) with respect to bisimulation. We show that our algorithm has an overall complexity of \(O(\hat{r}m \log n)\), where \(\hat{r}\) is the maximum rank of the input alphabet, m is the total size of the transition table, and n is the number of states.
CIAA 2006;Forgetting Automata and Unary Languages;Jens Glöckler;We consider forgetting automata, i.e., linear bounded automata which can only use the operations ‘move’, ‘erase’ (rewrite with a blank symbol) and ‘delete’ (remove completely). A classification of the families of languages corresponding to the possible combinations of operations has been given in [1], here we address some of the problems left open. Furthermore the unary case is being investigated.
CIAA 2006;Structurally Unambiguous Finite Automata;Hing Leung;We define a structurally unambiguous finite automaton (SUFA) to be a nondeterministic finite automaton (NFA) with one starting state q0 such that for all input strings w and for any state q, there is at most one path from q0 to q that consumes w. The definition of SUFA differs from the usual definition of an unambiguous finite automaton (UFA) in that the new definition is defined in terms of the transition logic of the finite automaton, and is independent of the choice of final states. We show that SUFA can be exponentially more succinct in the number of states than UFA and MDFA (deterministic finite automata with multiple initial states). Some interesting examples of SUFA are given. We argue that SUFA is a meaningful concept, and can have practical importance as it can implemented efficiently on synchronous models of parallel computation.
CIAA 2005;Languages Recognizable by Quantum Finite Automata;Rūsiņš Freivalds;There are several nonequivalent definitions of quantum finite automata. Nearly all of them recognize only regular languages but not all regular languages. On the other hand, for all these definitions there is a result showing that there is a language l such that the size of the quantum automaton recognizing L is essentially smaller than the size of the minimal deterministic automaton recognizing L.
CIAA 2005;The Language, the Expression, and the (Small) Automaton;Jacques Sakarovitch;This survey paper reviews the means that allow to go from one representation of the languages to the other and how, and to what extend, one can keep them small. Some emphasis is put on the comparison between the expressions that can be computed from a given automaton and on the construction of the derived term automaton of an expression.
CIAA 2005;Minimization of Non-deterministic Automata with Large Alphabets;Parosh Aziz Abdulla, Johann Deneux, Lisa Kaati, Marcus Nilsson;There has been several attempts over the years to solve the bisimulation minimization problem for finite automata. One of the most famous algorithms is the one suggested by Paige and Tarjan. The algorithm has a complexity of \(\mathcal O\)(m log n) where m is the number of edges and n is the number of states in the automaton. A bottleneck in the application of the algorithm is often the number of labels which may appear on the edges of the automaton. In this paper we adapt the Paige-Tarjan algorithm to the case where the labels are symbolically represented using Binary Decision Diagrams (BDDs). We show that our algorithm has an overall complexity of \({\mathcal O}(l \cdot m \cdot log{n})\) where ℓ is the size of the alphabet. This means that our algorithm will have the same worst case behavior as other algorithms. However, as shown by our prototype implementation, we get a vast improvement in performance due to the compact representation provided by the BDDs.
CIAA 2005;Simulating Two-Dimensional Recognizability by Pushdown and Queue Automata ;Marcella Anselmo, Maria Madonia;The aim of this paper is to investigate sequential models to describe two-dimensional languages. The intent is to add more capabilities to 4NFA in order to encompass a wider class of languages. We show that any (tiling) recognizable language can be simulated by a 4NFA with an extra queue whose size is bounded by the minimum of the two dimensions of a picture. and that 2NFA (i.e. automata moving only in two directions) with an analogous queue are sufficient when the alphabet is unary. A special class of recognizable languages can be simulated also by 4-way pushdown automata with a stack of size bounded by the sum of the two dimensions of the picture. Such a class is also characterized by a recursive definition involving the operations of union, intersection and a new diagonal overlapping operation applied to languages recognized by 2NFA.
CIAA 2005;Component Composition Preserving Behavioural Contracts Based on Communication Traces;Arnaud Bailly, Mireille Clerbout, Isabelle Simplot-Ryl;This paper investigates the compositional properties of reusable software components defined with explicit dependencies and behavioural contracts expressing rely-guarantee specifications in the form of communication traces. In this setting, connection of components through their matching ports is indeed compositional and yields a new component or composite that respects its constituents’ contracts. Thus the behaviour of the composite is computed from the behaviours of its constituents and is known to conform to the contracts without any new proof.
CIAA 2005;Strong Retiming Equivalence of Synchronous Schemes;Miklós Bartha;Strong retiming equivalence is the join of two basic equivalence relations of synchronous schemes: strong equivalence and retiming equivalence, which play an important role in the optimization of synchronous systems. Each of these equivalences is characterized separately in an algebraic/category theoretic framework, and the characterization is carried over to the join of them. Tree-reducible schemes are introduced to facilitate the proof that strong retiming equivalence is decidable.
CIAA 2005;Prime Normal Form and Equivalence of Simple Grammars;Cédric Bastien, Jurek Czyzowicz, Wojciech Fraczak, Wojciech Rytter;A prefix-free language is a prime if it cannot be decomposed into a concatenation of two prefix-free languages. We show that we can check in polynomial time if a language generated by a simple context-free grammar is a prime. Our algorithm computes a canonical representation of a simple language, converting its arbitrary simple grammar into Prime Normal Form (PNF). a simple grammar is in PNF if all its nonterminals define primes. We also improve the complexity of testing the equivalence of simple grammars. The best previously known algorithm for this problem worked in O(n13) time. We improve it to O(n7 log2n) and O(n5 polylog v) deterministic time, and O(n4 polylog n) randomized time, where n is the total size of the grammars involved, and v is the length of a shortest string derivable from a nonterminal, maximized over all nonterminals. Our improvement is based on a version of Caucal’s algorithm from [1].
CIAA 2005;An Incremental Algorithm for Constructing Minimal Deterministic Finite Cover Automata;Cezar Câmpeanu, Andrei Păun, Jason R. Smith;We present a fast incremental algorithm for constructing minimal DFCA for a given language. Since it was shown that the DFCA for a language L can have less states than the DFA for L, this technique seems to be the best choice for incrementally building the automaton for a large language, especially when the number of states in the DFCA is significantly less than the number of states in the corresponding minimal DFA. We have implemented the proposed algorithm and have tested it against the best known DFCA minimization technique.
CIAA 2005;Finite Automata and Unions of Regular Patterns with Bounded Constant Segments;Antonio Cano, Pedro García;The class of unbounded unions of regular pattern languages with bounded constant segments is identifiable from positive data in the limit [1]. Otherwise, no efficient algorithm that performs the inference of this class of languages is known. We propose a solution to this problem using the existing connexion between the positive variety of languages of dot depth 1/2, \({\mathcal LJ}^+\) [2] and the class of unbounded union of pattern languages \({\mathcal RP}^+{\mathcal L}\).
CIAA 2005;Inside Vaucanson;Thomas Claveirole, Sylvain Lombardy, Sarah O’Connor, Louis-Noël Pouchet, Jacques Sakarovitch;This paper presents some features of the Vaucanson platform. We describe some original algorithms on weighted automata and transducers (computation of the quotient, conversion of a regular expression into a weighted automaton, and composition). We explain how complex declarations due to the generic programming are masked from the user and finally we present a proposal for an XML format that allows implicit descriptions for simple types of automata.
CIAA 2005;Deterministic Recognition of Trees Accepted by a Linear Pushdown Tree Automaton;Akio Fujiyoshi, Ikuo Kawaharada;In this paper, a deterministic recognition algorithm for the class of tree languages accepted by (nondeterministic) linear pushdown tree automata (L-PDTAs) is proposed. L-PDTAs accept an important class of tree languages since the class of their yield languages coincides with the class of yield languages generated by tree adjoining grammars (TAGs). The proposed algorithm is obtained by combining a bottom-up parsing procedure on trees with the CKY (Cocke-Kasami-Younger) algorithm. The running time of the algorithm is O(n4), where n is the number of nodes of an input tree.
CIAA 2005;Shorter Regular Expressions from Finite-State Automata;Yo-Sub Han, Derick Wood;We consider the use of state elimination to construct shorter regular expressions from finite-state automata. Although state elimination is an intuitive method for computing regular expressions from finite-state automata, the resulting regular expressions are often very long and complicated. We examine the minimization of finite-state automata to obtain shorter expressions first. Then, we introduce vertical chopping based on bridge states and horizontal chopping based on the structural properties of given finite-state automata. We prove that we should not eliminate bridge states until we eliminate all non-bridge states to obtain shorter regular expressions. In addition, we suggest heuristics for state elimination that lead to shorter regular expressions based on vertical chopping and horizontal chopping.
CIAA 2005;Wind in the Willows – Generating Music by Means of Tree Transducers;Johanna Högberg;We implement a rule-based system for algorithmic composition. This system, that we call Willow, resides in the Treebag environment and consists of a sequence of formal devices, familiar from the field of tree grammars and tree transducers. Since these devices are well studied, we can apply known results to derive the descriptive complexity of the system as a whole.
CIAA 2005;On Deterministic Catalytic Systems;Oscar H. Ibarra, Hsu-Chun Yen;We look at a 1-membrane catalytic P system with evolution rules of the form Ca →Cv or a →v, where C is a catalyst, a is a noncatalyst symbol, and v is a (possibly null) string representing a multiset of noncatalyst symbols. (Note that we are only interested in the multiplicities of the symbols.) A catalytic system can be regarded as a language acceptor in the following sense. Given an input alphabet Σ consisting of noncatalyst symbols, the system starts with an initial configuration wz, where w is a fixed string of catalysts and noncatalysts not containing any symbol in z, and \(z = a_1^{n_1} \ldots a_k^{n_k}\) for some nonnegative integers n1, ..., nk, with { a1 ...ak } ⊆ ∑. At each step, a maximal multiset of rules is nondeterministically selected and applied in parallel to the current configuration to derive the next configuration (note that the next configuration is not unique, in general). The string z is accepted if the system eventually halts.
CIAA 2005;Restricting the Use of Auxiliary Symbols for Restarting Automata;Tomasz Jurdziński, Friedrich Otto;The most general models of restarting automata make use of auxiliary symbols in their rewrite operations. Here we put restrictions on the way in which restarting automata use auxiliary symbols, and we investigate the influence of these restrictions on their expressive power. In fact, we consider two types of restrictions. First, we consider the number of auxiliary symbols in the tape alphabet of a restarting automaton as a measure of its descriptional complexity. Secondly, we consider the number of occurrences of auxiliary symbols on the tape as a dynamic complexity measure. We establish some lower and upper bounds with respect to these complexity measures concerning the ability of restarting automata to recognize the (deterministic) context-free languages and some of their subclasses.
CIAA 2005;A Class of Rational n-WFSM Auto-intersections;André Kempe, Jean-Marc Champarnaud, Jason Eisner, Franck Guingne, Florent Nicart;Weighted finite-state machines with n tapes describe n-ary rational string relations. The join n-ary relation is very important in applications. It is shown how to compute it via a more simple operation, the auto-intersection. Join and auto-intersection generally do not preserve rationality. We define a class of triples 〈A, i, j〉 such that the auto-intersection of the machine A on tapes i and j can be computed by a delay-based algorithm. We point out how to extend this class and hope that it is sufficient for many practical applications.
CIAA 2005;Experiments with Deterministic ω-Automata for Formulas of Linear Temporal Logic;Joachim Klein, Christel Baier;This paper addresses the problem of generating deterministic ω-automata for formulas of linear temporal logic, which can be solved by applying well-known algorithms to construct a nondeterministic Büchi automaton for the given formula on which we then apply a determinization algorithm. We study here in detail Safra’s determinization algorithm, present several heuristics that attempt to decrease the size of the resulting automata and report on experimental results.
CIAA 2005;Computing Affine Hulls over ${\mathbb Q}$ and ${\mathbb Z}$ from Sets Represented by Number Decision Diagrams;Louis Latour;Number Decision Diagrams (NDD) are finite automata representing sets of integer vectors and have recently been proposed as an efficient data structure for representing sets definable in Presburger arithmetic. In this context, some work has been done in order to generate formulas or sets of generators from the NDDs. Taking another step in this direction, this paper present algorithms that takes as input an NDD and computes the affine hull over \({\mathbb Q}\) or over \({\mathbb Z}\) of the set represented by the NDD, i.e., the smallest set defined by a conjunction of equations or by a conjunction of equations and congruence relations that includes the set represented by the NDD. Our algorithms run in time \({\mathcal O}(|{\mathcal Q}| \cdot |{\Sigma_r^n}| \cdot n )\) and \({\mathcal O}(|{\mathcal Q}^3| \cdot |{\Sigma_r^n}| \cdot {n^3} )\) respectively, where n is the number of components of the vectors represented by the NDD, and |Q| and Σ\(_{r}^{n}\) are the number of states and the alphabet of the NDD. On a prototype implementation, the computations of affine hulls of NDDs with more than 100000 states are done in seconds.
CIAA 2005;Tree Automata and XPath on Compressed Trees;Markus Lohrey, Sebastian Maneth;The complexity of various membership problems for tree automata on compressed trees is analyzed. Two compressed representations are considered: dags, which allow to share identical subtrees in a tree, and straight-line context-free tree grammars, which moreover allow to share identical intermediate parts of a tree. Several completeness results for the classes NL, P, and PSPACE are obtained. Finally, the complexity of the XPath evaluation problem on trees that are compressed via straight-line context-free tree grammars is investigated.
CIAA 2003;Automata for Specifying Component Interfaces;Thomas A. Henzinger;R. Alur, T. A. Henzinger, O. Kupferman, and M.Y. Vardi. Alternating refinement relations. In CONCUR 98: Concurrency Theory, Lecture Notes in Computer Science 1466, pages 163–178. Springer-Verlag, 1998.
CIAA 2003;Automata on Words;Juhani Karhumäki;Unable to display preview. Download preview PDF.
CIAA 2003;Symbolic Synthesis of Finite-State Controllers for Request-Response Specifications;Nico Wallmeier, Patrick Hütten, Wolfgang Thomas;We present a method to solve certain infinite games over finite state spaces and apply this for the automatic synthesis of finitestate controllers. A lift-controller problem serves as an example for which the implementation of our algorithm has been tested. The specifications consist of safety conditions and so-called “request-response-conditions” (which have the form “after visiting a state of P later a state of R is visited”). Many real-life problems can be modeled in this framework. We sketch the theoretical solution which synthesizes a finite-state controller for satisfiable specifications. The core of the implementation is a convenient input language (based on enriched Boolean logic) and a realization of the abstract algorithms with OBDD’s (ordered binary decision diagrams).
CIAA 2003;Timing Parameter Characterization of Real-Time Systems;Farn Wang, Hsu-Chun Yen;We investigate the problem of characterizing the solution spaces for timed automata augmented by unknown timing parameters (called timing parameter automata (TPA)). The main contribution of this paper is that we identify three non-trivial subclasses of TPAs, namely, upper-bound, lower-bound and bipartite TPAs, and analyze how hard it is to characterize the solution space. As it turns out, we are able to give complexity bounds for the sizes of the minimal (resp., maximal) elements which completely characterize the upward-closed (resp., downward-closed) solution spaces of upper-bound (resp., lower-bound) TPAs. For bipartite TPAs, it is shown that their solution spaces are not semilinear in general. We also extend our analysis to TPAs equipped with counters without zero-test capabilities.
CIAA 2003;Constructing Büchi Automata from Linear Temporal Logic Using Simulation Relations for Alternating Büchi Automata;Carsten Fritz;We present a new procedure for the translation of propositional linear-time temporal logic (LTL) formulas to equivalent nondeterministic Büchi automata. Our procedure is based on simulation relations for alternating Büchi automata. Whereas most of the procedures that have been described in the past compute simulation relations in the last step of the translation (after a nondeterministic Büchi automaton has already been constructed), our procedure computes simulation relations for alternating Büchi automata in an early stage and uses them in an on-the- fly fashion. This decreases the time and space consumption without sacrificing the potential of simulation relations.
CIAA 2003;From Regular Weighted Expressions to Finite Automata;Jean-Marc Champarnaud, Éric Laugerotte, Faissal Ouardi, Djelloul Ziadi;In this article we generalize the concepts of position automaton and ZPC structure to the regular \( \mathbb{K} \)-expressions. We show that the ZPC structure can be built in linear time in the size of the expression and that the associated position automaton can be deduced from it in quadratic time.
CIAA 2003;Bideterministic Automata and Minimal Representations of Regular Languages;Hellis Tamm, Esko Ukkonen;Bideterministic automata are deterministic automata with the property of their reversal automata also being deterministic. It has been known that a bideterministic automaton is the minimal deterministic automaton accepting its language. This paper shows that any bideterministic automaton is the unique minimal automaton among all (including nondeterministic) automata accepting the same language. We also present a more general result that shows that under certain conditions a minimal deterministic automaton accepting some language or the reversal of the minimal deterministic automaton of the reversal language is a minimal automaton representation of the language. These conditions can be checked in polynomial time.
CIAA 2003;Succinct Descriptions of Regular Languages with Binary ⊕-NFAs;Lynette van Zijl;Champarnaud [1] analyzed the number of states obtained from a binary ⊕-NFA during the subset construction. We extend this work to an experimental analysis of the size of the minimal DFAs obtained from binary ⊕-NFAs.We then consider the number of distinct languages accepted by binary ⊕-NFAs, and compare that to Domaratzki’s results [2] for (traditional) binary NFAs. We also show that there are certain regular languages which are accepted by succinct ⊕-NFAs, but for which no succinct traditional NFA exists.
CIAA 2003;An Efficient Pre-determinization Algorithm;Cyril Allauzen, Mehryar Mohri;We present a general algorithm, pre-determinization, that makes an arbitrary weighted transducer over the tropical semiring or an arbitrary unambiguous weighted transducer over a cancellative commutative semiring determinizable by inserting in it transitions labeled with special symbols. After determinization, the special symbols can be removed or replaced with ε-transitions. The resulting transducer can be significantly more efficient to use. We report empirical results showing that our algorithm leads to a substantial speed-up in large-vocabulary speech recognition. Our pre-determinization algorithm makes use of an efficient algorithm for testing a general twins property, a sufficient condition for the determinizability of all weighted transducers over the tropical semiring and unambiguous weighted transducers over cancellative commutative semirings. It inserts new transitions just when needed to guarantee that the resulting transducer has the twins property and thus is determinizable. It also uses a single-source shortest-paths algorithm over the min-max semiring for carefully selecting the positions for insertion of new transitions to benefit from the subsequent application of determinization. These positions are proved to be optimal in a sense that we describe.
CIAA 2003;Introducing Vaucanson ;Sylvain Lombardy, Raphaël Poss, Yann Régis-Gianas, Jacques Sakarovitch;This paper reports on a new software platform called Vaucanson and dedicated to the computation with automata and transducers. Its main feature is the capacity of dealing with automata whose labels may belong to various algebraic structures.
CIAA 2003;WFSC — A New Weighted Finite State Compiler;André Kempe, Christof Baeijs, Tamás Gaál, Franck Guingne, Florent Nicart;This article presents a new tool, WFSC, for creating, manipulating, and applying weighted finite state automata. It inherits some powerful features from Xerox’s non-weighted XFST tool and represents a continuation of Xerox’s work in the field of finite state automata over two decades. The design is generic: algorithms work on abstract components of automata and on a generic abstract semiring, and are independent of their concrete realizations. Applications can access WFSC’s functions through an API or create automata through an end-user interface, either from an enumeration of their states and transitions or from rational expressions.
CIAA 2003;Ternary Directed Acyclic Word Graphs;Satoru Miyamoto, Shunsuke Inenaga, Masayuki Takeda, Ayumi Shinohara;Given a set S of strings, a DFA accepting S offers a very time-efficient solution to the pattern matching problem over S. The key is how to implement such a DFA in the trade-off between time and space, and especially the choice of how to implement the transitions of each state is critical. Bentley and Sedgewick proposed an effective tree structure called ternary trees. The idea of ternary trees is to ‘implant’ the process of binary search for transitions into the structure of the trees themselves. This way the process of binary search becomes visible, and the implementation of the trees becomes quite easy. The directed acyclic word graph (DAWG) of a string w is the smallest DFA that accepts all suffixes of w, and requires only linear space. We apply the scheme of ternary trees to DAWGs, introducing a new data structure named ternary DAWGs (TDAWGs). We perform some experiments that show the efficiency of TDAWGs, compared to DAWGs in which transitions are implemented by tables and linked lists.
CIAA 2003;Running Time Complexity of Printing an Acyclic Automaton;Franck Guingne, André Kempe, Florent Nicart;This article estimates the worst-case running time complexity for traversing and printing all successful paths of a normalized trim acyclic automaton. First, we show that the worst-case structure is a festoon with distribution of arcs on states as uniform as possible. Then, we prove that the complexity is maximum when we have a distribution of e (Napier constant) outgoing arcs per state on average, and that it can be exponential in the number of arcs.
CIAA 2003;Reducing the Time Complexity of Testing for Local Threshold Testability;Avraham Trakhtman;A locally threshold testable language L is a language with the property that for some nonnegative integers k and l, whether or not a word u is in the language L depends on (1) the prefix and suf- fix of the word u of length k − 1 and (2) the set of intermediate substrings of length k of the word u where the sets of substrings occurring at least j times are the same, for j ≤ l. For given k and l the language is called l-threshold k-testable. A finite deterministic automaton is called threshold locally testable if the automaton accepts a l-threshold ktestable language for some l and k.
CIAA 2003;Branching Automata with Costs — A Way of Reflecting Parallelism in Costs;Dietrich Kuske, Ingmar Meinecke;Extending work by Lodaya and Weil, we propose a model of branching automata with costs in which the calculation of the cost of a parallel composition is handled differently from the calculation of the cost of a sequential composition. Our main result characterizes the behavior of these automata in the spirit of Kleene’s and Schützenberger’s theorems.
CIAA 2003;New Complexity Results for Some Linear Counting Problems Using Minimal Solutions to Linear Diophantine Equations;Gaoyan Xie, Cheng Li, Zhe Dang;The linear reachability problem is to decide whether there is an execution path in a given finite state transition system such that the counts of labels on the path satisfy a given linear constraint. Using results on minimal solutions (in nonnegative integers) for linear Diophantine systems, we obtain new complexity results for the problem, as well as for other linear counting problems of finite state transition systems and timed automata. In contrast to previously known results, the complexity bounds obtained in this paper are polynomial in the size of the transition system in consideration, when the linear constraint is fixed.
CIAA 2003;TCTL Inevitability Analysis of Dense-Time Systems;Farn Wang, Geng-Dian Hwang, Fang Yu;Inevitability properties in branching temporal logics are of the syntax ∀◊φ, where φ is an arbitrary (timed) CTL formula. Such inevitability properties in dense-time logics can be analyzed with greatest fixpoint calculation. We present algorithms to model-check inevitability properties both with and without non-Zeno computation requirement. We discuss a technique for early decision on greatest fixpoint calculation. Our algorithms come with a d-parameter for the measurement of time-progress. We have experimented with various issues, which may affect the performance of TCTL inevitability analysis. Specifically, we report the performance of our implementation w.r.t. various d-parameter values and with or without the non-Zeno computation requirement in the evaluation of greatest fixpoints. We have also experimented with safe abstration techniques for model-checking TCTL inevitability properties. Analysis of experiment data helps clarify how various techniques can be used to improve verification of inevitability properties.
CIAA 2003;Conversation Protocols: A Formalism for Specification and Verification of Reactive Electronic Services;Xiang Fu, Tevfik Bultan, Jianwen Su;This paper focuses on the realizability problem of a framework for modeling and specifying the global behavior of reactive electronicservices (e-services). In this framework, Web accessible programs (peers) communicate by asynchronous message passing, and a virtual global watcher listens silently to the network. The global behavior is characterized by a conversation, which is the infinite sequence of messages observed by the watcher. We show that given a Büchi automaton specifying the desired set of conversations, called a conversation protocol, it is possible to implement it using a set of finite state peers if three realizability conditions are satisfied. In particular, the synthesized peers will conform to the protocol by generating only those conversations specified by the protocol. Our results enable a top-down verification strategy where: (1) A conversation protocol is specified by a realizable Büchi automaton, (2) The properties of the protocol are verified on the Büchi automaton specification, (3) The peer implementations are synthesized from the protocol via projection.
CIAA 2003;Boolean Operations for Attribute-Element Constraints;Haruo Hosoya, Makoto Murata;The history of schema languages for XML is an increase of expressiveness. While early schema languages mainly focused on the element structure, Clark first paid an equal attention to attributes by allowing both element and attribute constraints in a single regular expression. In this paper, we investigate an algorithmic aspect of Clark’s mechanism (called “attribute-element constraints”), namely, intersection and difference operations, which have been proved to be important in static typechecking for XML processing programs. The contributions here are (1) proofs of closure under intersection and difference and (2) algorithm formulations incorporating a “divide-and-conquer” strategy for avoiding an exponential blow-up for typical inputs.
CIAA 2002;Edit-Distance of Weighted Automata;Mehryar Mohri;The edit-distance of two strings is the minimal cost of a sequence of symbol insertions, deletions, or substitutions transforming one string into the other. The definition is used in various contexts to give a measure of the difference or similarity between two strings. This definition can be extended to measure the similarity between two sets of strings. In particular, when these sets are represented by automata, their edit-distance can be computed using the general algorithm of composition of weighted transducers combined with a single-source shortest-paths algorithm. More generally, in some applications such as speech recognition and computational biology, the strings may represent a range of alternative hypotheses with associated probabilities. Thus, we introduce the definition of the edit-distance of two distributions of strings given by two weighted automata. We show that general weighted automata algorithms over the appropriate semirings can be used to compute the edit-distance of two weighted automata exactly. The algorithm for computing exactly the edit-distance of weighted automata can be used to improve the word accuracy of automatic speech recognition systems. More generally, the algorithm can be extended to provide an edit-distance automaton useful for rescoring and other post-processing purposes in the context of large-vocabulary speech recognition. In the course of the presentation of our algorithm, we also introduce a new and general synchronization algorithm for weighted transducers which, combined with ∈-removal, can be used to normalize weighted transducers with bounded delays.
CIAA 2002;p-Subsequentiable Transducers;Cyril Allauzen, Mehryar Mohri;p-subsequential transducers are efficient finite-state transducers with p final outputs used in a variety of applications. Not all transducers admit equivalent p-subsequential transducers however. We briefly describe an existing generalized determinization algorithm for psubsequential transducers and give the first characterization of p-subsequentiable transducers, transducers that admit equivalent p-subsequential transducers. Our characterization shows the existence of an efficient algorithm for testing p-subsequentiability. We have fully implemented the generalized determinization algorithm and the algorithm for testing p- subsequentiability. We report experimental results showing that these algorithms are practical in large-vocabulary speech recognition applications. The theoretical formulation of our results is the equivalence of the following three properties for finite-state transducers: determinizability in the sense of the generalized algorithm, p-subsequentiability, and the twins property.
CIAA 2002;Bidirectional Push Down Automata;Miguel A. Alonso, Víctor J. Díaz, Manuel Vilares;We define a new model of automata for the description of bidirectional parsing strategies for context-free grammars and a tabulation mechanism that allow them to be executed in polynomial time. This new model of automata provides a modular way of defining bidirectional parsers, separating the description of a strategy from its execution.
CIAA 2002;Finite Automata and Non-self-Embedding Grammars;Marcella Anselmo, Dora Giammarresi, Stefano Varricchio;We consider non-self-embedding (NSE) context-free grammars as a representation of regular sets.We point out its advantages with respect to more classical representations by finite automata, in particular when considering the efficient realization of the rational operations. We give a characterization in terms of composition of regular grammars and state relationships between NSE grammars and push-down automata. Finally we show a polynomial algorithm to decide whether a context-free grammars is self-embedding or not.
CIAA 2002;Simulation of Gate Circuits in the Algebra of Transients;Janusz Brzozowski, Mihaela Gheorghiu;We study simulation of gate circuits in algebra C recently introduced by Brzozowski and Ésik.A transient is a word consisting of alternating 0s and 1s. it represents a changing signal. In C, gates process transients instead of 0s and 1s. Simulation in C is capable of counting signal changes, and detecting hazards.We study two simulation algorithms: a general one, A, that works with any state, and Ã, that applies if the initial state is stable.We show that the two algorithms agree in the stable case. We prove the sufficiency of the simulation: all signal changes occurring in binary analysis are also predicted by Algorithm A.
CIAA 2002;The Number of Similarity Relations and the Number of Minimal Deterministic Finite Cover Automata;Cezar Cămpeanu, Andrei Păun;Finite Deterministic Cover Automata (DFCA) can be obtained from Deterministic Finite Automata (DFA) using the similarity relation. Since the similarity relation is not an equivalence relation, the minimal DFCA for a finite language is usually not unique. We count the number of minimal DFCA that can be obtained from a given minimal DFA with n states by merging the similar states in the given DFA. We compute an upper bound for this number and prove that in the worst case (for a non-unary alphabet) it is [4n-9+√8n+1!/8]/(2[4n-9+√8n+1/8] - n + 1)!
CIAA 2002;Regex and Extended Regex;Cezar Câmpeanu, Kai Salomaa, Sheng Yu;Regex are used in many programs such as Perl, Awk, Python, egrep, vi, emacs etc. It is known that regex are different from regular expressions. In this paper, we give regex a formal treatment. We make a distinction between regex and extended regex. while regex present regular languages, extended regex present a family of languages larger than regular languages. We prove a pumping lemma for the languages expressed by extended regex. We show that the languages represented by extended regex are incomparable with context-free languages and a proper subset of context-sensitive languages.
CIAA 2002;Prime Decompositions of Regular Prefix Codes;Jurek Czyzowicz, Wojciech Fraczak, Andrzej Pelc, Wojciech Rytter;One of the new approaches to data classification uses finite state automata for representation of prefix codes. An important task driven by the need for the efficient storage of such automata in memory is the decomposition of prefix codes into prime factors. We investigate properties of such prefix code decompositions. A linear time algorithm is designed which finds the prime decomposition F1F2 . . . Fk of a regular prefix code F given by its minimal deterministic automaton.
CIAA 2002;Implementation of Dictionaries via Automata and Decision Trees;Abolfazl Fatholahzadeh;Finite-state transducers can be used to map a language onto a set of values. This paper proposes an alternate representation method for such a mapping, consisting of associating a finite-state automaton accepting the input language with a decision tree representing the output values. The advantages of this approach are that it leads to more compact representations than transducers, and that decision trees can easily be synthesized by machine learning techniques.
CIAA 2002;Feedback-Free Circuits in the Algebra of Transients;Mihaela Gheorghiu, Janusz Brzozowski;An efficient simulation algorithm using an algebra of transients for gate circuits was proposed by Brzozowski and Ésik. This algorithm seems capable of predicting all the signal changes that can occur in a circuit under worst-case delay conditions. We verify this claim by comparing simulation with binary analysis. For any feedback-free circuit consisting of 1- and 2-input gates and started in a stable state, we prove that all signal changes predicted by simulation occur in binary analysis, provided that wire delays are taken into account. Two types of finite automata play an important role in our proof.
CIAA 2002;On Minimizing Cover Automata for Finite Languages in O(n log n) Time;Heiko Körner;A deterministic finite automaton (DFA) A is called a cover automaton (DFCA) for a finite language L over some alphabet σ if L = L(A) ∩ σ≤l, with l being the length of some longest word in L. Thus a word w ∈ σ* is in L if and only if ∣w∣ ≤ l and w ∈ L(A). The DFCA A is minimal if no DFCA for L has fewer states.
CIAA 2002;Compilation of Constraint-Based Contextual Rules for Part-of-Speech Tagging into Finite State Transducers;Jorge Graña, Gloria Andrade, Jesús Vilares;With the aim of removing the residuary errors made by pure stochastic disambiguation models, we put forward a hybrid system in which linguist users introduce high level contextual rules to be applied in combination with a tagger based on a Hidden Markov Model. The design of these rules is inspired in the Constraint Grammars formalism. In the present work, we review this formalism in order to propose a more intuitive syntax and semantics for rules, and we develop a strategy to compile the rules under the form of Finite State Transducers, thus guaranteeing an efficient execution framework.
CIAA 2002;Finite State Lazy Operations in NLP;Franck Guingne, Florent Nicart;Finite state networks can represent dictionaries and lexical relations. Traditional finite-state operations like composition can produce huge networks with prohibitive computation space and time. For a subset of finite state operations, these drawbacks can be avoided by using virtual networks, which rely on structures that are partially built on demand. This paper addresses the implementation of virtual network operations in xfst (XEROX Finite State Technology software). The example of “priority union” which is particularly useful in NLP, is developed.
CIAA 2002;State Complexity of Basic Operations on Nondeterministic Finite Automata;Markus Holzer, Martin Kutrib;The state complexities of basic operations on nondeterministic finite automata (NFA) are investigated. In particular, we consider Boolean operations, catenation operations - concatenation, iteration, λ- free iteration - and the reversal on NFAs that accept finite and infinite languages over arbitrary alphabets. Most of the shown bounds are tight in the exact number of states, i.e. the number is sufficient and necessary in the worst case. For the complementation tight bounds in the order of magnitude are proved. It turns out that the state complexities of operations on NFAs and deterministic .nite automata (DFA) are quite different. For example, the reversal and concatenation have exponential state complexity on DFAs but linear complexity on NFAs. Conversely, the complementation can be done with linear complexity on DFAs but needs exponentially many states on NFAs.
CIAA 2002;Adaptive Automata - A Revisited Proposal;João José Neto, César Bravo;This paper impose further discipline to the use of adaptive automata [Jos94], [Iwa00] by restricting some of their features, in order to obtain devices that are easier to create and more readable, without loosing computational power. An improved notation is proposed as a first try towards a language for adaptive paradigm programming.
CIAA 2002;Efficient Automaton-Based Recognition for Linear Conjunctive Languages;Alexander Okhotin;This paper studies practical algorithms for dealing with a particular family of cellular automata, which has recently been proved computationally equivalent to linear conjunctive grammars. The relation between these grammars and these automata resembles that between regular expressions and finite automata: while the former are better suited for human use, the latter are considerably easier to implement. In this paper, an algorithm for converting an arbitrary linear conjunctive grammar to an equivalent automaton is proposed, and different techniques of reducing the size of existing automata are studied.
CIAA 2002;Syntactic Semiring and Language Equations;Libor Polák;A classical construction assigns to any language its (ordered) syntactic monoid. Recently the author defined the so-called syntactic semiring of a language. We show here that elements of the syntactic semiring of L can be identified with transformations of a certain modification of the minimal automaton for L.
CIAA 2002;Reduced Power Automata;Klaus Sutner;We describe a class of transitive semiautomata whose power automata are reduced: any two reachable sets of states have distinct behavior. These automata appear naturally in the study of one-dimensional cellular automata.
CIAA 2002;A Polynomial Time Algorithm for Left [Right] Local Testability;A.N. Trahtman;A right [left] locally testable language S is a language with the property that for some nonnegative integer k two words u and v in alphabet S are equal in the semigroup if (1) the prefix and sufix of the words of length k -1 coincide, (2) the set of segments of length k of the words as well as 3) the order of the first appearance of these segments in prefixes [sufixes] coincide.
CIAA 2001;Using Finite State Technology in Natural Language Processing of Basque;Iñaki Alegria, Maxux Aranzabe, Nerea Ezeiza, Aitzol Ezeiza, Ruben Urizar;This paper describes the components used in the design and implementation of NLP tools for Basque. These components are based on finite state technology and are devoted to the morphological analysis of Basque, an agglutinative pre-Indo-European language. We think that our design can be interesting for the treatment of other languages. The main components developed are a general and robust morphological analyser/generator and a spelling checker/corrector for Basque named Xuxen. The analyser is a basic tool for current and future work on NLP of Basque, such as the lemmatiser/tagger Euslem, an Intranet search engine or an assistant for verse-making.
CIAA 2001;Cascade Decompositions are Bit-Vector Algorithms;Anne Bergeron, Sylvie Hamel;A vector algorithm is an algorithm that applies a bounded number of vector operations to an input vector, regardless of the length of the input. In this paper, we describe the links between the existence of vector algorithms and the cascade decompositions of counter-free automata.
CIAA 2001;Submodule Construction and Supervisory Control: A Generalization;Gregor v. Bochmann;We consider the following problem: For a system consisting of two submodules, the behavior of one submodule is known as well as the desired behavior S of the global system. What should be the behavior of the second submodule such that the behavior of the composition of the two submodules conforms to S? - This problem has also been called “equation solving”, and in the context of supervisory control, it is the problem of designing a suitable controller (second submodule) which controls a given system to be controlled (first submodule). Solutions to this problem have been described by different authors for various assumptions about the underlying communication mechanisms and conformance relations. We present a generalization of this problem and its solution using concepts from relational database theory. We also show that several of the existing solutions are special cases of our general formulation
CIAA 2001;Counting the Solutions of Presburger Equations without Enumerating Them;Bernard Boigelot, Louis Latour;The Number Decision Diagram (NDD) has recently been proposed as a powerful representation system for sets of integer vectors. In particular, NDDs can be used for representing the sets of solutions of arbitrary Presburger formulas, or the set of reachable states of some systems using unbounded integer variables. In this paper, we address the problem of counting the number of distinct elements in a set of vectors represented as an NDD. We give an algorithm that is able to perform an exact count without enumerating explicitly the vectors, which makes it capable of handling very large sets. As an auxiliary result, we also develop an efficient projection method that allows to construct efficiently NDDs from quantified formulas, and thus makes it possible to apply our counting technique to sets specified by formulas. Our algorithms have been implemented in the verification tool LASH, and applied successfully to various counting problems.
CIAA 2001;Brzozowski’s Derivatives Extended to Multiplicities;Jean-Marc Champarnaud, Gérard Duchamp;Our aim is to study the set of K-rational expressions describing rational series. More precisely we are concerned with the definition of quotients of this set by coarser and coarser congruences which lead to an extension - in the case of multiplicities - of some classical results stated in the Boolean case. In particular, analogues of the well known theorems of Brzozowski and Antimirov are provided in this frame.
CIAA 2001;Finite Automata for Compact Representation of Language Models in NLP;Jan Daciuk, Gertjan van Noord;A technique for compact representation of language models in Natural Language Processing is presented. After a brief review of the motivations for a more compact representation of such language models, it is shown how finite-state automata can be used to compactly represent such language models. The technique can be seen as an application and extension of perfect hashing by means of finite-state automata. Preliminary practical experiments indicate that the technique yields considerable and important space savings of up to 90% in practice.
CIAA 2001;Past Pushdown Timed Automata;Zhe Dang, Tevfik Bultan, Oscar H. Ibarra, Richard A. Kemmerer;We consider past pushdown timed automata that are discrete pushdown timed automata [15] with past-formulas as enabling conditions. Using past formulas allows a past pushdown timed automaton to access the past values of the finite state variables in the automaton. We prove that the reachability (i.e., the set of reachable configurations from an initial configuration) of a past pushdown timed automaton can be accepted by a nondeterministic reversal-bounded multicounter machine augmented with a pushdown stack (i.e., a reversal-bounded NPCM). Using the known fact that the emptiness problem for reversal-bounded NPCMs is decidable, we show that model-checking past pushdown timed automata against Presburger safety properties on discrete clocks and stack word counts is decidable. An example ASTRAL specification is presented to demonstrate the usefulness of the results.
CIAA 2001;Scheduling Hard Sporadic Tasks by Means of Finite Automata and Generating Functions;Jean-Philippe Dubernard, Dominique Geniet;In a previous work, we propose a technique to decide feasability of periodic hard real-time systems based on finite automata. Here, associating generating functions (whose role is “to predict the future”) to a finite automaton, we extend this technique to hard sporadic tasks, independent or interdependent with the periodic tasks.
CIAA 2001;Bounded-Graph Construction for Noncanonical Discriminating-Reverse Parsers;Jacques Farré, José Fortes Gálvez;We present a new approach for the construction of NDR parsers, which defines a new form of items and keeps track of bounded sequences of subgraph connections. This improves the precise recovery of conflicts’ right-hand contexts over the basic looping approach, and thus allows to extend the class of accepted grammars. Acceptance of at least all LALR(k) grammars, for a given k, is guaranteed. Moreover, the construction needs no subgraph copies. Since bounded-graph and basic looping constructions only differ in the accuracy of the conflicts’ right-hand contexts computation, the NDR parsing algorithm remains unchanged.
CIAA 2001;Finite-State Transducer Cascade to Extract Proper Names in Texts;Nathalie Friburger, 1]Denis Maurel;This article describes a finite-state cascade for the extraction of person names in texts in French. We extract these proper names in order to categorize and to cluster texts with them. After a finite-state pre-processing (division of the text in sentences, tagging with dictionaries, etc.), a series of finite-state transducers is applied one after the other to the text and locates left and right contexts that indicates the presence of a person name. An evaluation of the results of this extraction is presented.
CIAA 2001;Is this Finite-State Transducer Sequentiable?;Tamás Gaál;Sequentiality is a desirable property of finite state transducers: such transducers are optimal for time efficiency. Not all transducers are sequentiable. Sequentialization algorithms of finite state transducers do not recognize whether a transducer is sequentiable or not and simply do not ever halt when it is not. Choffrut proved that sequentiality of finite state transducers is decidable. Béal et al. have proposed squaring to decide sequentiality. We propose a different procedure, which, with ε-closure extension, is able to handle letter transducers with arbitrary ε-ambiguities, too. Our algorithm is more economical than squaring, in terms of size. In different cases of non-sequentiability necessary and sufficient conditions of the ambiguity class of the transducer can be observed. These ambiguities can be mapped bijectively to particular basic patterns in the structure of the transducer. These patterns can be recognized, using finite state methods, in any transducer.
CIAA 2001;Compilation Methods of Minimal Acyclic Finite-State Automata for Large Dictionaries;Jorge Graña, Fco. Mario Barcala, Miguel A. Alonso;We present a reflection on the evolution of the different methods for constructing minimal deterministic acyclic finite-state automata from a finite set of words. We outline the most important methods, including the traditional ones (which consist of the combination of two phases: insertion of words and minimization of the partial automaton) and the incremental algorithms (which add new words one by one and minimize the resulting automaton on-the-fly, being much faster and having significantly lower memory requirements). We analyze their main features in order to provide some improvements for incremental constructions, and a general architecture that is needed to implement large dictionaries in natural language processing (NLP) applications.
CIAA 2001;Bit Parallelism - NFA Simulation;Jan Holub;This paper deals with one of possibilities of use of nondeterministic finite automaton (NFA) — simulation of NFA using the method called bit parallelism. After a short presentation of the basic simulation method, the bit parallelism is presented on one of the pattern matching problems. Then a flexibility of the bit parallelism is demonstrated by a simulation of NFAs for other pattern matching problems.
CIAA 2001;Improving Raster Image Run-Length Encoding Using Data Order;Markus Holzer, Martin Kutrib;We examine the technique of run-length encoding in combination with data order, where our attention is focused on good performance of image operations such as, e.g., rotation, reflection, and zooming. To this end we develop a new type of data order that supports these operations well and allows to perform them on a variant of a double-queue automaton directly on the compressed data stream. Because of its shape we call this data order shamrock or S-order. To confirm our theoretical results on S-order we have performed some experiments on sample data using various data orderings that appear in the literature.
CIAA 2001;Enhancements of Partitioning Techniques for Image Compression Using Weighted Finite Automata;Frank Katritzke, Wolfgang Merzenich, Michael Thomas;WFAs (weighted finite automata) are efficient structures for the storage of digital images. The choice of the image partitioning technique is important to achieve good compression results. In this paper we examine the fitness of various promising techniques by measuring the compression performance at well-known test images.
CIAA 2001;Extraction of ε-Cycles from Finite-State Transducers;André Kempe;Much attention has been brought to determinization and ε-removal in previous work. This article describes an algorithm for extracting all ε-cycles, which are a special type of non-determinism, from an arbitrary finite-state transducer (FST). The algorithm factorizes (decomposes) the FST, T, into two FSTs, T1 and T2, such that T1 contains no ε-cycles and T2 contains all ε-cycles of T. Since ε-cycles are an obstacle for some algorithms such as the factorization of ambiguous FSTs, the proposed approach allows us to by-pass this problem. ε-cycles can be extracted before and re-inserted (by composition) after such algorithms.
CIAA 2001;On the Size of Deterministic Finite Automata;Bořivoj Melichar, Jan Skryja;The number of states of a deterministic finite automaton, which is equivalent to a nondeterministic finite automaton is bounded by 2n, where n is the number of states of the nondeterministic finite automaton. This bound is very pesimistic. Some subclasses of finite automata are shown, for which the complexity of determinization is far lower. On the base of pioneering idea of homogenous finite automata, two classes of finite automata are defined and the complexity of their determinization are shown. These classes are called generalized homogenous finite automata and semihomogenous finite automata.
CIAA 2001;Crystal Lattice Automata;Jim Morey, Kamran Sedig, Robert E. Mercer, Wayne Wilson;A description of crystal lattices in terms of automata is presented. The words of a language represented by an automata are mapped to points in R2 and R3 defining lattice points and their connections. These automata descriptions of crystal lattices reveal subtle properties that are difficult to see in other descriptions. A few applications of these automata are discussed.
CIAA 2001;Minimal Adaptive Pattern-Matching Automata for Efficient Term Rewriting;Nadia Nedjah, Luiza de Macedo Mourelle;In term rewriting systems, pattern-matching is performed according to a prescribed traversal order. By adapting the traversal order to suit the patterns of the rewriting system, it is often possible to obtain better matching automata in the sense that they have a smaller size and allow term matching in shorter time, compared with the left-to-right automaton. They may improve termination properties too. Space requirement is reduced further using a directed acyclic graph automaton that shares all the equivalent subautomata. This is done without altering either the matching time or termination properties. Isomorphic subautomata are duplicated in the tree-based automata. We discuss and develop an efficient approach to space requirement optimisation, matching time and termination properties improvement.
CIAA 2000;Synthesizing State-Based Object Systems from LSC Specifications;David Harel, Hillel Kugler;Live sequence charts (LSCs) have been defined recently as an extension of message sequence charts (MSCs. or their UML variant, sequence diagrams) for rich inter-object specification. One of the main additions is the notion of universal charts and hot, mandatory behavior, which, among other things, enables one to specify forbidden scenarios. LSCs are thus essentially as expressive as statecharts. This paper deals with synthesis, which is the problem of deciding, given an LSC specification, if there exists a satisfying object system and, if so, to synthesize one automatically. The synthesis problem is crucial in the development of complex systems, since sequence diagrams serve as the manifestation of use cases — whether used formally or informally — and if synthesizable they could lead directly to implementation. Synthesis is considerably harder for LSCs than for MSCs, and we tackle it by defining consistency, showing that an entire LSC specification is consistent iff it is satisfiable by a state-based object system, and then synthesizing a satisfying system as a collection of finite state machines or statecharts.
CIAA 2000;Applications of Finite-State Transducers in Natural Language Processing;Lauri Karttunen;This paper is a review of some of the major applications of finite-state transducers in Natural Language Processing ranging from morphological analysis to finite-state parsing. The analysis and generation of inflected word forms can be performed efficiently by means of lexical transducers. Such transducers can be compiled using an extended regular expression calculus with restriction and replacement operators. These operators facilitate the description of complex linguistic phenomena involving morphological alternations and syntactic patterns. Because regular languages and relations can be encoded as finite-automata, new languages and relations can be derived from them directly by the finite-state calculus. This is a fundamental advantage over higher-level linguistic formalisms.
CIAA 2000;Fast Implementations of Automata Computations;Anne Bergeron, Sylvie Hamel;In [6], G. Myers describes a bit-vector algorithm to compute the edit distance between strings. The algorithm converts an input sequence to an output sequence in a parallel way, using bit operations readily available in processors.
CIAA 2000;Regularly Extended Two-Way Nondeterministic Tree Automata;Anne Brüggemann-Klein, Derick Wood;We establish that regularly extended two-way nondeterministic tree automata with unranked alphabets have the same expressive power as regularly extended nondeterministic tree automata with unranked alphabets. We obtain this result by establishing regularly extended versions of a congruence on trees and of a congruence on, so called, views. Our motivation for the study of these tree models is the Extensible Markup Language (XML), a metalanguage for defining document grammars. Such grammars have regular sets of right-hand sides for their productions and tree automata provide an alternative and useful modeling tool for them. In particular, we believe that they provide a useful computational model for what we call caterpillar expressions.
CIAA 2000;Glushkov Construction for Multiplicities;Pascal Caron, Marianne Flouret;We present an extension to multiplicities of a classical algorithm for computing a boolean automaton from a regular expression. The Glushkov construction computes an automaton with n + 1 states from a regular expression with n occurences of letters. We show that the Glushkov algorithm still suits to the multiplicity case. Next, we give three equivalent extended step by step algorithm
CIAA 2000;Implicit Structures to Implement NFA’s from Regular Expressions;Jean-Marc Champarnaud;The aim of this paper is to compare three efficient representations of the position automaton of a regular expression: the Thompson ε-automaton, the ZPC-structure and the F-structure, an optimization of the ZPC-structure. These representations are linear w.r.t. the sizes of the expression, since their construction is in O(s) space and time, as well as the computation of the set δ(X, a) of the targets of the transitions by a of any subset X of states. The comparison is based on the evaluation of the number of edges of the underlying graphs respectively created by the construction step or visited by the computation of a set δ(X, a).
CIAA 2000;New Finite Automaton Constructions Based on Canonical Derivatives;Jean-Marc Champarnaud, D. Ziadi;Two classical constructions to convert a regular expression into a finite non-deterministic automaton provide complementary advantages: the notion of position of a symbol in an expression, introduced by Glushkov and McNaugthon-Yamada, leads to an efficient computation of the position automaton (there exist quadratic space and time implementations w.r.t. the size of the expression), whereas the notion of derivative of an expression w.r.t. a word, due to Brzozowski, and generalized by Antimirov, yields a small automaton. The number of states of this automaton, called the equation automaton, is less than or equal to the number of states of the position automaton, and in practice it is generally much smaller. So far, algorithms to build the equation automaton, such as Mirkin’s or Antimirov’s ones, have a high space and time complexity. The aim of this paper is to present new theoretical results allowing to compute the equation automaton in quadratic space and time, improving by a cubic factor Antimirov’s construction. These results lay on the computation of a new kind of derivative, called canonical derivative, which makes it possible to connect the notion of continuation in a linear expression due to Berry and Sethi, and the notion of partial derivative of a regular expression due to Antimirov. A main interest of the notion of canonical derivative is that it leads to an efficient computation of the equation automaton via a specific reduction of the position automaton.
CIAA 2000;Experiments with Automata Compression;Jan Daciuk;Several compression methods of finite-state automata are presented and evaluated. Most compression methods used here are already described in the literature. However, their impact on the size of automata has not been described yet. We fill that gap, presenting results of experiments carried out on automata representing German, and Dutch morphological dictionaries.
CIAA 2000;Computing Raster Images from Grid Picture Grammars;Frank Drewes, Sigrid Ewert, Renate Klempien-Hinrichs, Hans-Jörg Kreowski;While a 2-dimensional grid picture grammar may generate pictures (defined as subsets of the unit square) with arbitrarily small details, only a finite number of them can be made visible as raster images for any given raster. We present an algorithm based on bottom-up tree automata which computes the set of all raster images of the pictures generated by a given grid picture grammar.
CIAA 2000;A Basis for Looping Extensions to Discriminating-Reverse Parsing;Jacques Farré, José Fortes Gálvez;We present a noncanonical extension to the Discriminating Reverse parsing method, which accepts non-LR grammars. In cases of parsing conflict, actions are deferred and a mark is virtually pushed onto the parsing stack. Then, locally-canonical DR parsing resumes until sufficient right context is read to resolve the initial conflict. Marks code coverings of the right contexts that are compatible with the actions in conflict. A suboptimal solution for such a coding is proposed, which is computed from the DR automaton itself. The stack vocabulary is enlarged with the mark set, but no new state is added to the basic DR automaton. Moreover, conflict resolution basically uses the DR parser. The method determines at construction time whether all the conflicts can be resolved, and only produces deterministic parsers.
CIAA 2000;Automata for Pro-V Topologies;Pierre-Cyrille Héam;In this paper, we give an automata theoretic version of several algorithms dealing with profinite topologies. The profinite topology was first introduced for the free group by M. Hall, Jr. and by Reutenauer for the free monoid. It is the initial topology defined by all the monoid morphisms from the free monoid into a discrete finite group. For a variety of finite groups V, the pro-V topology is defined in the same way by replacing “group” by “group in V” in the definition. Recently, by a geometric approach, Steinberg developed an efficient algorithm to compute the closure, for some pro-V topologies (including the profinite one), of a rational language given by a finite automaton. In this paper we show that these algorithms can be obtained by an automata theoretic approach by using a result of Pin and Reutenauer. We also analyze precisely the complexity of these algorithms.
CIAA 2000;Reachability and Safety in Queue Systems;Oscar H. Ibarra;We look at a model of a queue system M that consists of the following components:
CIAA 2000;Generalizing the Discrete Timed Automaton;Oscar H. Ibarra, Jianwen Su;We describe a general automata-theoretic approach for analyzing the verification problems (binary reachability, safety, etc.) of discrete timed automata augmented with various data structures. We give examples of such data structures and exhibit some new properties of discrete timed automata that can be verified. We also briefly consider reachability in discrete timed automata operating in parallel.
CIAA 2000;Factorization of Ambiguous Finite-State Transducers;André Kempe;This article describes an algorithm for factorizing a finitely ambiguous finite-state transducer (FST) into two FSTs, T1 and T2, such that T1 is functional and T2 retains the ambiguity of the original FST. The application of T2 to the output of T1 never leads to a state that does not provide a transition for the next input symbol, and always terminates in a final state. In other words, T2 contains no “failing paths” whereas T1 in general does. Since T1 is functional, it can be factorized into a left-sequential and a right-sequential FST that jointly constitute a bimachine. The described factorization can accelerate the processing of input because no failing paths are ever followed.
CIAA 2000;MONA Implementation Secrets;Nils Klarlund, Anders Møller, Michael I. Schwartzbach;The Mona tool provides an implementation of the decision procedures for the logics WS1S and WS2S. It has been used for numerous applications, and it is remarkably efficient in practice, even though it faces a theoretically non-elementary worst-case complexity. The implementation has matured over a period of six years. Compared to the first naive version, the present tool is faster by several orders of magnitude. This speedup is obtained from many different contributions working on all levels of the compilation and execution of formulas. We present a selection of implementation “secrets” that have been discovered and tested over the years, including formula reductions, DAGification, guided tree automata, three-valued logic, eager minimization, BDD-based automata representations, and cache-conscious data structures. We describe these techniques and quantify their respective effects by experimenting with separate versions of the Mona tool that in turn omit each of them.
CIAA 2000;Cursors;Vincent Le Maout;The iterator concept is becoming the fundamental abstraction of reusable software and the key to modularity and clean code especially in object-oriented languages like C++ and Java. They serve as accessors to a sequence hiding the implementation details from the algorithm and their encapsulation power allows true generic programming. The Standard Template Library defines clearly their behavior on simple sequences like linked lists or vectors. In this paper, we define the concept of cursor which can be seen as a generalization of the iterator concept to more complex data structures than sequences, in this case acyclic automata. We show how elegant and efficient they can be on applications written in C++ and based on the Automaton Standard Template Library.
CIAA 2000;An Automaton Model of User-Controlled Navigation on the Web;K. Lodaya, R. Ramanujam;We present a simple theoretical model of web navigation, in which each WWW user creates style specifications which constrain web browsing, search and navigation using the user’s own judgement of the quality of visited sites. A finite state automaton is associated with each specification, which is presented in a two-level modal logic making up the acceptance condition for the automaton. We show that many interesting queries regarding the user’s web search can be answered using standard automata theory.
CIAA 2000;Direct Construction of Minimal Acyclic Subsequential Transducers;Stoyan Mihov, Denis Maurel;This paper presents an algorithm for direct building of minimal acyclic subsequential transducer, which represents a finite relation given as a sorted list of words with their outputs. The algorithm constructs the minimal transducer directly - without constructing intermediate tree-like or pseudo-minimal transducers. In NLP applications our algorithm provides significantly better efficiency than the other algorithms building minimal transducer for large-scale natural language dictionaries. Some experimental comparisons are presented at the end of the paper.
CIAA 2000;Generic ε-Removal Algorithm for Weighted Automata;Mehryar Mohri;We present a new generic ε-removal algorithm for weighted automata and transducers defined over a semiring. The algorithm can be used with any semiring covered by our framework and works with any queue discipline adopted. It can be used in particular in the case of unweighted automata and transducers and weighted automata and transducers defined over the tropical semiring. It is based on a general shortest-distance algorithm that we briefly describe. We give a full description of the algorithm including its pseudocode and its running time complexity, discuss the more efficient case of acyclic automata, an on-the-fly implementation of the algorithm and an approximation algorithm in the case of the semirings not covered by our framework. We also illustrate the use of the algorithm with several semirings.
CIAA 1999;FA Minimisation Heuristics for a Class of Finite Languages;Jérôme Amilhastre, Philippe Janssen, Marie-Catherine Vilarem;In this paper, we deal with minimization of finite automata associated with finite languages all the words have the same length. This problem arises in the context of Constraint Satisfaction Problems, widely used in AI. We first give some complexity results which are based on the strong relationship with covering problems of bipartite graphs. We then use these coverings as a basic tool for the definition of minimization heuristics, and describe some experimental results.
CIAA 1999;SEA: A Symbolic Environment for Automata Theory;Philippe Andary, Pascal Caron, Jean-Marc Champarnaud, Gérard Duchamp, Marianne Flouret, Éric Laugerotte;We here present the system SEA which integrates manipulations over boolean and multiplicity automata. The system provides also self development facilities.
CIAA 1999;Analysis of Reactive Systems with n Timers;Anne Bergeron, Riccardo Catalano;In this paper, we develop theoretical, as well as practical, tools for the synthesis and the verification of processes that contain n timers. Such tools are equally adapted to numerical calculations as to symbolical ones, thus allowing for parametric analysis. The results we have obtained rely on a simple and efficient representation of the states of an automaton that recognizes the behaviors of the process. This representation is based on a mechanical structure which helps us encode the states in a compact manner and leads to simple algorithms.
CIAA 1999;Animation of the Generation and Computation of Finite Automata for Learning Software;Beatrix Braune, Stephan Diehl, Andreas Kerren, Reinhard Wilhelm;In computer science methods to aid learning are very important, because abstract models are used frequently. For this conventional teaching methods do not suffice. We have developed a learning software, that helps the learner to better understand principles of compiler construction, in particular lexical analysis. The software offers on the one hand an interactive introduction to the problems of lexical analysis, in which the most important definitions and algorithms are presented in graphically appealing form. Animations show how finite automata are created from regular expressions, as well as, how finite automata work. We discuss principles used throughout the design of the software and give some preliminary results of evaluations of the software and discuss related work.
CIAA 1999;Metric Lexical Analysis;Cristian S. Calude, Kai Salomaa, Sheng Yu;We study automata-theoretic properties of distances and quasi-distances between words. We show that every additive distance is finite. We also show that every additive quasi-distance is regularitypreserving, that is, the neighborhood of any radius of a regular language with respect to an additive quasi-distance is regular. As an application we present a simple algorithm that constructs a metric (fault-tolerant) lexical analyzer for any given lexical analyzer and desired radius (faulttolerance index).
CIAA 1999;State Complexity of Basic Operations on Finite Languages;C. Câmpeanu, K. Culik II, Kai Salomaa, Sheng Yu;The state complexity of basic operations on regular languages has been studied in [9],[10],[11]. Here we focus on finite languages. We show that the catenation of two finite languages accepted by an mstate and an n-state DFA, respectively, with m &gt. n is accepted by a DFA of (m − n + 3)2n−2 − 1 states in the two-letter alphabet case, and this bound is shown to be reachable. We also show that the tight upperbounds for the number of states of a DFA that accepts the star of an n-state finite language is 2n−3 + 2n−4 in the two-letter alphabet case. The same bound for reversal is 3 · 2p−1 − 1 when n is even and 2p − 1 when n is odd. Results for alphabets of an arbitrary size are also obtained. These upper-bounds for finite languages are strictly lower than the corresponding ones for general regular languages.
CIAA 1999;Treatment of Unknown Words;Jan Daciuk;Words not present in the dictionary are almost always found in unrestricted texts. However, there is a need to obtain their likely base forms (in lemmatization), or morphological categories (in tagging), or both. Some of them find their ways into dictionaries, and it would be nice to predict what their entries should look like. Humans can perform those tasks using endings of words (sometimes prefixes and infixes as well), and so can do computers. Previous approaches used manually constructed lists of endings and associated information. Brill proposed transformation-based learning from corpora, and Mikheev used Brill’s approach on data for a morphological lexicon. However, both Brill’s algorithm, and Mikheev’s algorithm that is derived from Brill’s one, lack speed, both in the rule acquisition phase, and in the rule application phase. Their algorithms handle only the case of tagging, although an extension to other tasks seems possible. We propose a very fast finite-state method that handles all of the tasks described above, and that achieves similar quality of guessing.
CIAA 1999;Computing Entropy Maps of Finite-Automaton-Encoded Binary Images;Mark G. Eramian;Finite automata are being used to encode images. Applications of this technique include image compression, and extraction of self similarity information and Hausdorff dimension of the encoded image. Jürgensen and Staiger [7] proposed a method by which the local Hausdorff dimension of the encoded image could be effectively computed. This paper describes the first implementation of this procedure and presents some experimental results showing local entropy maps computed from images represented by finite automata.
CIAA 1999;Thompson Digraphs: A Characterization;Dora Giammarresi, Jean-Luc Ponty, Derick Wood;A finite-state machine is called a Thompson machine if it can be constructed from a regular expression using Thompson’s construction. We call the underlying digraph of a Thompson machine a Thompson digraph. We establish and prove a characterization of Thompson digraphs. As one application of the characterization, we give an algorithm that generates an equivalent regular expression from a Thompson machine in time linear in the number of states.
CIAA 1999;Finite Automata Encoding Geometric Figures;Helmut Jürgensen, Ludwig Staiger;Finite automata are used for the encoding and compression of images. For black-and-white images, for instance, using the quad-tree representation, the black points correspond to ω-words defining the corresponding paths in the tree that lead to them. If the ω-language consisting of the set of all these words is accepted by a deterministic finite automaton then the image is said to be encodable as a finite automaton. For grey-level images and colour images similar representations by automata are in use.
CIAA 1999;Compressed Storage of Sparse Finite-State Transducers;George Anton Kiraz;This paper presents an eclectic approach for compressing weighted finite-state automata and transducers, with minimal impact on performance. The approach is eclectic in the sense that various complementary methods have been employed: row-indexed storage of sparse matrices, dictionary compression, bit manipulation, and lossless omission of data. The compression rate is over 83% with respect to the current Bell Labs finite-state library.
CIAA 1999;An Extendible Regular Expression Compiler for Finite-State Approaches in Natural Language Processing;Gertjan van Noord, Dale Gerdemann;Finite-state techniques are widely used in various areas of Natural Language Processing (NLP).As Kaplan and Kay [12] have argued, regular expressions are the appropriate level of abstraction for thinking about finite-state languages and finite-state relations.More complex finite-state operations (such as contexted replacement) are defined on the basis of basic operations (such as Kleene closure, complementation, composition).
CIAA 1999;Multiset Processing by Means of Systems of Finite State Transducers;Gheorghe Păun, Gabriel Thierrin;We introduce a computing mechanism of a biochemical inspiration (similar to a P system from the area of Computing with Membranes) which consists of a multiset of symbol-objects and a set of finite state transducers. The transducers process symbols in the current multiset in the usual manner. A computation starts in an initial configuration and ends in a halting configuration. The power of these mechanisms is investigated, as well as the closure properties of the obtained family. The main results say that (1) systems with two components and an unbounded number of states in each component generate all gsm images of all permutation closures of recursively enumerable languages, while (2) systems with two states in each component but an unbounded number of components can generate the permutation closures of all recursively enumerable languages, and (3) the obtained family is a full AFL. Result (2) is related to a possible (speculative) implementation of our systems in biochemical media.
CIAA 1999;A Structural Method for Output Compaction of Sequential Automata Implemented as Circuits;M. Seuring, M. Gössel;In this paper output space compaction for sequential circuits is considered for the first time. Based on simple estimates for the probabilities of the existence of sensitized paths from the signal lines to the circuit outputs, optimal output partitions can be determined without fault simulation. The outputs are partitioned in such a way that internal stuck-at faults influence at most one of the outputs of a group with high probability. The proposed method is primarily developed for concurrent checking. On average with less than 4 compacted groups of outputs an error detection probability of 98% can be achieved. As the experimental results show, the method is also effectively applicable in pseudo-random test mode. On average for three groups of compacted outputs there is no reduction of the fault coverage for a pseudo-random off-line test. Since the proposed algorithm is of linear complexity with respect to the number of circuit lines and of quadratic complexity with respect to the number of primary circuit outputs large automata can be efficiently processed.
CIAA 1999;An Algorithm to Verify Local Threshold Testability of Deterministic Finite Automata;A.N. Trahtman;A locally threshold testable language L is a language with the property that for some nonnegative integers k and l, whether or not a word u is in the language L depends on (1) the prefix and suffix of the word u of length k-1 and (2) the set of intermediate substrings of length k of the word u where the sets of substrings occurring at least j times are the same, for j ≤ l. For given k and l the language is called l-threshold ktestable. A finite deterministic automaton is called l-threshold k-testable
CIAA 1999;A Taxonomy of Algorithms for Constructing Minimal Acyclic Deterministic Finite Automata;Bruce W. Watson;In this paper, we present a taxonomy of algorithms for constructing minimal acyclic deterministic finite automata (MADFAs).Suc h automata represent finite languages and are therefore useful in applications such as storing words for spell-checking, computer and biological virus searching, text indexing and XML tag lookup.In such applications, the automata can grow extremely large (with more than 106 states) and are difficult to store without compression or minimization.
CIAA 1998;Extended Context-Free Grammars and Normal Form Algorithms;Jürgen Albert, Dora Giammaressi, Derick Wood;We investigate the complexity of a variety of normal-form transformations for extended context-free grammars, where by extended we mean that the set of right-hand sides for each nonterminal in such a grammar is a regular set. The study is motivated by the implementation project GraMa which will provide a C++ toolkit for the symbolic manipulation of context-free objects just as Grail does for regular objects. The results are that all transformations of interest take time linear in the size of the given grammar giving resulting grammars that are larger by a constant factor than the original grammar. Our results generalize known bounds for context-free grammars but do so in nontrivial ways. Specifically, we introduce a new representation scheme for extended context-free grammars (the symbol-threaded expression forest), a new normal form for these grammars (dot normal form) and new regular expression algorithms.
CIAA 1998;On Parsing LL-Languages;Norbert Blum;Usually, a parser for an LL(k)-grammar G is a deterministic pushdown transducer which produces a leftmost derivation for a given input string x ∈ L(G). Ukkonen [<a aria-label="Reference 5" data-test="citation-ref" data-track="click" data-track-action="reference anchor" data-track-label="link" href="#ref-CR5" id="ref-link-section-d50842506e486" title="E. Ukkonen, Lower bound on the size of deterministic parsers, JCSS                        26 (1983), 153–170.">5] has given a family of LL(2)- grammars proving that every parser for these grammars has exponential size. If we add to a parser the possibility to manipulate a constant num- ber of pointers which point to positions within the constructed part of the leftmost derivation and to change the output in such positions, we obtain an extended parser for the LL(k)-grammar G. Given an arbitrary LL(k)-grammar G, we will show how to construct an extended parser of polynomial size manipulating at most k2 pointers.
CIAA 1998;On Parsing and Condensing Substrings of LR Languages in Linear Time;Heiko Goeman;LR parsers have long been known as being an efficient algorithm for recognizing deterministic context-free grammars. In this article, we present a linear—time method for parsing substrings of LR languages. The algorithm depends on the LR automaton that is used for the usual parsing of complete sentences. We prove the correctness and linear complexity of our algorithm and present an interesting extension of our substring parser that allows to condense the input string, which increases the speed when reparsing that string for a second time.
CIAA 1998;Minimal Cover-Automata for Finite Languages;Cezar Câmpeanu, Nicolae Sântean, Sheng Yu;A cover-automaton A of a finite language L ⊆ Σ* is a finite automaton that accepts all words in L and possibly other words that are longer than any word in L. A minimal deterministic cover automaton of a finite language L usually has a smaller size than a minimal DFA that accept L. Thus, cover automata can be used to reduce the size of the representations of finite languages in practice. In this paper, we describe an efficient algorithm that, for a given DFA accepting a finite language, constructs a minimal deterministic finite coverautomaton of the language. We also give algorithms for the boolean operations on deterministic cover automata, i.e., on the finite languages they represent.
CIAA 1998;Determinization of Glushkov Automata;Jean-Marc Champarnaud, Djelloul Ziadi, Jean-Luc Ponty;We establish a new upper bound on the number of states of the automaton yielded by the determinization of a Glushkov automaton. We show that the ZPC structure, which is an implicit construction for Glushkov automata, leads to an efficient implementation of the subset construction.
CIAA 1998;Implementing Reversed Alternating Finite Automaton (r-AFA) Operations;Sandra Huerter, Kai Salomaa, Xiuming Wu, Sheng Yu;In [17], we introduced a bit-wise representation of r-AFA, which greatly improved the space efficiency in representing regular languages. We also described our algorithms and implementation methods for the union, intersection, and complementation of r-AFA. However, our direct algorithms for the star, concatenation, and reversal operations of r- AFA would cause an exponential expansion in the size of resulting r-AFA for even the average cases. In this paper, we will design new algorithms for the star, concatenation, and reversal operations of r-AFA based on the bit-wise representation introduced in [17]. Experiments show that the new algorithms can significantly reduce the state size of the resulting r- AFA. We also show how we have improved the DFA-to-AFA transformation algorithm which was described in [17]. The average run time of this transformation using the modified algorithm has improved significantly (by 97 percent).
CIAA 1998;Operations on DASG;Zdeněk Tronìček;Acyclic Subsequence Graph (DASG) is an automaton that accepts all subsequences of a given string T. DASG allows us to decide whether a string S is a subsequence of T in O(|S|) time where |S| is the length of S. We show that if we slightly modify the string T, it is possible to get the DASG for the modified string from the original DASG. For this purpose we define these operations on DASG: adding a state on the left, deleting a state on left, adding a state on the right, deleting a state on the right, adding an inner state, deleting an inner state and replacing a transition label. For each of these operations we describe the modification of DASG and the proof of correctness.
CIAA 1998;Implementation of Nondeterministic Finite Automata for Approximate Pattern Matching;Jan Holub, Bořivoj Melichar;There are two ways of using the nondeterministic finite automata (NFA). The first one is the transformation to the equivalent deterministic finite automaton and the second one is the simulation of the run of NFA. In this paper we discuss the second way. We present an overview of the simulation methods that have been found in the approximate string matching. We generalize these simulation methods and form the rules for the usage of these methods.
CIAA 1998;The Syntactic Prediction with Token Automata: Application to HandiAS System;Denis Maurel, Brigitte Le Pévédic, Olivier Rousseau;This paper presents an adjustable way of syntactic prediction on the basis of left context with token automata. Our purpose is to predict the end of a word on the basis of its first letters keyboarding. We illustrate our intention with the presentation of a prototype software for disabled communication aid, called HandiAS.
CIAA 1998;Bi-directional Automata to Extract Complex Phrases from Texts;Thierry Poibeau;This paper presents an experiment to develop natural-language tools to improve the quality of documents. These softwares are using finite-state automata enriched with notions of proximity, optionality and contextual information. They are called bi-directional because they need to parse a sequence not only from the left to right-hand side of a sentence, but on both sides of a word. This method improves efficiency.
CIAA 1998;A Fast New Semi-incremental Algorithm for the Construction of Minimal Acyclic DFAs;Bruce W. Watson;We present a semi-incremental algorithm for constructing minimal acyclic deterministic finite automata. Such automata are useful for storing sets of words for spell-checking, among other applications. The algorithm is semi-incremental because it maintains the automaton in near-minimal condition and requires a final minimization step after the last word has been added (during construction).
CIAA 1998;Using Acceptors as Transducers;Matti Nykänen;We wish to use a given nondeterministic two-way multi-tape acceptor as a transducer by supplying the contents for only some of its input tapes, and asking it to generate the missing contents for the other tapes. We provide here an algorithm for determining beforehand whether this transduction always results in a finite set of answers or not. We also develop an algorithm for evaluating these finite answers whenever the previous algorithm indicated their existence. Our algorithms can also be used for speeding up the simulation of these acceptors even when not used as transducers.
CIAA 1998;Proving Sequential Function Chart Programs Using Automata;Dominique L’Her, Philippe Le Parc, Lionel Marcé;Applications described by Sequential Function Chart (SFC) often being critical, we have studied the possibilities of program checking. In particular, physical time can be handled by SFC programs using temporisations, that’s why we are interested in the quantitative temporal properties. We have proposed a modeling of SFC in timed automata, a formalism which takes time into account. In this modeling, we use the physical constraints of the environment. Verification of properties can be carried out using the model-checker Kronos. We apply this method to SFC programs of average size like the one of the controlling part of the production cell Korso. The size of the programs remaining however a limit, we are studying the means of solving this problem.
CIAA 1998;Automata and Computational Probabilities;Marie-Chantal Beaulieu, Anne Bergeron;In this paper, we discuss the underlying ideas of a computer laboratory for symbolic manipulation of discrete random experiments. Finite automata, and associated formal series, are the basic theoretical tool for representing experiments, and for solving probability problems. Starting from a description of a random experiment given as a special kind of regular expressions, the environment constructs automata from which it extracts generating series associated to the experiment.
CIAA 1998;Automata and Binary Decision Diagrams;Jean-Francis Michon, Jean-Marc Champarnaud;We show that the concept of automata minimization leads to a nice interpretation of the famous canonicity of binary decision diagrams discovered by Bryant.
CIAA 1998;Operations over Automata with Multiplicities;Gérard Duchamp, Marianne Flouret, Éric Laugerotte;We present here theoretical results coming from the implementation of the package called AMULT (automata with multiplicities in several noncommutative variables). We show that classical formulas are “almost every time” optimal and characterize the dual laws preserving rationality.
CIAA 1998;Paging Automata;Ricardo Ueda Karpischek;We present biba, a package designed to deal with representations of large automata. It offers a library able to build, even on a modest computer, automata where the sum of the numbers of states and edges achieves one billion or more. Two applications that use this library are provided as examples. They build the reduced automaton for a given vocabulary, and the suffix automaton of a given word. New programs can be developed using this library. In order to overcome physical memory limitations, biba implements a paging scheme, in such a way that the automata really reside on disk, making possible their permanent storage. Through a simple interface suited for perl, small scripts can be easily written to use and extract informations from these automata.
CIAA 1998;On the Syntax, Semantics, and Implementation of a Graph-Based Computational Environment;Yuri Velinov;In the present paper we consider the abstract background for designing a practical graph-based computational environment with variable, optional semantics. From the variety of possibilities we concentrate on graphs and polynets as possible carriers of the syntax, and finite automata and flow-diagram programs as possible semantics. We discuss the encapsulation property which emerges in such systems and give precise description of the syntax, operational and denotational semantics in terms of Category Theory. A data structure capable to meet the requirements of a graph-based computational environment is sketched at the end.
CIAA 1998;The Finite State Automata’s Design Patterns;Sandro Pedrazzini;In this article we want to discuss the design patterns used and proposed for the realization of finite state automata. Various aspects in the design of a framework for the implementation of FSA will be treated, presenting not only the patterns for the single components, but the entire system design. Using design patterns to sketch a framework means performing an ”abstract implementation”, from which it is possible to realize concrete specific automata, simply customizing some classes. In order to test the framework, some concrete lexical tools have been created. The resulting automata and transducers are used to perform word form analysis, word form generation, creation and derivation history, spellchecking and phrase recognition.
CIAA 1996;WIA and the practice of theory in computer science;Darrell Raymond;Unable to display preview. Download preview PDF.
CIAA 1996;Algorithms for guided tree automata;Morten Biehl, Nils Klarlund, Theis Rauhe;When reading an input tree, a bottom-up tree automaton is] “unaware” of where it is relative to the root. This problem is important to the efficient implementation of decision procedures for the Monadic Second-order Logic (M2L) on finite trees. In [KS97], it is shown how exponential state space blow-ups may occur in common situations. The analysis of the problem leads to the notion of guided tree automaton for combatting such explosions. The guided automaton is equipped with separate state spaces that are assigned by a top-down automaton, called the guide.
CIAA 1996;Time series forecasting by finite-state automata;Romuald Boné, Christophe Daguin, Antoine Georgevail, Denis Maurel;We have developed automata to address the problem of time series forecasting. After turning the time series into sequences of letters, Mohri's algorithm constructs an automaton indexing this text that, once a given word is read, can be used to obtain the set of its positions. By using the automaton to determine what letter usually follows the last sequence of length L, we have developed a one step predictor. This predictor will be used to analyze sunspot activity data.
CIAA 1996;Dynamical implementation of nondeterministic automata and concurrent systems;Max Garzon, Eugene Eberbach;Several recent results have implemented a number of deterministic automata (finite-state, pushdown, even Turing machines and neural nets) using piecewise linear dynamical systems in one- and two-dimensional euclidean spaces. Nondeterministic devices have only been likewise implemented by iterated systems containing several maps. We show how to simulate nondeterministic and concurrent systems (finite-state automata, pushdown automata, and Petri nets) using a single deterministic piecewise linear map of the real interval. As a consequence, we establish a correspondence between nondeterminism and incremental entropy of the corresponding dynamical system. Relationship to the separation of complexity classes is discussed.
CIAA 1996;Implementing WS1S via finite automata;James Glenn, William Gasarch;It has long been known that WSIS is decidable through the use of finite automata. However, since the worst-case running time has been proven to grow extremely quickly, few have explored the implementation of the algorithm. In this paper we describe some of the points of interest that have come up while coding and running the algorithm. These points include the data structures used as well as the special features of the automata, which we can exploit to perform minimization very quickly in certain cases. We also present some data that enable us to gain insight into how the algorithm performs in the average case, both on random inputs and on inputs that come from the use of Presburger Arithmetic (which can be converted to WSIS) in compiler optimization.
CIAA 1996;Instruction computation in subset construction;J. Howard Johnson, Derick Wood;Subset construction is the method of converting a nondeterministic finite-state machine into a deterministic one. The process of determinization is important in any implementation of finite-state machines. The reasons are that nondeterministic machines are often easier to describe than their deterministic equivalents and the conversion of regular expressions to finite-state machines usually produces nondeterministic machines.
CIAA 1996;Building automaton on schemata and acceptability tables;Denis Maurel;This paper presents a lexical finite states automaton to parse French Date Adverbials. To build this automaton, I have developed an original model of representation (Schemata and Acceptability Tables), the computation and use of which I will explain in this paper.
CIAA 1996;FSA utilities: A toolbox to manipulate finite-state automata;Gertjan van Noord;This paper describes the FSA Utilities toolbox: a collection of utilities to manipulate finite-state automata and finite-state transducers. Manipulations include determinization (both for finite-state acceptors and finite-state transducers), minimization, composition, complementation, intersection, Kleene closure, etc. Furthermore, various visualization tools are available to browse finite-state automata. The toolbox is implemented in SICStus Prolog.
CIAA 1996;A new quadratic algorithm to convert a regular expression into an automaton;J. -L. Ponty, D. Ziadi, J. -M. Champarnaud;We present a new sequential algorithm to convert a regular expression into its Glushkov automaton. This conversion runs in quadratic time, so it has the same time complexity as the Brüggemann-Klein algorithm and the Chang and Paige one. It provides, however, a representation of the Glushkov automaton that needs only linear space.
CIAA 1996;Implementing sequential and parallel programs for the homing sequence problem;B. Ravikumar, X. Xiong;Homing sequences play an important role in the testing of finite state systems and have been used in a number of applications such as hardware fault-detection [7], protocol verification [4], and learning algorithms [11, 3, 1] etc. Here we present a parallel program implementation that finds a homing sequence for an input DFA. Our program can handle randomly generated instances with millions of states, and all DFA's with thousand states. In addition to the design, analysis and implementation of the algorithm, we also discuss what constitute good test cases to test programs that deal with finite automata.
CIAA 1996;Integrating hands-on work into the formal languages course via tools and programming;Susan H. Rodger;Integrating hands-on practice into an automata and formal languages course aids in transforming the course from a traditional mathematics course into a traditional computer science course, while making the material more interesting from both teaching and learning perspectives. The interactive and visual tools we integrate into our course are FLAP, a tool for constructing and simulating several types of nondeterministic automata, and LLparse and LRparse, tools for constructing parse tables and animating the parsing of strings. As a programming component, our students are also required to write an LR(1) parser for a simple programming language, using the tool Xtango to animate programs in this new language.
CIAA 1996;NFA to DFA transformation for finite languages;Kai Salomaa, Sheng Yu;We consider the number of states of a DFA that is equivalent to an n-state NFA accepting a finite language. We first give a detailed proof for the case where the finite languages are over a two-letter alphabet. It shows that O(2n/2) is the (worst-case) optimal upper-bound on the number of states of a DFA that is equivalent to an n-state NFA accepting a finite language. The main result of this paper is a generalization of the above result. We show that, for any n-state NFA accepting a finite language over an arbitrary k-letter alphabet, n, k&gt.1, there is an equivalent DFA of \(O(k^{{n \mathord{\left/{\vphantom {n {(\log _2 k + 1)}}} \right.\kern-\nulldelimiterspace} {(\log _2 k + 1)}}} )\)states, and show that this bound is optimal in the worst case.
CIAA 1996;How to use sorting procedures to minimize DFA;Barbara Schubert;In this paper we introduce a new idea, which can be used in minimization of a deterministic finite automaton. Namely, we associate names with states of an automaton and we sort them. We give a new algorithm, its correctness proof, and its proof of execution time bound. This algorithm has time complexity O(n2 log n) and can be considered as a direct improvement of Wood's algorithm [6] which has time complexity O(n3), where n is the number of states. Wood's algorithm checks if pairs of states are distinguishable. It is improved by making better use of transitivity. Similarly some other algorithms which check if pairs of states are distinguishable can be improved using sorting procedures.
CIAA 1996;FIRE Lite: FAs and REs in C++;Bruce W. Watson;This paper describes a C++ finite automata toolkit known as FIRE Lite (Finite automata and Regular Expressions. Lite since it is the smaller and newer cousin of the FIRE Engine toolkit, also originally developed at the Eindhoven University of Technology). The client interface and aspects of the design and implementation are also described. The toolkit includes implementations of almost all of the known automata construction algorithms and many of the deterministic automata minimization algorithms. These implementations enabled us to collect performance data on these algorithms. The performance data, which we believe to be the first extensive benchmarks of the algorithms, are also summarized in this paper.
